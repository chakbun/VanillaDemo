// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/crack_egg.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/CrackEggExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3CrackEggExtRoot

@implementation PB3CrackEggExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3CrackEggExtRoot_FileDescriptor

static GPBFileDescriptor *PB3CrackEggExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3CrackEggCmdId

GPBEnumDescriptor *PB3CrackEggCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None401\000CrackCmdId\000OpenCmdId\000CrackShift\000"
        "CrackShiftNotice\000CrackHour\000CrackLuckCmdI"
        "d\000CrackLuckGain\000CrackLuckNotice\000CrackTim"
        "e\000CrackLuckValue\000";
    static const int32_t values[] = {
        PB3CrackEggCmdId_None401,
        PB3CrackEggCmdId_CrackCmdId,
        PB3CrackEggCmdId_OpenCmdId,
        PB3CrackEggCmdId_CrackShift,
        PB3CrackEggCmdId_CrackShiftNotice,
        PB3CrackEggCmdId_CrackHour,
        PB3CrackEggCmdId_CrackLuckCmdId,
        PB3CrackEggCmdId_CrackLuckGain,
        PB3CrackEggCmdId_CrackLuckNotice,
        PB3CrackEggCmdId_CrackTime,
        PB3CrackEggCmdId_CrackLuckValue,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CrackEggCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CrackEggCmdId_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CrackEggCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CrackEggCmdId_None401:
    case PB3CrackEggCmdId_CrackCmdId:
    case PB3CrackEggCmdId_OpenCmdId:
    case PB3CrackEggCmdId_CrackShift:
    case PB3CrackEggCmdId_CrackShiftNotice:
    case PB3CrackEggCmdId_CrackHour:
    case PB3CrackEggCmdId_CrackLuckCmdId:
    case PB3CrackEggCmdId_CrackLuckGain:
    case PB3CrackEggCmdId_CrackLuckNotice:
    case PB3CrackEggCmdId_CrackTime:
    case PB3CrackEggCmdId_CrackLuckValue:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3Award

@implementation PB3Award

@dynamic giftId;
@dynamic giftNum;
@dynamic isFree;

typedef struct PB3Award__storage_ {
  uint32_t _has_storage_[1];
  uint32_t giftId;
  uint32_t giftNum;
} PB3Award__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Award_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Award__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Award_FieldNumber_GiftNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Award__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isFree",
        .dataTypeSpecific.className = NULL,
        .number = PB3Award_FieldNumber_IsFree,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Award class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Award__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggRecord

@implementation PB3CrackEggRecord

@dynamic playerId;
@dynamic playerNickname;
@dynamic awardId;
@dynamic awardNum;
@dynamic msg;
@dynamic freeId;
@dynamic freeNum;
@dynamic roomId;
@dynamic showMe;
@dynamic deviceType;
@dynamic msgSignArray, msgSignArray_Count;

typedef struct PB3CrackEggRecord__storage_ {
  uint32_t _has_storage_[1];
  uint32_t awardId;
  uint32_t freeId;
  PB3DeviceType deviceType;
  NSString *playerNickname;
  NSString *msg;
  NSMutableArray *msgSignArray;
  uint64_t playerId;
  int64_t awardNum;
  int64_t freeNum;
  int64_t roomId;
} PB3CrackEggRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "playerNickname",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_PlayerNickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, playerNickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "awardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_AwardId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, awardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "awardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_AwardNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, awardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_Msg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "freeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_FreeId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, freeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "freeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_FreeNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, freeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_RoomId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "showMe",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_ShowMe,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3CrackEggRecord_FieldNumber_DeviceType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgSignArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRecord_FieldNumber_MsgSignArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CrackEggRecord__storage_, msgSignArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggRecord class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CrackEggRecord_DeviceType_RawValue(PB3CrackEggRecord *message) {
  GPBDescriptor *descriptor = [PB3CrackEggRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CrackEggRecord_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CrackEggRecord_DeviceType_RawValue(PB3CrackEggRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CrackEggRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CrackEggRecord_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CrackEggNotice

@implementation PB3CrackEggNotice

@dynamic code;
@dynamic msg;

typedef struct PB3CrackEggNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *msg;
} PB3CrackEggNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggNotice_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggNotice__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggNotice_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggNotice class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackTime

@implementation PB3CrackTime

@dynamic time;

typedef struct PB3CrackTime__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
} PB3CrackTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTime_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackTime__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackTime class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggReq

@implementation PB3CrackEggReq

@dynamic open;
@dynamic assetsType;

typedef struct PB3CrackEggReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t assetsType;
} PB3CrackEggReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "open",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggReq_FieldNumber_Open,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "assetsType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggReq_FieldNumber_AssetsType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggReq__storage_, assetsType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggRes

@implementation PB3CrackEggRes

@dynamic awardsArray, awardsArray_Count;
@dynamic gold;
@dynamic luckyValueRatio;
@dynamic addLuckyValue;

typedef struct PB3CrackEggRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t luckyValueRatio;
  int32_t addLuckyValue;
  NSMutableArray *awardsArray;
} PB3CrackEggRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "awardsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Award),
        .number = PB3CrackEggRes_FieldNumber_AwardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CrackEggRes__storage_, awardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRes_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggRes__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "luckyValueRatio",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRes_FieldNumber_LuckyValueRatio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggRes__storage_, luckyValueRatio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "addLuckyValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRes_FieldNumber_AddLuckyValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggRes__storage_, addLuckyValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggShiftReq

@implementation PB3CrackEggShiftReq

@dynamic opType;

typedef struct PB3CrackEggShiftReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
} PB3CrackEggShiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftReq_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftReq__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggShiftReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggShiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggShiftRes

@implementation PB3CrackEggShiftRes

@dynamic opType;
@dynamic hasShift, shift;
@dynamic crackeggExchangeURL;
@dynamic crackeggMillionForestURL;
@dynamic crackeggDescriptionURL;

typedef struct PB3CrackEggShiftRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
  PB3CrackEggShift *shift;
  NSString *crackeggExchangeURL;
  NSString *crackeggMillionForestURL;
  NSString *crackeggDescriptionURL;
} PB3CrackEggShiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftRes_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftRes__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shift",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CrackEggShift),
        .number = PB3CrackEggShiftRes_FieldNumber_Shift,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftRes__storage_, shift),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "crackeggExchangeURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftRes_FieldNumber_CrackeggExchangeURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftRes__storage_, crackeggExchangeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crackeggMillionForestURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftRes_FieldNumber_CrackeggMillionForestURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftRes__storage_, crackeggMillionForestURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crackeggDescriptionURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftRes_FieldNumber_CrackeggDescriptionURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftRes__storage_, crackeggDescriptionURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggShiftRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggShiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\010\250\241!!\000\004\010\247\246\241!!\000\005\010\253\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggShift

@implementation PB3CrackEggShift

@dynamic num;
@dynamic maxNum;
@dynamic timeout;

typedef struct PB3CrackEggShift__storage_ {
  uint32_t _has_storage_[1];
  int64_t num;
  int64_t maxNum;
  int64_t timeout;
} PB3CrackEggShift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShift_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggShift__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShift_FieldNumber_MaxNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggShift__storage_, maxNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShift_FieldNumber_Timeout,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggShift__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggShift class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggShift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggHour

@implementation PB3CrackEggHour

@dynamic code;
@dynamic msg;

typedef struct PB3CrackEggHour__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *msg;
} PB3CrackEggHour__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggHour_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggHour__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggHour_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggHour__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggHour class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggHour__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggShiftNotice

@implementation PB3CrackEggShiftNotice

@dynamic msg;

typedef struct PB3CrackEggShiftNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} PB3CrackEggShiftNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggShiftNotice_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggShiftNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggShiftNotice class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggShiftNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggLuck

@implementation PB3CrackEggLuck

@dynamic gold;
@dynamic mtime;

typedef struct PB3CrackEggLuck__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int64_t mtime;
} PB3CrackEggLuck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuck_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggLuck__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mtime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuck_FieldNumber_Mtime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggLuck__storage_, mtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggLuck class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggLuck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggLuckGain

@implementation PB3CrackEggLuckGain

@dynamic id_p;
@dynamic playerId;
@dynamic playerNickname;
@dynamic gold;
@dynamic giftId;
@dynamic giftNum;
@dynamic msg;

typedef struct PB3CrackEggLuckGain__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t gold;
  int32_t giftId;
  int32_t giftNum;
  NSString *playerNickname;
  NSString *msg;
  uint64_t playerId;
} PB3CrackEggLuckGain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "playerNickname",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_PlayerNickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, playerNickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_Gold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_GiftId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_GiftNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckGain_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckGain__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggLuckGain class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggLuckGain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggLuckReq

@implementation PB3CrackEggLuckReq

@dynamic opType;

typedef struct PB3CrackEggLuckReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
} PB3CrackEggLuckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckReq_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckReq__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggLuckReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggLuckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggLuckRes

@implementation PB3CrackEggLuckRes

@dynamic opType;
@dynamic hasLuck, luck;

typedef struct PB3CrackEggLuckRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
  PB3CrackEggLuck *luck;
} PB3CrackEggLuckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckRes_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckRes__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "luck",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CrackEggLuck),
        .number = PB3CrackEggLuckRes_FieldNumber_Luck,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckRes__storage_, luck),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggLuckRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggLuckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggLuckNotice

@implementation PB3CrackEggLuckNotice

@dynamic gold;
@dynamic msg;

typedef struct PB3CrackEggLuckNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  NSString *msg;
} PB3CrackEggLuckNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckNotice_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckNotice__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggLuckNotice_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggLuckNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggLuckNotice class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggLuckNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggRank

@implementation PB3CrackEggRank

@dynamic id_p;
@dynamic name;
@dynamic level;
@dynamic resTime;
@dynamic gapVal;
@dynamic icon;
@dynamic desc;

typedef struct PB3CrackEggRank__storage_ {
  uint32_t _has_storage_[1];
  uint32_t level;
  uint32_t resTime;
  uint32_t gapVal;
  NSString *name;
  NSString *icon;
  NSString *desc;
  int64_t id_p;
} PB3CrackEggRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_Level,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_ResTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, resTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gapVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_GapVal,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, gapVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_Icon,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRank_FieldNumber_Desc,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CrackEggRank__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggRank class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\007\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggRankReq

@implementation PB3CrackEggRankReq

@dynamic opType;

typedef struct PB3CrackEggRankReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
} PB3CrackEggRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRankReq_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggRankReq__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggRankReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackEggRankRes

@implementation PB3CrackEggRankRes

@dynamic opType;
@dynamic listArray, listArray_Count;

typedef struct PB3CrackEggRankRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t opType;
  NSMutableArray *listArray;
} PB3CrackEggRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackEggRankRes_FieldNumber_OpType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackEggRankRes__storage_, opType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CrackEggRank),
        .number = PB3CrackEggRankRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CrackEggRankRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackEggRankRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackEggRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCrackTimeReq

@implementation PB3GetCrackTimeReq


typedef struct PB3GetCrackTimeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetCrackTimeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCrackTimeReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetCrackTimeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCrackTimeRes

@implementation PB3GetCrackTimeRes

@dynamic time;

typedef struct PB3GetCrackTimeRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
} PB3GetCrackTimeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCrackTimeRes_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetCrackTimeRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCrackTimeRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCrackTimeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackCopywritingReq

@implementation PB3CrackCopywritingReq


typedef struct PB3CrackCopywritingReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CrackCopywritingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackCopywritingReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CrackCopywritingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackCopywritingRes

@implementation PB3CrackCopywritingRes

@dynamic keyword;
@dynamic copywritingURL;

typedef struct PB3CrackCopywritingRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *keyword;
  NSString *copywritingURL;
} PB3CrackCopywritingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyword",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackCopywritingRes_FieldNumber_Keyword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackCopywritingRes__storage_, keyword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "copywritingURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackCopywritingRes_FieldNumber_CopywritingURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackCopywritingRes__storage_, copywritingURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackCopywritingRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackCopywritingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CrackTheme

@implementation PB3CrackTheme

@dynamic id_p;
@dynamic name;
@dynamic type;
@dynamic status;
@dynamic startTime;
@dynamic endTime;
@dynamic key;
@dynamic iosURL;
@dynamic androidURL;
@dynamic pcURL;
@dynamic progressCol;
@dynamic progressBorderCol;
@dynamic progressBackgCol;
@dynamic buyCol;
@dynamic onCol;
@dynamic offCol;
@dynamic luckCol;

typedef struct PB3CrackTheme__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t type;
  NSString *name;
  NSString *key;
  NSString *iosURL;
  NSString *androidURL;
  NSString *pcURL;
  NSString *progressCol;
  NSString *progressBorderCol;
  NSString *progressBackgCol;
  NSString *buyCol;
  NSString *onCol;
  NSString *offCol;
  NSString *luckCol;
  int64_t startTime;
  int64_t endTime;
} PB3CrackTheme__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_Status,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_StartTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_EndTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_Key,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_IosURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, iosURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_AndroidURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, androidURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_PcURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, pcURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "progressCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_ProgressCol,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, progressCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "progressBorderCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_ProgressBorderCol,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, progressBorderCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "progressBackgCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_ProgressBackgCol,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, progressBackgCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buyCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_BuyCol,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, buyCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_OnCol,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, onCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "offCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_OffCol,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, offCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "luckCol",
        .dataTypeSpecific.className = NULL,
        .number = PB3CrackTheme_FieldNumber_LuckCol,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3CrackTheme__storage_, luckCol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CrackTheme class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CrackTheme__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\010\003\241!!\000\t\007\241!!\000\n\002\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCrackThemeReq

@implementation PB3GetCrackThemeReq


typedef struct PB3GetCrackThemeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetCrackThemeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCrackThemeReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetCrackThemeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCrackThemeRes

@implementation PB3GetCrackThemeRes

@dynamic themesArray, themesArray_Count;

typedef struct PB3GetCrackThemeRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *themesArray;
} PB3GetCrackThemeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "themesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CrackTheme),
        .number = PB3GetCrackThemeRes_FieldNumber_ThemesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetCrackThemeRes__storage_, themesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCrackThemeRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCrackThemeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NoticeShiftReq

@implementation PB3NoticeShiftReq

@dynamic playerId;
@dynamic oper;

typedef struct PB3NoticeShiftReq__storage_ {
  uint32_t _has_storage_[1];
  PB3NoticeShiftReq_Operation oper;
  int64_t playerId;
} PB3NoticeShiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3NoticeShiftReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NoticeShiftReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "oper",
        .dataTypeSpecific.enumDescFunc = PB3NoticeShiftReq_Operation_EnumDescriptor,
        .number = PB3NoticeShiftReq_FieldNumber_Oper,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3NoticeShiftReq__storage_, oper),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NoticeShiftReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NoticeShiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3NoticeShiftReq_Oper_RawValue(PB3NoticeShiftReq *message) {
  GPBDescriptor *descriptor = [PB3NoticeShiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NoticeShiftReq_FieldNumber_Oper];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3NoticeShiftReq_Oper_RawValue(PB3NoticeShiftReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3NoticeShiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NoticeShiftReq_FieldNumber_Oper];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PB3NoticeShiftReq_Operation

GPBEnumDescriptor *PB3NoticeShiftReq_Operation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknow\000TurnOnNotice\000TurnOffNotice\000GetNot"
        "iceStatus\000";
    static const int32_t values[] = {
        PB3NoticeShiftReq_Operation_Unknow,
        PB3NoticeShiftReq_Operation_TurnOnNotice,
        PB3NoticeShiftReq_Operation_TurnOffNotice,
        PB3NoticeShiftReq_Operation_GetNoticeStatus,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3NoticeShiftReq_Operation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3NoticeShiftReq_Operation_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3NoticeShiftReq_Operation_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3NoticeShiftReq_Operation_Unknow:
    case PB3NoticeShiftReq_Operation_TurnOnNotice:
    case PB3NoticeShiftReq_Operation_TurnOffNotice:
    case PB3NoticeShiftReq_Operation_GetNoticeStatus:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3NoticeShiftRes

@implementation PB3NoticeShiftRes

@dynamic status;

typedef struct PB3NoticeShiftRes__storage_ {
  uint32_t _has_storage_[1];
  PB3NoticeShiftRes_Status status;
} PB3NoticeShiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3NoticeShiftRes_Status_EnumDescriptor,
        .number = PB3NoticeShiftRes_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NoticeShiftRes__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NoticeShiftRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NoticeShiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3NoticeShiftRes_Status_RawValue(PB3NoticeShiftRes *message) {
  GPBDescriptor *descriptor = [PB3NoticeShiftRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NoticeShiftRes_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3NoticeShiftRes_Status_RawValue(PB3NoticeShiftRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3NoticeShiftRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NoticeShiftRes_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PB3NoticeShiftRes_Status

GPBEnumDescriptor *PB3NoticeShiftRes_Status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknow\000NoticeShiftOn\000NoticeShiftOff\000";
    static const int32_t values[] = {
        PB3NoticeShiftRes_Status_Unknow,
        PB3NoticeShiftRes_Status_NoticeShiftOn,
        PB3NoticeShiftRes_Status_NoticeShiftOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3NoticeShiftRes_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3NoticeShiftRes_Status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3NoticeShiftRes_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3NoticeShiftRes_Status_Unknow:
    case PB3NoticeShiftRes_Status_NoticeShiftOn:
    case PB3NoticeShiftRes_Status_NoticeShiftOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3LuckyValueRes

@implementation PB3LuckyValueRes

@dynamic luckyValueRatio;

typedef struct PB3LuckyValueRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t luckyValueRatio;
} PB3LuckyValueRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "luckyValueRatio",
        .dataTypeSpecific.className = NULL,
        .number = PB3LuckyValueRes_FieldNumber_LuckyValueRatio,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LuckyValueRes__storage_, luckyValueRatio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LuckyValueRes class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LuckyValueRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LuckyValueReq

@implementation PB3LuckyValueReq


typedef struct PB3LuckyValueReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LuckyValueReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LuckyValueReq class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LuckyValueReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LuckyValueNotice

@implementation PB3LuckyValueNotice

@dynamic ratio;
@dynamic msg;

typedef struct PB3LuckyValueNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t ratio;
  NSString *msg;
} PB3LuckyValueNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ratio",
        .dataTypeSpecific.className = NULL,
        .number = PB3LuckyValueNotice_FieldNumber_Ratio,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LuckyValueNotice__storage_, ratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3LuckyValueNotice_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LuckyValueNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LuckyValueNotice class]
                                     rootClass:[PB3CrackEggExtRoot class]
                                          file:PB3CrackEggExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LuckyValueNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
