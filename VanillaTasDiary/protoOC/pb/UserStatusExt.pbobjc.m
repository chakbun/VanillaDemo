// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/user_status.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/UserStatusExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3UserStatusExtRoot

@implementation PB3UserStatusExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3UserStatusExtRoot_FileDescriptor

static GPBFileDescriptor *PB3UserStatusExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3UserStatusErr

GPBEnumDescriptor *PB3UserStatusErr_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UserStatusSuccess\000ErrUserStatusKeyExpire"
        "d\000ErrUserStatusBanAccount\000ErrUserStatusB"
        "anIp\000ErrUserStatusRelogin\000ErrUserStatusT"
        "akeLeave\000ErrUserStatusBanDevice\000ErrUserS"
        "tatusBanPhone\000ErrUserStatusBanIdCard\000Err"
        "UserStatusLimitLogin\000ErrUserStatusTimeOu"
        "t\000";
    static const int32_t values[] = {
        PB3UserStatusErr_UserStatusSuccess,
        PB3UserStatusErr_ErrUserStatusKeyExpired,
        PB3UserStatusErr_ErrUserStatusBanAccount,
        PB3UserStatusErr_ErrUserStatusBanIp,
        PB3UserStatusErr_ErrUserStatusRelogin,
        PB3UserStatusErr_ErrUserStatusTakeLeave,
        PB3UserStatusErr_ErrUserStatusBanDevice,
        PB3UserStatusErr_ErrUserStatusBanPhone,
        PB3UserStatusErr_ErrUserStatusBanIdCard,
        PB3UserStatusErr_ErrUserStatusLimitLogin,
        PB3UserStatusErr_ErrUserStatusTimeOut,
    };
    static const char *extraTextFormatInfo = "\013\000\013f\000\001\027\000\002\027\000\003\022\000\004\024\000\005\026\000\006\026\000\007\025\000\010\026\000\t\027\000\n\024\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserStatusErr)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserStatusErr_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserStatusErr_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserStatusErr_UserStatusSuccess:
    case PB3UserStatusErr_ErrUserStatusKeyExpired:
    case PB3UserStatusErr_ErrUserStatusBanAccount:
    case PB3UserStatusErr_ErrUserStatusBanIp:
    case PB3UserStatusErr_ErrUserStatusRelogin:
    case PB3UserStatusErr_ErrUserStatusTakeLeave:
    case PB3UserStatusErr_ErrUserStatusBanDevice:
    case PB3UserStatusErr_ErrUserStatusBanPhone:
    case PB3UserStatusErr_ErrUserStatusBanIdCard:
    case PB3UserStatusErr_ErrUserStatusLimitLogin:
    case PB3UserStatusErr_ErrUserStatusTimeOut:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserStatusCmdId

GPBEnumDescriptor *PB3UserStatusCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UcUserStatusZero\000UcUserStatusRelogin\000UcU"
        "serStatusTakeLeave\000UcUserStatusDeviceDis"
        "connected\000UcUserStatusRemote\000";
    static const int32_t values[] = {
        PB3UserStatusCmdId_UcUserStatusZero,
        PB3UserStatusCmdId_UcUserStatusRelogin,
        PB3UserStatusCmdId_UcUserStatusTakeLeave,
        PB3UserStatusCmdId_UcUserStatusDeviceDisconnected,
        PB3UserStatusCmdId_UcUserStatusRemote,
    };
    static const char *extraTextFormatInfo = "\005\000b\216\000\001b\221\000\002b\223\000\003b\234\000\004b\220\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserStatusCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserStatusCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserStatusCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserStatusCmdId_UcUserStatusZero:
    case PB3UserStatusCmdId_UcUserStatusRelogin:
    case PB3UserStatusCmdId_UcUserStatusTakeLeave:
    case PB3UserStatusCmdId_UcUserStatusDeviceDisconnected:
    case PB3UserStatusCmdId_UcUserStatusRemote:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ExpandType

GPBEnumDescriptor *PB3ExpandType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownZero\000Umengpushid\000Umengmsgid\000Destt"
        "ype\000Pushtype\000";
    static const int32_t values[] = {
        PB3ExpandType_UnknownZero,
        PB3ExpandType_Umengpushid,
        PB3ExpandType_Umengmsgid,
        PB3ExpandType_Desttype,
        PB3ExpandType_Pushtype,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ExpandType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ExpandType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ExpandType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ExpandType_UnknownZero:
    case PB3ExpandType_Umengpushid:
    case PB3ExpandType_Umengmsgid:
    case PB3ExpandType_Desttype:
    case PB3ExpandType_Pushtype:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3LogoutType

GPBEnumDescriptor *PB3LogoutType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LtNone\000LtDeleteAccount\000";
    static const int32_t values[] = {
        PB3LogoutType_LtNone,
        PB3LogoutType_LtDeleteAccount,
    };
    static const char *extraTextFormatInfo = "\002\000b\204\000\001b\215\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3LogoutType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3LogoutType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3LogoutType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3LogoutType_LtNone:
    case PB3LogoutType_LtDeleteAccount:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3LoginReq

@implementation PB3LoginReq

@dynamic key;
@dynamic deviceType;
@dynamic deviceId;
@dynamic pushToken;
@dynamic reyunDeviceId;
@dynamic uMengDeviceId;
@dynamic expand, expand_Count;

typedef struct PB3LoginReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *key;
  NSString *deviceId;
  NSString *pushToken;
  NSString *reyunDeviceId;
  NSString *uMengDeviceId;
  GPBInt32ObjectDictionary *expand;
} PB3LoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3LoginReq_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_PushToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, pushToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reyunDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_ReyunDeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, reyunDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uMengDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_UMengDeviceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, uMengDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expand",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginReq_FieldNumber_Expand,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LoginReq__storage_, expand),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\n\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LoginReq_DeviceType_RawValue(PB3LoginReq *message) {
  GPBDescriptor *descriptor = [PB3LoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoginReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LoginReq_DeviceType_RawValue(PB3LoginReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoginReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LoginRes

@implementation PB3LoginRes

@dynamic accountId;
@dynamic extends, extends_Count;

typedef struct PB3LoginRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *extends;
  int64_t accountId;
} PB3LoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginRes_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginRes__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "extends",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginRes_FieldNumber_Extends,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LoginRes__storage_, extends),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastRelogin

@implementation PB3BroadcastRelogin

@dynamic deviceId;
@dynamic deviceType;
@dynamic multiClient;
@dynamic loginAt;
@dynamic loginType;
@dynamic deviceName;
@dynamic application;

typedef struct PB3BroadcastRelogin__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  PB3ClientLoginType loginType;
  NSString *deviceId;
  NSString *deviceName;
  NSString *application;
  int64_t loginAt;
} PB3BroadcastRelogin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastRelogin_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3BroadcastRelogin_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "multiClient",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastRelogin_FieldNumber_MultiClient,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "loginAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastRelogin_FieldNumber_LoginAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, loginAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "loginType",
        .dataTypeSpecific.enumDescFunc = PB3ClientLoginType_EnumDescriptor,
        .number = PB3BroadcastRelogin_FieldNumber_LoginType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, loginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastRelogin_FieldNumber_DeviceName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "application",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastRelogin_FieldNumber_Application,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BroadcastRelogin__storage_, application),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastRelogin class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastRelogin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\010\000\004\007\000\006J\000\007K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastRelogin_DeviceType_RawValue(PB3BroadcastRelogin *message) {
  GPBDescriptor *descriptor = [PB3BroadcastRelogin descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRelogin_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastRelogin_DeviceType_RawValue(PB3BroadcastRelogin *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastRelogin descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRelogin_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3BroadcastRelogin_LoginType_RawValue(PB3BroadcastRelogin *message) {
  GPBDescriptor *descriptor = [PB3BroadcastRelogin descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRelogin_FieldNumber_LoginType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastRelogin_LoginType_RawValue(PB3BroadcastRelogin *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastRelogin descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRelogin_FieldNumber_LoginType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BroadcastTakeLeave

@implementation PB3BroadcastTakeLeave

@dynamic accountId;
@dynamic msg;

typedef struct PB3BroadcastTakeLeave__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
  int64_t accountId;
} PB3BroadcastTakeLeave__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastTakeLeave_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastTakeLeave__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastTakeLeave_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastTakeLeave__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastTakeLeave class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastTakeLeave__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastDeviceDisconnected

@implementation PB3BroadcastDeviceDisconnected

@dynamic deviceId;
@dynamic deviceType;

typedef struct PB3BroadcastDeviceDisconnected__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *deviceId;
} PB3BroadcastDeviceDisconnected__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastDeviceDisconnected_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastDeviceDisconnected__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3BroadcastDeviceDisconnected_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastDeviceDisconnected__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastDeviceDisconnected class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastDeviceDisconnected__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastDeviceDisconnected_DeviceType_RawValue(PB3BroadcastDeviceDisconnected *message) {
  GPBDescriptor *descriptor = [PB3BroadcastDeviceDisconnected descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastDeviceDisconnected_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastDeviceDisconnected_DeviceType_RawValue(PB3BroadcastDeviceDisconnected *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastDeviceDisconnected descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastDeviceDisconnected_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LogoutReq

@implementation PB3LogoutReq

@dynamic key;
@dynamic logoutType;

typedef struct PB3LogoutReq__storage_ {
  uint32_t _has_storage_[1];
  PB3LogoutType logoutType;
  NSString *key;
} PB3LogoutReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogoutReq_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LogoutReq__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logoutType",
        .dataTypeSpecific.enumDescFunc = PB3LogoutType_EnumDescriptor,
        .number = PB3LogoutReq_FieldNumber_LogoutType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LogoutReq__storage_, logoutType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogoutReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogoutReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LogoutReq_LogoutType_RawValue(PB3LogoutReq *message) {
  GPBDescriptor *descriptor = [PB3LogoutReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LogoutReq_FieldNumber_LogoutType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LogoutReq_LogoutType_RawValue(PB3LogoutReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LogoutReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LogoutReq_FieldNumber_LogoutType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LogoutRes

@implementation PB3LogoutRes


typedef struct PB3LogoutRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LogoutRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogoutRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LogoutRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DisconnectReq

@implementation PB3DisconnectReq

@dynamic connId;
@dynamic userId;
@dynamic deviceType;
@dynamic deviceId;

typedef struct PB3DisconnectReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *deviceId;
  int64_t connId;
  int64_t userId;
} PB3DisconnectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connId",
        .dataTypeSpecific.className = NULL,
        .number = PB3DisconnectReq_FieldNumber_ConnId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DisconnectReq__storage_, connId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3DisconnectReq_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DisconnectReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3DisconnectReq_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3DisconnectReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3DisconnectReq_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3DisconnectReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DisconnectReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DisconnectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3DisconnectReq_DeviceType_RawValue(PB3DisconnectReq *message) {
  GPBDescriptor *descriptor = [PB3DisconnectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DisconnectReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3DisconnectReq_DeviceType_RawValue(PB3DisconnectReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3DisconnectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DisconnectReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3DisconnectRes

@implementation PB3DisconnectRes


typedef struct PB3DisconnectRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DisconnectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DisconnectRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DisconnectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HeartbeatReq

@implementation PB3HeartbeatReq

@dynamic connId;
@dynamic userId;
@dynamic roomId;
@dynamic deviceType;
@dynamic ip;

typedef struct PB3HeartbeatReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *ip;
  int64_t connId;
  int64_t userId;
  int64_t roomId;
} PB3HeartbeatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HeartbeatReq_FieldNumber_ConnId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HeartbeatReq__storage_, connId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HeartbeatReq_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HeartbeatReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HeartbeatReq_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HeartbeatReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3HeartbeatReq_FieldNumber_DeviceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3HeartbeatReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3HeartbeatReq_FieldNumber_Ip,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3HeartbeatReq__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HeartbeatReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HeartbeatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\006\000\002\006\000\003\006\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3HeartbeatReq_DeviceType_RawValue(PB3HeartbeatReq *message) {
  GPBDescriptor *descriptor = [PB3HeartbeatReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HeartbeatReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HeartbeatReq_DeviceType_RawValue(PB3HeartbeatReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HeartbeatReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HeartbeatReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3HeartbeatRes

@implementation PB3HeartbeatRes

@dynamic timeAt;

typedef struct PB3HeartbeatRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeAt;
} PB3HeartbeatRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3HeartbeatRes_FieldNumber_TimeAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HeartbeatRes__storage_, timeAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HeartbeatRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HeartbeatRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserConInfoListReq

@implementation PB3UserConInfoListReq


typedef struct PB3UserConInfoListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3UserConInfoListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserConInfoListReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserConInfoListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserConInfoListRes

@implementation PB3UserConInfoListRes

@dynamic listArray, listArray_Count;

typedef struct PB3UserConInfoListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3UserConInfoListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserConInfo),
        .number = PB3UserConInfoListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserConInfoListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserConInfoListRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserConInfoListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserConInfo

@implementation PB3UserConInfo

@dynamic id_p;
@dynamic ip;
@dynamic deviceType;
@dynamic deviceId;
@dynamic dieTime;
@dynamic playerId;
@dynamic createTime;

typedef struct PB3UserConInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *ip;
  NSString *deviceId;
  int64_t id_p;
  int64_t dieTime;
  int64_t playerId;
  int64_t createTime;
} PB3UserConInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3UserConInfo_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dieTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_DieTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, dieTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_PlayerId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserConInfo_FieldNumber_CreateTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3UserConInfo__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserConInfo class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserConInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserConInfo_DeviceType_RawValue(PB3UserConInfo *message) {
  GPBDescriptor *descriptor = [PB3UserConInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserConInfo_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserConInfo_DeviceType_RawValue(PB3UserConInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserConInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserConInfo_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserDeviceDisconnectedReq

@implementation PB3UserDeviceDisconnectedReq

@dynamic deviceId;
@dynamic deviceType;

typedef struct PB3UserDeviceDisconnectedReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *deviceId;
} PB3UserDeviceDisconnectedReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDeviceDisconnectedReq_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDeviceDisconnectedReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3UserDeviceDisconnectedReq_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserDeviceDisconnectedReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDeviceDisconnectedReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDeviceDisconnectedReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserDeviceDisconnectedReq_DeviceType_RawValue(PB3UserDeviceDisconnectedReq *message) {
  GPBDescriptor *descriptor = [PB3UserDeviceDisconnectedReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDeviceDisconnectedReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserDeviceDisconnectedReq_DeviceType_RawValue(PB3UserDeviceDisconnectedReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserDeviceDisconnectedReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDeviceDisconnectedReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserDeviceDisconnectedRes

@implementation PB3UserDeviceDisconnectedRes


typedef struct PB3UserDeviceDisconnectedRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UserDeviceDisconnectedRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDeviceDisconnectedRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserDeviceDisconnectedRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStateReq

@implementation PB3GetStateReq


typedef struct PB3GetStateReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStateReq class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStateRes

@implementation PB3GetStateRes

@dynamic msg;

typedef struct PB3GetStateRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} PB3GetStateRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetStateRes_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetStateRes__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStateRes class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetStateRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RemoteLogin

@implementation PB3RemoteLogin

@dynamic timeAt;
@dynamic deviceId;

typedef struct PB3RemoteLogin__storage_ {
  uint32_t _has_storage_[1];
  NSString *timeAt;
  NSString *deviceId;
} PB3RemoteLogin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3RemoteLogin_FieldNumber_TimeAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RemoteLogin__storage_, timeAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RemoteLogin_FieldNumber_DeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RemoteLogin__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RemoteLogin class]
                                     rootClass:[PB3UserStatusExtRoot class]
                                          file:PB3UserStatusExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RemoteLogin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
