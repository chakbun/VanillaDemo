// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/user.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/UserExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
#import "pb/BillExt.pbobjc.h"
#import "pb/SystemExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3UserExtRoot

@implementation PB3UserExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3UserExtRoot_FileDescriptor

static GPBFileDescriptor *PB3UserExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3UserCode

GPBEnumDescriptor *PB3UserCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000ErrUserKeyExpired\000ErrUserBanAcco"
        "unt\000ErrUserBanIp\000ErrUserNameIllegal\000ErrU"
        "serRelogin\000ErrUserNameDuplicate\000ErrUserW"
        "rongArgs\000ErrUserFail\000ErrUserBankNameNotE"
        "qual\000ErrUserNotBindBand\000ErrUserBindMaliF"
        "ail\000ErrUserNoRight\000ErrUserPassword\000ErrUs"
        "erBusy\000ErrUserBindIdCard\000ErrUserNotAgree"
        "\000ErrUserNameDirty\000ErrUserPassLength\000ErrU"
        "serKickOutRoom\000ErrUserIndexTop\000ErrUserOf"
        "fline\000ErrUserPasswdLength\000ErrUserPasswdE"
        "qual\000ErrUserOriginPasswd\000ErrUserSmscode\000"
        "ErrUserBindPhone\000ErrUserLoginTimeout\000Err"
        "UserNamePasswd\000ErrUser3RdError\000ErrUserBi"
        "ndPhoneRewardAgain\000ErrUserBindPhoneNot\000E"
        "rrUserBindPhoneEquel\000ErrUserBindPhoneErr"
        "\000ErrUserSamePhoneBind10\000ErrUserCertifica"
        "tionInput\000ErrUserCertificationCardNoErr\000"
        "ErrUserCertificationFull\000ErrUserCertific"
        "ationBusy\000ErrUserCertificationCallback\000E"
        "rrUserCertificationFail\000ErrUserCertifica"
        "tionChangeGold\000ErrUserHadCertified\000ErrUs"
        "erCertifyUpdateUserInfo\000ErrUserCodeCerti"
        "fyWord\000ErrUserUserName\000ErrUserBillSignat"
        "ure\000ErrUserBillFreeze\000ErrUserBillCheck\000E"
        "rrUserBillClose\000ErrUserBillNone\000ErrUserB"
        "illNoRight\000ErrUserBillFileNotExist\000ErrUs"
        "erNoCertify\000ErrUserSendSmscode\000ErrUserRe"
        "centVisitorOptLimit\000ErrUserDataAudit\000Err"
        "UserBillSkillNotAuth\000ErrUserNoBillSkill\000"
        "ErrUserNewPlayerBillNoAuth\000ErrUserBillSk"
        "illAlreadyAuth\000ErrUserBillSkillChecking\000"
        "ErrUserBillSkillNotOpen\000ErrUserProtectio"
        "nOfMinors\000ErrUserRemarkExceed\000ErrUserWro"
        "ngType\000ErrUserBindPhoneByUmeng\000ErrUserBi"
        "llProtectionOfMinors\000ErrUserInfoChecking"
        "\000ErrUserBankNotIdCard\000ErrUserTooFrequent"
        "\000ErrUserDeliverGoldNotEnough\000ErrUserPres"
        "entGoldNotEnough\000ErrUserNeteaseTokenFail"
        "ed\000ErrDeliverGoldNotEnough\000ErrUserUpdate"
        "BankInfoFailed\000ErrUserFileTooLarge\000";
    static const int32_t values[] = {
        PB3UserCode_Success,
        PB3UserCode_ErrUserKeyExpired,
        PB3UserCode_ErrUserBanAccount,
        PB3UserCode_ErrUserBanIp,
        PB3UserCode_ErrUserNameIllegal,
        PB3UserCode_ErrUserRelogin,
        PB3UserCode_ErrUserNameDuplicate,
        PB3UserCode_ErrUserWrongArgs,
        PB3UserCode_ErrUserFail,
        PB3UserCode_ErrUserBankNameNotEqual,
        PB3UserCode_ErrUserNotBindBand,
        PB3UserCode_ErrUserBindMaliFail,
        PB3UserCode_ErrUserNoRight,
        PB3UserCode_ErrUserPassword,
        PB3UserCode_ErrUserBusy,
        PB3UserCode_ErrUserBindIdCard,
        PB3UserCode_ErrUserNotAgree,
        PB3UserCode_ErrUserNameDirty,
        PB3UserCode_ErrUserPassLength,
        PB3UserCode_ErrUserKickOutRoom,
        PB3UserCode_ErrUserIndexTop,
        PB3UserCode_ErrUserOffline,
        PB3UserCode_ErrUserPasswdLength,
        PB3UserCode_ErrUserPasswdEqual,
        PB3UserCode_ErrUserOriginPasswd,
        PB3UserCode_ErrUserSmscode,
        PB3UserCode_ErrUserBindPhone,
        PB3UserCode_ErrUserLoginTimeout,
        PB3UserCode_ErrUserNamePasswd,
        PB3UserCode_ErrUser3RdError,
        PB3UserCode_ErrUserBindPhoneRewardAgain,
        PB3UserCode_ErrUserBindPhoneNot,
        PB3UserCode_ErrUserBindPhoneEquel,
        PB3UserCode_ErrUserBindPhoneErr,
        PB3UserCode_ErrUserSamePhoneBind10,
        PB3UserCode_ErrUserCertificationInput,
        PB3UserCode_ErrUserCertificationCardNoErr,
        PB3UserCode_ErrUserCertificationFull,
        PB3UserCode_ErrUserCertificationBusy,
        PB3UserCode_ErrUserCertificationCallback,
        PB3UserCode_ErrUserCertificationFail,
        PB3UserCode_ErrUserCertificationChangeGold,
        PB3UserCode_ErrUserHadCertified,
        PB3UserCode_ErrUserCertifyUpdateUserInfo,
        PB3UserCode_ErrUserCodeCertifyWord,
        PB3UserCode_ErrUserUserName,
        PB3UserCode_ErrUserBillSignature,
        PB3UserCode_ErrUserBillFreeze,
        PB3UserCode_ErrUserBillCheck,
        PB3UserCode_ErrUserBillClose,
        PB3UserCode_ErrUserBillNone,
        PB3UserCode_ErrUserBillNoRight,
        PB3UserCode_ErrUserBillFileNotExist,
        PB3UserCode_ErrUserNoCertify,
        PB3UserCode_ErrUserSendSmscode,
        PB3UserCode_ErrUserRecentVisitorOptLimit,
        PB3UserCode_ErrUserDataAudit,
        PB3UserCode_ErrUserBillSkillNotAuth,
        PB3UserCode_ErrUserNoBillSkill,
        PB3UserCode_ErrUserNewPlayerBillNoAuth,
        PB3UserCode_ErrUserBillSkillAlreadyAuth,
        PB3UserCode_ErrUserBillSkillChecking,
        PB3UserCode_ErrUserBillSkillNotOpen,
        PB3UserCode_ErrUserProtectionOfMinors,
        PB3UserCode_ErrUserRemarkExceed,
        PB3UserCode_ErrUserWrongType,
        PB3UserCode_ErrUserBindPhoneByUmeng,
        PB3UserCode_ErrUserBillProtectionOfMinors,
        PB3UserCode_ErrUserInfoChecking,
        PB3UserCode_ErrUserBankNotIdCard,
        PB3UserCode_ErrUserTooFrequent,
        PB3UserCode_ErrUserDeliverGoldNotEnough,
        PB3UserCode_ErrUserPresentGoldNotEnough,
        PB3UserCode_ErrUserNeteaseTokenFailed,
        PB3UserCode_ErrDeliverGoldNotEnough,
        PB3UserCode_ErrUserUpdateBankInfoFailed,
        PB3UserCode_ErrUserFileTooLarge,
    };
    static const char *extraTextFormatInfo = "L\001\021\000\002\021\000\003\014\000\004\022\000\005\016\000\006\024\000\007\020\000\010\013\000\t\027\000\n\022\000\013\023\000\014\016\000\r\017\000\016\013\000\017\021\000\020\017\000\021\020\000\022\021\000\023\022\000\024\017\000\025\016\000\026\023\000\027\022\000\030\023\000\031\010c\003\000\032\020\000\033\023\000\034\021\000\035\010\'\000\036\033\000\037\023\000 \025\000!\023\000\"\026\000#\031\000$\035\000%\030\000&\030\000\'\034\000(\030\000)\036\000*\023\000+\034\000,\026\000-\017\000.\024\000/\021\0000\020\0001\020\0002\017\0003\022\0004\027\0005\020\0006\014c\003\0007\034\0008\020\0009\027\000:\022\000;\032\000<\033\000=\030\000>\027\000?\031\000@\023\000A\020\000B\027\000C\035\000D\023\000E\024\000F\022\000G\033\000H\033\000I\031\000J\027\000K\033\000L\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserCode_Success:
    case PB3UserCode_ErrUserKeyExpired:
    case PB3UserCode_ErrUserBanAccount:
    case PB3UserCode_ErrUserBanIp:
    case PB3UserCode_ErrUserNameIllegal:
    case PB3UserCode_ErrUserRelogin:
    case PB3UserCode_ErrUserNameDuplicate:
    case PB3UserCode_ErrUserWrongArgs:
    case PB3UserCode_ErrUserFail:
    case PB3UserCode_ErrUserBankNameNotEqual:
    case PB3UserCode_ErrUserNotBindBand:
    case PB3UserCode_ErrUserBindMaliFail:
    case PB3UserCode_ErrUserNoRight:
    case PB3UserCode_ErrUserPassword:
    case PB3UserCode_ErrUserBusy:
    case PB3UserCode_ErrUserBindIdCard:
    case PB3UserCode_ErrUserNotAgree:
    case PB3UserCode_ErrUserNameDirty:
    case PB3UserCode_ErrUserPassLength:
    case PB3UserCode_ErrUserKickOutRoom:
    case PB3UserCode_ErrUserIndexTop:
    case PB3UserCode_ErrUserOffline:
    case PB3UserCode_ErrUserPasswdLength:
    case PB3UserCode_ErrUserPasswdEqual:
    case PB3UserCode_ErrUserOriginPasswd:
    case PB3UserCode_ErrUserSmscode:
    case PB3UserCode_ErrUserBindPhone:
    case PB3UserCode_ErrUserLoginTimeout:
    case PB3UserCode_ErrUserNamePasswd:
    case PB3UserCode_ErrUser3RdError:
    case PB3UserCode_ErrUserBindPhoneRewardAgain:
    case PB3UserCode_ErrUserBindPhoneNot:
    case PB3UserCode_ErrUserBindPhoneEquel:
    case PB3UserCode_ErrUserBindPhoneErr:
    case PB3UserCode_ErrUserSamePhoneBind10:
    case PB3UserCode_ErrUserCertificationInput:
    case PB3UserCode_ErrUserCertificationCardNoErr:
    case PB3UserCode_ErrUserCertificationFull:
    case PB3UserCode_ErrUserCertificationBusy:
    case PB3UserCode_ErrUserCertificationCallback:
    case PB3UserCode_ErrUserCertificationFail:
    case PB3UserCode_ErrUserCertificationChangeGold:
    case PB3UserCode_ErrUserHadCertified:
    case PB3UserCode_ErrUserCertifyUpdateUserInfo:
    case PB3UserCode_ErrUserCodeCertifyWord:
    case PB3UserCode_ErrUserUserName:
    case PB3UserCode_ErrUserBillSignature:
    case PB3UserCode_ErrUserBillFreeze:
    case PB3UserCode_ErrUserBillCheck:
    case PB3UserCode_ErrUserBillClose:
    case PB3UserCode_ErrUserBillNone:
    case PB3UserCode_ErrUserBillNoRight:
    case PB3UserCode_ErrUserBillFileNotExist:
    case PB3UserCode_ErrUserNoCertify:
    case PB3UserCode_ErrUserSendSmscode:
    case PB3UserCode_ErrUserRecentVisitorOptLimit:
    case PB3UserCode_ErrUserDataAudit:
    case PB3UserCode_ErrUserBillSkillNotAuth:
    case PB3UserCode_ErrUserNoBillSkill:
    case PB3UserCode_ErrUserNewPlayerBillNoAuth:
    case PB3UserCode_ErrUserBillSkillAlreadyAuth:
    case PB3UserCode_ErrUserBillSkillChecking:
    case PB3UserCode_ErrUserBillSkillNotOpen:
    case PB3UserCode_ErrUserProtectionOfMinors:
    case PB3UserCode_ErrUserRemarkExceed:
    case PB3UserCode_ErrUserWrongType:
    case PB3UserCode_ErrUserBindPhoneByUmeng:
    case PB3UserCode_ErrUserBillProtectionOfMinors:
    case PB3UserCode_ErrUserInfoChecking:
    case PB3UserCode_ErrUserBankNotIdCard:
    case PB3UserCode_ErrUserTooFrequent:
    case PB3UserCode_ErrUserDeliverGoldNotEnough:
    case PB3UserCode_ErrUserPresentGoldNotEnough:
    case PB3UserCode_ErrUserNeteaseTokenFailed:
    case PB3UserCode_ErrDeliverGoldNotEnough:
    case PB3UserCode_ErrUserUpdateBankInfoFailed:
    case PB3UserCode_ErrUserFileTooLarge:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserCmdId

GPBEnumDescriptor *PB3UserCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UcZero\000UcUpdatePlayerName\000UcCharmLevel\000U"
        "cWealthLevel\000UcUserBan\000UcPlayerFlags\000UcU"
        "pdateIcon\000UcUpdateOnOff\000UcSetShortId\000UcS"
        "earchPlayer\000UcIsChargeToday\000UcVersionCon"
        "tent\000UcCountdownStart\000UcAuditDetail\000UcFl"
        "owerLevel\000UcPlayerFlagsKv\000UcAntiAddictio"
        "n\000UcOfficialAuth\000UcBillPlayerStatus\000UcDe"
        "lProfileVoice\000UcLeaveMessage\000UcBlackWhal"
        "e\000UcIntimateFansCardInfo\000UcWhaleBossList"
        "\000UcWhaleBossStatus\000UcSettingOnOffChange\000"
        "UcPlayerPunishWarning\000UcPlayerInfoChange"
        "\000UcAccountDeleted\000UcJumpPageLink\000UcMissi"
        "onRewardRedPoint\000UcBroadcastNeteaseToken"
        "\000";
    static const int32_t values[] = {
        PB3UserCmdId_UcZero,
        PB3UserCmdId_UcUpdatePlayerName,
        PB3UserCmdId_UcCharmLevel,
        PB3UserCmdId_UcWealthLevel,
        PB3UserCmdId_UcUserBan,
        PB3UserCmdId_UcPlayerFlags,
        PB3UserCmdId_UcUpdateIcon,
        PB3UserCmdId_UcUpdateOnOff,
        PB3UserCmdId_UcSetShortId,
        PB3UserCmdId_UcSearchPlayer,
        PB3UserCmdId_UcIsChargeToday,
        PB3UserCmdId_UcVersionContent,
        PB3UserCmdId_UcCountdownStart,
        PB3UserCmdId_UcAuditDetail,
        PB3UserCmdId_UcFlowerLevel,
        PB3UserCmdId_UcPlayerFlagsKv,
        PB3UserCmdId_UcAntiAddiction,
        PB3UserCmdId_UcOfficialAuth,
        PB3UserCmdId_UcBillPlayerStatus,
        PB3UserCmdId_UcDelProfileVoice,
        PB3UserCmdId_UcLeaveMessage,
        PB3UserCmdId_UcBlackWhale,
        PB3UserCmdId_UcIntimateFansCardInfo,
        PB3UserCmdId_UcWhaleBossList,
        PB3UserCmdId_UcWhaleBossStatus,
        PB3UserCmdId_UcSettingOnOffChange,
        PB3UserCmdId_UcPlayerPunishWarning,
        PB3UserCmdId_UcPlayerInfoChange,
        PB3UserCmdId_UcAccountDeleted,
        PB3UserCmdId_UcJumpPageLink,
        PB3UserCmdId_UcMissionRewardRedPoint,
        PB3UserCmdId_UcBroadcastNeteaseToken,
    };
    static const char *extraTextFormatInfo = " \000b\204\000\001b\220\000\002b\212\000\003b\213\000\004b\207\000\005b\213\000\006b\212\000\007b\213\000\010b\212\000\tb\214\000\nb\215\000\013b\216\000\014b\216\000\rb\213\000\016b\213\000\017b\214A\000\020b\215\000\021b\214\000\022b\220\000\023b\217\000\024b\214\000\025b\212\000\026b\224\000\027b\215\000\030b\217\000\031b\222\000\032b\223\000\033b\220\000\034b\216\000\035b\214\000\036b\225\000\037b\225\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserCmdId_UcZero:
    case PB3UserCmdId_UcUpdatePlayerName:
    case PB3UserCmdId_UcCharmLevel:
    case PB3UserCmdId_UcWealthLevel:
    case PB3UserCmdId_UcUserBan:
    case PB3UserCmdId_UcPlayerFlags:
    case PB3UserCmdId_UcUpdateIcon:
    case PB3UserCmdId_UcUpdateOnOff:
    case PB3UserCmdId_UcSetShortId:
    case PB3UserCmdId_UcSearchPlayer:
    case PB3UserCmdId_UcIsChargeToday:
    case PB3UserCmdId_UcVersionContent:
    case PB3UserCmdId_UcCountdownStart:
    case PB3UserCmdId_UcAuditDetail:
    case PB3UserCmdId_UcFlowerLevel:
    case PB3UserCmdId_UcPlayerFlagsKv:
    case PB3UserCmdId_UcAntiAddiction:
    case PB3UserCmdId_UcOfficialAuth:
    case PB3UserCmdId_UcBillPlayerStatus:
    case PB3UserCmdId_UcDelProfileVoice:
    case PB3UserCmdId_UcLeaveMessage:
    case PB3UserCmdId_UcBlackWhale:
    case PB3UserCmdId_UcIntimateFansCardInfo:
    case PB3UserCmdId_UcWhaleBossList:
    case PB3UserCmdId_UcWhaleBossStatus:
    case PB3UserCmdId_UcSettingOnOffChange:
    case PB3UserCmdId_UcPlayerPunishWarning:
    case PB3UserCmdId_UcPlayerInfoChange:
    case PB3UserCmdId_UcAccountDeleted:
    case PB3UserCmdId_UcJumpPageLink:
    case PB3UserCmdId_UcMissionRewardRedPoint:
    case PB3UserCmdId_UcBroadcastNeteaseToken:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AntiAddictionAlertType

GPBEnumDescriptor *PB3AntiAddictionAlertType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AntiAddictionAlertTypeNone\000AntiAddiction"
        "AlertTypePrompt\000AntiAddictionAlertTypeEn"
        "force\000AntiAddictionAlertTypeClose\000";
    static const int32_t values[] = {
        PB3AntiAddictionAlertType_AntiAddictionAlertTypeNone,
        PB3AntiAddictionAlertType_AntiAddictionAlertTypePrompt,
        PB3AntiAddictionAlertType_AntiAddictionAlertTypeEnforce,
        PB3AntiAddictionAlertType_AntiAddictionAlertTypeClose,
    };
    static const char *extraTextFormatInfo = "\004\000\026\204\000\001\026\206\000\002\026\207\000\003\026\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AntiAddictionAlertType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AntiAddictionAlertType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AntiAddictionAlertType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AntiAddictionAlertType_AntiAddictionAlertTypeNone:
    case PB3AntiAddictionAlertType_AntiAddictionAlertTypePrompt:
    case PB3AntiAddictionAlertType_AntiAddictionAlertTypeEnforce:
    case PB3AntiAddictionAlertType_AntiAddictionAlertTypeClose:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserBindPhoneOpType

GPBEnumDescriptor *PB3UserBindPhoneOpType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UcphoneOpTypeSendCode\000UcphoneOpTypeConfi"
        "rmCode\000UcphoneOpTypeOldSendCode\000UcphoneO"
        "pTypeOldConfirmCode\000UcphoneOpTypeNewSend"
        "Code\000UcphoneOpTypeNewConfirmCode\000";
    static const int32_t values[] = {
        PB3UserBindPhoneOpType_UcphoneOpTypeSendCode,
        PB3UserBindPhoneOpType_UcphoneOpTypeConfirmCode,
        PB3UserBindPhoneOpType_UcphoneOpTypeOldSendCode,
        PB3UserBindPhoneOpType_UcphoneOpTypeOldConfirmCode,
        PB3UserBindPhoneOpType_UcphoneOpTypeNewSendCode,
        PB3UserBindPhoneOpType_UcphoneOpTypeNewConfirmCode,
    };
    static const char *extraTextFormatInfo = "\006\000c\n\210\000\001c\n\213\000\002c\n\213\000\003c\n\216\000\004c\n\213\000\005c\n\216\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserBindPhoneOpType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserBindPhoneOpType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserBindPhoneOpType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserBindPhoneOpType_UcphoneOpTypeSendCode:
    case PB3UserBindPhoneOpType_UcphoneOpTypeConfirmCode:
    case PB3UserBindPhoneOpType_UcphoneOpTypeOldSendCode:
    case PB3UserBindPhoneOpType_UcphoneOpTypeOldConfirmCode:
    case PB3UserBindPhoneOpType_UcphoneOpTypeNewSendCode:
    case PB3UserBindPhoneOpType_UcphoneOpTypeNewConfirmCode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserBindPhoneItemType

GPBEnumDescriptor *PB3UserBindPhoneItemType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UcphoneItemTypeGift\000UcphoneItemTypeGold\000";
    static const int32_t values[] = {
        PB3UserBindPhoneItemType_UcphoneItemTypeGift,
        PB3UserBindPhoneItemType_UcphoneItemTypeGold,
    };
    static const char *extraTextFormatInfo = "\002\000c\014\204\000\001c\014\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserBindPhoneItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserBindPhoneItemType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserBindPhoneItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserBindPhoneItemType_UcphoneItemTypeGift:
    case PB3UserBindPhoneItemType_UcphoneItemTypeGold:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserMailType

GPBEnumDescriptor *PB3UserMailType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UserMailNone\000UserMailSystem\000UserMailActi"
        "vity\000UserMailFollow\000UserMailClan\000";
    static const int32_t values[] = {
        PB3UserMailType_UserMailNone,
        PB3UserMailType_UserMailSystem,
        PB3UserMailType_UserMailActivity,
        PB3UserMailType_UserMailFollow,
        PB3UserMailType_UserMailClan,
    };
    static const char *extraTextFormatInfo = "\005\000\010\204\000\001\010\206\000\002\010\210\000\003\010\206\000\004\010\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserMailType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserMailType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserMailType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserMailType_UserMailNone:
    case PB3UserMailType_UserMailSystem:
    case PB3UserMailType_UserMailActivity:
    case PB3UserMailType_UserMailFollow:
    case PB3UserMailType_UserMailClan:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3JumpPageLinkType

GPBEnumDescriptor *PB3JumpPageLinkType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "JumpPageLinkNone\000JumpPageLinkFacebook\000";
    static const int32_t values[] = {
        PB3JumpPageLinkType_JumpPageLinkNone,
        PB3JumpPageLinkType_JumpPageLinkFacebook,
    };
    static const char *extraTextFormatInfo = "\002\000\014\204\000\001\014\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3JumpPageLinkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3JumpPageLinkType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3JumpPageLinkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3JumpPageLinkType_JumpPageLinkNone:
    case PB3JumpPageLinkType_JumpPageLinkFacebook:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RegisterType

GPBEnumDescriptor *PB3RegisterType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Rtzero\000RtWeixin\000RtQq\000RtPhone\000";
    static const int32_t values[] = {
        PB3RegisterType_Rtzero,
        PB3RegisterType_RtWeixin,
        PB3RegisterType_RtQq,
        PB3RegisterType_RtPhone,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RegisterType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RegisterType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RegisterType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RegisterType_Rtzero:
    case PB3RegisterType_RtWeixin:
    case PB3RegisterType_RtQq:
    case PB3RegisterType_RtPhone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RequestSourceType

GPBEnumDescriptor *PB3RequestSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RstZero\000RstIm\000";
    static const int32_t values[] = {
        PB3RequestSourceType_RstZero,
        PB3RequestSourceType_RstIm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RequestSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RequestSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RequestSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RequestSourceType_RstZero:
    case PB3RequestSourceType_RstIm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SourceType

GPBEnumDescriptor *PB3SourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StModify\000StRegister\000";
    static const int32_t values[] = {
        PB3SourceType_StModify,
        PB3SourceType_StRegister,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SourceType_StModify:
    case PB3SourceType_StRegister:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AccountChannelType

GPBEnumDescriptor *PB3AccountChannelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ActZero\000ActPhone\000ActQq\000ActWechat\000ActAppl"
        "eId\000ActSubsidiary\000";
    static const int32_t values[] = {
        PB3AccountChannelType_ActZero,
        PB3AccountChannelType_ActPhone,
        PB3AccountChannelType_ActQq,
        PB3AccountChannelType_ActWechat,
        PB3AccountChannelType_ActAppleId,
        PB3AccountChannelType_ActSubsidiary,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AccountChannelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AccountChannelType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AccountChannelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AccountChannelType_ActZero:
    case PB3AccountChannelType_ActPhone:
    case PB3AccountChannelType_ActQq:
    case PB3AccountChannelType_ActWechat:
    case PB3AccountChannelType_ActAppleId:
    case PB3AccountChannelType_ActSubsidiary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SmsCode

GPBEnumDescriptor *PB3SmsCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SmsOk\000SmsError\000";
    static const int32_t values[] = {
        PB3SmsCode_SmsOk,
        PB3SmsCode_SmsError,
    };
    static const char *extraTextFormatInfo = "\001\001c\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SmsCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SmsCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SmsCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SmsCode_SmsOk:
    case PB3SmsCode_SmsError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RiskType

GPBEnumDescriptor *PB3RiskType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RtZero\000RtWarn\000RtRisk\000";
    static const int32_t values[] = {
        PB3RiskType_RtZero,
        PB3RiskType_RtWarn,
        PB3RiskType_RtRisk,
    };
    static const char *extraTextFormatInfo = "\003\000b\204\000\001b\204\000\002b\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RiskType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RiskType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RiskType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RiskType_RtZero:
    case PB3RiskType_RtWarn:
    case PB3RiskType_RtRisk:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ClearMsgRedType

GPBEnumDescriptor *PB3ClearMsgRedType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmrtypeNone\000CmrtypeAll\000CmrtypeBillVisit\000";
    static const int32_t values[] = {
        PB3ClearMsgRedType_CmrtypeNone,
        PB3ClearMsgRedType_CmrtypeAll,
        PB3ClearMsgRedType_CmrtypeBillVisit,
    };
    static const char *extraTextFormatInfo = "\003\000d\003\204\000\001d\003\343\000\002d\003\211\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClearMsgRedType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClearMsgRedType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClearMsgRedType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClearMsgRedType_CmrtypeNone:
    case PB3ClearMsgRedType_CmrtypeAll:
    case PB3ClearMsgRedType_CmrtypeBillVisit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WeChatLogin

GPBEnumDescriptor *PB3WeChatLogin_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WxLoginZero\000WxLoginPhone\000WxLoginIdPsw\000";
    static const int32_t values[] = {
        PB3WeChatLogin_WxLoginZero,
        PB3WeChatLogin_WxLoginPhone,
        PB3WeChatLogin_WxLoginIdPsw,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WeChatLogin)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WeChatLogin_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WeChatLogin_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WeChatLogin_WxLoginZero:
    case PB3WeChatLogin_WxLoginPhone:
    case PB3WeChatLogin_WxLoginIdPsw:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AuthGainType

GPBEnumDescriptor *PB3AuthGainType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AuthGainGuild\000AuthGainOffical\000AuthGainLe"
        "velUp\000";
    static const int32_t values[] = {
        PB3AuthGainType_AuthGainGuild,
        PB3AuthGainType_AuthGainOffical,
        PB3AuthGainType_AuthGainLevelUp,
    };
    static const char *extraTextFormatInfo = "\003\000\r\000\001\017\000\002\017\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AuthGainType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AuthGainType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AuthGainType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AuthGainType_AuthGainGuild:
    case PB3AuthGainType_AuthGainOffical:
    case PB3AuthGainType_AuthGainLevelUp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CheckType

GPBEnumDescriptor *PB3CheckType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CheckNone\000CheckChangePwd\000CheckBindPhone\000"
        "CheckChangeExchangePwd\000";
    static const int32_t values[] = {
        PB3CheckType_CheckNone,
        PB3CheckType_CheckChangePwd,
        PB3CheckType_CheckBindPhone,
        PB3CheckType_CheckChangeExchangePwd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CheckType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CheckType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CheckType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CheckType_CheckNone:
    case PB3CheckType_CheckChangePwd:
    case PB3CheckType_CheckBindPhone:
    case PB3CheckType_CheckChangeExchangePwd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3LeaveMessageType

GPBEnumDescriptor *PB3LeaveMessageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LmtNone\000LmtOwner\000LmtOther\000";
    static const int32_t values[] = {
        PB3LeaveMessageType_LmtNone,
        PB3LeaveMessageType_LmtOwner,
        PB3LeaveMessageType_LmtOther,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3LeaveMessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3LeaveMessageType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3LeaveMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3LeaveMessageType_LmtNone:
    case PB3LeaveMessageType_LmtOwner:
    case PB3LeaveMessageType_LmtOther:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IntimateFansDayConf

GPBEnumDescriptor *PB3IntimateFansDayConf_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IntimateFansNone\000IntimateFansDay\000Intimat"
        "eFansMonth\000IntimateFansYear\000";
    static const int32_t values[] = {
        PB3IntimateFansDayConf_IntimateFansNone,
        PB3IntimateFansDayConf_IntimateFansDay,
        PB3IntimateFansDayConf_IntimateFansMonth,
        PB3IntimateFansDayConf_IntimateFansYear,
    };
    static const char *extraTextFormatInfo = "\004\000\010\204\204\000\001\010\204\203\000\002\010\204\205\000\003\010\204\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IntimateFansDayConf)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IntimateFansDayConf_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IntimateFansDayConf_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IntimateFansDayConf_IntimateFansNone:
    case PB3IntimateFansDayConf_IntimateFansDay:
    case PB3IntimateFansDayConf_IntimateFansMonth:
    case PB3IntimateFansDayConf_IntimateFansYear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PushIntimateFansCardInfoType

GPBEnumDescriptor *PB3PushIntimateFansCardInfoType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PifcitUpd\000PifcitAdd\000PifcitDel\000PifcitLev\000"
        "PifcitCard\000";
    static const int32_t values[] = {
        PB3PushIntimateFansCardInfoType_PifcitUpd,
        PB3PushIntimateFansCardInfoType_PifcitAdd,
        PB3PushIntimateFansCardInfoType_PifcitDel,
        PB3PushIntimateFansCardInfoType_PifcitLev,
        PB3PushIntimateFansCardInfoType_PifcitCard,
    };
    static const char *extraTextFormatInfo = "\005\000f\203\000\001f\203\000\002f\203\000\003f\203\000\004f\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PushIntimateFansCardInfoType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PushIntimateFansCardInfoType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PushIntimateFansCardInfoType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PushIntimateFansCardInfoType_PifcitUpd:
    case PB3PushIntimateFansCardInfoType_PifcitAdd:
    case PB3PushIntimateFansCardInfoType_PifcitDel:
    case PB3PushIntimateFansCardInfoType_PifcitLev:
    case PB3PushIntimateFansCardInfoType_PifcitCard:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SettingType

GPBEnumDescriptor *PB3SettingType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SonofftZero\000SonofftMessage\000SonofftImGift"
        "\000";
    static const int32_t values[] = {
        PB3SettingType_SonofftZero,
        PB3SettingType_SonofftMessage,
        PB3SettingType_SonofftImGift,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SettingType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SettingType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SettingType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SettingType_SonofftZero:
    case PB3SettingType_SonofftMessage:
    case PB3SettingType_SonofftImGift:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3InviteAwardType

GPBEnumDescriptor *PB3InviteAwardType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IatZero\000IatShow\000IatAward\000";
    static const int32_t values[] = {
        PB3InviteAwardType_IatZero,
        PB3InviteAwardType_IatShow,
        PB3InviteAwardType_IatAward,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3InviteAwardType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3InviteAwardType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3InviteAwardType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3InviteAwardType_IatZero:
    case PB3InviteAwardType_IatShow:
    case PB3InviteAwardType_IatAward:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3InviteMoneyType

GPBEnumDescriptor *PB3InviteMoneyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UimtZero\000UimtTw\000UimtGold\000UimtSg\000";
    static const int32_t values[] = {
        PB3InviteMoneyType_UimtZero,
        PB3InviteMoneyType_UimtTw,
        PB3InviteMoneyType_UimtGold,
        PB3InviteMoneyType_UimtSg,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3InviteMoneyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3InviteMoneyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3InviteMoneyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3InviteMoneyType_UimtZero:
    case PB3InviteMoneyType_UimtTw:
    case PB3InviteMoneyType_UimtGold:
    case PB3InviteMoneyType_UimtSg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3InviteTaskID

GPBEnumDescriptor *PB3InviteTaskID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ItidZero\000ItidOneDay\000ItidTwoDay\000ItidOneWe"
        "ek\000ItidOneMonth\000";
    static const int32_t values[] = {
        PB3InviteTaskID_ItidZero,
        PB3InviteTaskID_ItidOneDay,
        PB3InviteTaskID_ItidTwoDay,
        PB3InviteTaskID_ItidOneWeek,
        PB3InviteTaskID_ItidOneMonth,
    };
    static const char *extraTextFormatInfo = "\004\001d\203\203\000\002d\203\203\000\003d\203\204\000\004d\203\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3InviteTaskID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3InviteTaskID_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3InviteTaskID_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3InviteTaskID_ItidZero:
    case PB3InviteTaskID_ItidOneDay:
    case PB3InviteTaskID_ItidTwoDay:
    case PB3InviteTaskID_ItidOneWeek:
    case PB3InviteTaskID_ItidOneMonth:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3NotPassType

GPBEnumDescriptor *PB3NotPassType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NotPassTypeZore\000NotPassTypeSafe\000NotPassT"
        "ypeRisk\000NotPassTypeAssets\000NotPassTypeFam"
        "ily\000NotPassTypeApply\000";
    static const int32_t values[] = {
        PB3NotPassType_NotPassTypeZore,
        PB3NotPassType_NotPassTypeSafe,
        PB3NotPassType_NotPassTypeRisk,
        PB3NotPassType_NotPassTypeAssets,
        PB3NotPassType_NotPassTypeFamily,
        PB3NotPassType_NotPassTypeApply,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3NotPassType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3NotPassType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3NotPassType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3NotPassType_NotPassTypeZore:
    case PB3NotPassType_NotPassTypeSafe:
    case PB3NotPassType_NotPassTypeRisk:
    case PB3NotPassType_NotPassTypeAssets:
    case PB3NotPassType_NotPassTypeFamily:
    case PB3NotPassType_NotPassTypeApply:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RegisterChannel

GPBEnumDescriptor *PB3RegisterChannel_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RegisterChannelInside\000RegisterChannelPho"
        "ne\000RegisterChannelQq\000RegisterChannelWech"
        "at\000RegisterChannelGoogle\000RegisterChannel"
        "Facebook\000RegisterChannelApple\000RegisterCh"
        "annelTourists\000RegisterChannelLine\000";
    static const int32_t values[] = {
        PB3RegisterChannel_RegisterChannelInside,
        PB3RegisterChannel_RegisterChannelPhone,
        PB3RegisterChannel_RegisterChannelQq,
        PB3RegisterChannel_RegisterChannelWechat,
        PB3RegisterChannel_RegisterChannelGoogle,
        PB3RegisterChannel_RegisterChannelFacebook,
        PB3RegisterChannel_RegisterChannelApple,
        PB3RegisterChannel_RegisterChannelTourists,
        PB3RegisterChannel_RegisterChannelLine,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RegisterChannel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RegisterChannel_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RegisterChannel_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RegisterChannel_RegisterChannelInside:
    case PB3RegisterChannel_RegisterChannelPhone:
    case PB3RegisterChannel_RegisterChannelQq:
    case PB3RegisterChannel_RegisterChannelWechat:
    case PB3RegisterChannel_RegisterChannelGoogle:
    case PB3RegisterChannel_RegisterChannelFacebook:
    case PB3RegisterChannel_RegisterChannelApple:
    case PB3RegisterChannel_RegisterChannelTourists:
    case PB3RegisterChannel_RegisterChannelLine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserBindType

GPBEnumDescriptor *PB3UserBindType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UbtBindZero\000UbtBindPhone\000UbtBindEmail\000";
    static const int32_t values[] = {
        PB3UserBindType_UbtBindZero,
        PB3UserBindType_UbtBindPhone,
        PB3UserBindType_UbtBindEmail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserBindType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserBindType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserBindType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserBindType_UbtBindZero:
    case PB3UserBindType_UbtBindPhone:
    case PB3UserBindType_UbtBindEmail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3VerifyType

GPBEnumDescriptor *PB3VerifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VerifyPhone\000VerifyEmail\000";
    static const int32_t values[] = {
        PB3VerifyType_VerifyPhone,
        PB3VerifyType_VerifyEmail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3VerifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3VerifyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3VerifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3VerifyType_VerifyPhone:
    case PB3VerifyType_VerifyEmail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WelcomeType

GPBEnumDescriptor *PB3WelcomeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WelcometypeZone\000WelcometypeRoom\000Welcomet"
        "ypeIm\000";
    static const int32_t values[] = {
        PB3WelcomeType_WelcometypeZone,
        PB3WelcomeType_WelcometypeRoom,
        PB3WelcomeType_WelcometypeIm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WelcomeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WelcomeType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WelcomeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WelcomeType_WelcometypeZone:
    case PB3WelcomeType_WelcometypeRoom:
    case PB3WelcomeType_WelcometypeIm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3BroadcastAntiAddictionAlert

@implementation PB3BroadcastAntiAddictionAlert

@dynamic type;
@dynamic limitHours;

typedef struct PB3BroadcastAntiAddictionAlert__storage_ {
  uint32_t _has_storage_[1];
  PB3AntiAddictionAlertType type;
  int32_t limitHours;
} PB3BroadcastAntiAddictionAlert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AntiAddictionAlertType_EnumDescriptor,
        .number = PB3BroadcastAntiAddictionAlert_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAntiAddictionAlert__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limitHours",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAntiAddictionAlert_FieldNumber_LimitHours,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastAntiAddictionAlert__storage_, limitHours),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAntiAddictionAlert class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAntiAddictionAlert__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastAntiAddictionAlert_Type_RawValue(PB3BroadcastAntiAddictionAlert *message) {
  GPBDescriptor *descriptor = [PB3BroadcastAntiAddictionAlert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAntiAddictionAlert_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastAntiAddictionAlert_Type_RawValue(PB3BroadcastAntiAddictionAlert *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastAntiAddictionAlert descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAntiAddictionAlert_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BroadcastUpdatePlayerName

@implementation PB3BroadcastUpdatePlayerName

@dynamic id_p;
@dynamic name;

typedef struct PB3BroadcastUpdatePlayerName__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t id_p;
} PB3BroadcastUpdatePlayerName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastUpdatePlayerName_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdatePlayerName__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastUpdatePlayerName_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdatePlayerName__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastUpdatePlayerName class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastUpdatePlayerName__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastCharmLevel

@implementation PB3BroadcastCharmLevel

@dynamic id_p;
@dynamic name;
@dynamic charm;
@dynamic charmLevel;

typedef struct PB3BroadcastCharmLevel__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  NSString *name;
  int64_t id_p;
  int64_t charm;
} PB3BroadcastCharmLevel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastCharmLevel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastCharmLevel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastCharmLevel_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastCharmLevel__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastCharmLevel_FieldNumber_Charm,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastCharmLevel__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastCharmLevel_FieldNumber_CharmLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastCharmLevel__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastCharmLevel class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastCharmLevel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastWealthLevel

@implementation PB3BroadcastWealthLevel

@dynamic id_p;
@dynamic name;
@dynamic wealth;
@dynamic wealthLevel;
@dynamic oldWealth;
@dynamic oldWealthLevel;

typedef struct PB3BroadcastWealthLevel__storage_ {
  uint32_t _has_storage_[1];
  int32_t wealthLevel;
  int32_t oldWealthLevel;
  NSString *name;
  int64_t id_p;
  int64_t wealth;
  int64_t oldWealth;
} PB3BroadcastWealthLevel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_Wealth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, wealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_WealthLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "oldWealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_OldWealth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, oldWealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "oldWealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastWealthLevel_FieldNumber_OldWealthLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BroadcastWealthLevel__storage_, oldWealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastWealthLevel class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastWealthLevel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastFlowerLevel

@implementation PB3BroadcastFlowerLevel

@dynamic id_p;
@dynamic name;
@dynamic flower;
@dynamic flowerLevel;

typedef struct PB3BroadcastFlowerLevel__storage_ {
  uint32_t _has_storage_[1];
  int32_t flowerLevel;
  NSString *name;
  int64_t id_p;
  int64_t flower;
} PB3BroadcastFlowerLevel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastFlowerLevel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastFlowerLevel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastFlowerLevel_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastFlowerLevel__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flower",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastFlowerLevel_FieldNumber_Flower,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastFlowerLevel__storage_, flower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flowerLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastFlowerLevel_FieldNumber_FlowerLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastFlowerLevel__storage_, flowerLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastFlowerLevel class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastFlowerLevel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastBan

@implementation PB3BroadcastBan

@dynamic banType;
@dynamic status;
@dynamic time;
@dynamic remark;
@dynamic operaterId;

typedef struct PB3BroadcastBan__storage_ {
  uint32_t _has_storage_[1];
  uint32_t banType;
  uint32_t status;
  uint32_t time;
  NSString *remark;
  uint64_t operaterId;
} PB3BroadcastBan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "banType",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastBan_FieldNumber_BanType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastBan__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastBan_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastBan__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastBan_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastBan__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastBan_FieldNumber_Remark,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastBan__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "operaterId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastBan_FieldNumber_OperaterId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BroadcastBan__storage_, operaterId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastBan class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastBan__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BraodUpdatePlayerFlags

@implementation PB3BraodUpdatePlayerFlags

@dynamic playerId;
@dynamic flagType;
@dynamic flagVal;

typedef struct PB3BraodUpdatePlayerFlags__storage_ {
  uint32_t _has_storage_[1];
  int32_t flagType;
  int64_t playerId;
  int64_t flagVal;
} PB3BraodUpdatePlayerFlags__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BraodUpdatePlayerFlags_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BraodUpdatePlayerFlags__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "flagType",
        .dataTypeSpecific.className = NULL,
        .number = PB3BraodUpdatePlayerFlags_FieldNumber_FlagType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BraodUpdatePlayerFlags__storage_, flagType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "flagVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3BraodUpdatePlayerFlags_FieldNumber_FlagVal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BraodUpdatePlayerFlags__storage_, flagVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BraodUpdatePlayerFlags class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BraodUpdatePlayerFlags__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\010\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BraodUpdateIcon

@implementation PB3BraodUpdateIcon

@dynamic playerId;
@dynamic icon;

typedef struct PB3BraodUpdateIcon__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  int64_t playerId;
} PB3BraodUpdateIcon__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BraodUpdateIcon_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BraodUpdateIcon__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3BraodUpdateIcon_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BraodUpdateIcon__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BraodUpdateIcon class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BraodUpdateIcon__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastUpdateOnOff

@implementation PB3BroadcastUpdateOnOff

@dynamic hasOnOff, onOff;

typedef struct PB3BroadcastUpdateOnOff__storage_ {
  uint32_t _has_storage_[1];
  PB3OnOffStatus *onOff;
} PB3BroadcastUpdateOnOff__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOff",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3OnOffStatus),
        .number = PB3BroadcastUpdateOnOff_FieldNumber_OnOff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdateOnOff__storage_, onOff),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastUpdateOnOff class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastUpdateOnOff__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastShortId

@implementation PB3BroadcastShortId

@dynamic playerId;
@dynamic shortId;

typedef struct PB3BroadcastShortId__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
  int64_t shortId;
} PB3BroadcastShortId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastShortId_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastShortId__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shortId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastShortId_FieldNumber_ShortId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastShortId__storage_, shortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastShortId class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastShortId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastUpdateFlagsKV

@implementation PB3BroadcastUpdateFlagsKV

@dynamic playerId;
@dynamic flagKey;
@dynamic flagVal;

typedef struct PB3BroadcastUpdateFlagsKV__storage_ {
  uint32_t _has_storage_[1];
  PB3PlayerFlagKey flagKey;
  int32_t flagVal;
  int64_t playerId;
} PB3BroadcastUpdateFlagsKV__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastUpdateFlagsKV_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdateFlagsKV__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "flagKey",
        .dataTypeSpecific.enumDescFunc = PB3PlayerFlagKey_EnumDescriptor,
        .number = PB3BroadcastUpdateFlagsKV_FieldNumber_FlagKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdateFlagsKV__storage_, flagKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "flagVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastUpdateFlagsKV_FieldNumber_FlagVal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastUpdateFlagsKV__storage_, flagVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastUpdateFlagsKV class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastUpdateFlagsKV__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastUpdateFlagsKV_FlagKey_RawValue(PB3BroadcastUpdateFlagsKV *message) {
  GPBDescriptor *descriptor = [PB3BroadcastUpdateFlagsKV descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastUpdateFlagsKV_FieldNumber_FlagKey];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastUpdateFlagsKV_FlagKey_RawValue(PB3BroadcastUpdateFlagsKV *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastUpdateFlagsKV descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastUpdateFlagsKV_FieldNumber_FlagKey];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PlayerPunishWarning

@implementation PB3PlayerPunishWarning

@dynamic hasData_p, data_p;

typedef struct PB3PlayerPunishWarning__storage_ {
  uint32_t _has_storage_[1];
  PB3WarningData *data_p;
} PB3PlayerPunishWarning__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WarningData),
        .number = PB3PlayerPunishWarning_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerPunishWarning__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerPunishWarning class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerPunishWarning__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerInfoChange

@implementation PB3PlayerInfoChange

@dynamic hasUser, user;

typedef struct PB3PlayerInfoChange__storage_ {
  uint32_t _has_storage_[1];
  PB3GameCommPlayer *user;
} PB3PlayerInfoChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3PlayerInfoChange_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerInfoChange__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerInfoChange class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerInfoChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AccountDeleted

@implementation PB3AccountDeleted


typedef struct PB3AccountDeleted__storage_ {
  uint32_t _has_storage_[1];
} PB3AccountDeleted__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AccountDeleted class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AccountDeleted__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PushMissionRewardRedPoint

@implementation PB3PushMissionRewardRedPoint

@dynamic count;

typedef struct PB3PushMissionRewardRedPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} PB3PushMissionRewardRedPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PB3PushMissionRewardRedPoint_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PushMissionRewardRedPoint__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PushMissionRewardRedPoint class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PushMissionRewardRedPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerReq

@implementation PB3PlayerReq

@dynamic id_p;

typedef struct PB3PlayerReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3PlayerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerRes

@implementation PB3PlayerRes

@dynamic hasPlayer, player;
@dynamic accountFlags;
@dynamic effectArray, effectArray_Count;
@dynamic activityAdchannel;
@dynamic hasClan, clan;
@dynamic hasBindPhoneInfo, bindPhoneInfo;
@dynamic charmWeekRank;
@dynamic wealthWeekRank;
@dynamic hasBillPlayer, billPlayer;
@dynamic displayDownloadAppEntry;
@dynamic hasUserInfo, userInfo;
@dynamic isMinors;
@dynamic inviteCode;
@dynamic hasLastRoomInfo, lastRoomInfo;
@dynamic isBlackWhale;
@dynamic adChannel;
@dynamic realChannel;
@dynamic accountCreateAt;

typedef struct PB3PlayerRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t activityAdchannel;
  int32_t charmWeekRank;
  int32_t wealthWeekRank;
  int32_t isMinors;
  int32_t adChannel;
  int32_t realChannel;
  PB3Player *player;
  NSMutableArray *effectArray;
  PB3ClanInfo *clan;
  PB3BindPhoneInfo *bindPhoneInfo;
  PB3BillPlayerCard *billPlayer;
  PB3UserInfo *userInfo;
  NSString *inviteCode;
  PB3LastRoomInfo *lastRoomInfo;
  int64_t accountFlags;
  int64_t accountCreateAt;
} PB3PlayerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Player),
        .number = PB3PlayerRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountFlags",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_AccountFlags,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, accountFlags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3PlayerRes_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activityAdchannel",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_ActivityAdchannel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, activityAdchannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ClanInfo),
        .number = PB3PlayerRes_FieldNumber_Clan,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, clan),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindPhoneInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BindPhoneInfo),
        .number = PB3PlayerRes_FieldNumber_BindPhoneInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, bindPhoneInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "charmWeekRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_CharmWeekRank,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, charmWeekRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthWeekRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_WealthWeekRank,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, wealthWeekRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "billPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BillPlayerCard),
        .number = PB3PlayerRes_FieldNumber_BillPlayer,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, billPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayDownloadAppEntry",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_DisplayDownloadAppEntry,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserInfo),
        .number = PB3PlayerRes_FieldNumber_UserInfo,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isMinors",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_IsMinors,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, isMinors),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_InviteCode,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastRoomInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LastRoomInfo),
        .number = PB3PlayerRes_FieldNumber_LastRoomInfo,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, lastRoomInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isBlackWhale",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_IsBlackWhale,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "adChannel",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_AdChannel,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, adChannel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "realChannel",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_RealChannel,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, realChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountCreateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerRes_FieldNumber_AccountCreateAt,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3PlayerRes__storage_, accountCreateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\006\r\000\020\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LastRoomInfo

@implementation PB3LastRoomInfo

@dynamic id_p;
@dynamic id2;
@dynamic name;

typedef struct PB3LastRoomInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t id_p;
  int64_t id2;
} PB3LastRoomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3LastRoomInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LastRoomInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3LastRoomInfo_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LastRoomInfo__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3LastRoomInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LastRoomInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LastRoomInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LastRoomInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BindPhoneInfo

@implementation PB3BindPhoneInfo

@dynamic isDraw;
@dynamic phone;
@dynamic type;

typedef struct PB3BindPhoneInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3RegisterType type;
  NSString *phone;
} PB3BindPhoneInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isDraw",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneInfo_FieldNumber_IsDraw,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneInfo_FieldNumber_Phone,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BindPhoneInfo__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RegisterType_EnumDescriptor,
        .number = PB3BindPhoneInfo_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BindPhoneInfo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BindPhoneInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BindPhoneInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BindPhoneInfo_Type_RawValue(PB3BindPhoneInfo *message) {
  GPBDescriptor *descriptor = [PB3BindPhoneInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneInfo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BindPhoneInfo_Type_RawValue(PB3BindPhoneInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BindPhoneInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneInfo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PlayerInfoListReq

@implementation PB3PlayerInfoListReq

@dynamic idsArray, idsArray_Count;
@dynamic type;

typedef struct PB3PlayerInfoListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3RequestSourceType type;
  GPBInt64Array *idsArray;
} PB3PlayerInfoListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerInfoListReq_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerInfoListReq__storage_, idsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RequestSourceType_EnumDescriptor,
        .number = PB3PlayerInfoListReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerInfoListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerInfoListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerInfoListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PlayerInfoListReq_Type_RawValue(PB3PlayerInfoListReq *message) {
  GPBDescriptor *descriptor = [PB3PlayerInfoListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerInfoListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PlayerInfoListReq_Type_RawValue(PB3PlayerInfoListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PlayerInfoListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerInfoListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PlayerInfoListRes

@implementation PB3PlayerInfoListRes

@dynamic listArray, listArray_Count;

typedef struct PB3PlayerInfoListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3PlayerInfoListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerInfo),
        .number = PB3PlayerInfoListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerInfoListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerInfoListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerInfoListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelReq

@implementation PB3LevelReq


typedef struct PB3LevelReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LevelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LevelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelRes

@implementation PB3LevelRes

@dynamic charm;
@dynamic charmLevel;
@dynamic charmRank;
@dynamic wealth;
@dynamic wealthLevel;
@dynamic wealthRank;
@dynamic exp;
@dynamic expRank;
@dynamic bill;
@dynamic billLevel;
@dynamic billRank;
@dynamic billTick;
@dynamic charmExp;
@dynamic wealthExp;
@dynamic prevCharmExp;
@dynamic prevWealthExp;
@dynamic charmMaxLevel;
@dynamic wealthMaxLevel;
@dynamic newWealth;

typedef struct PB3LevelRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  int32_t charmRank;
  int32_t wealth;
  int32_t wealthLevel;
  int32_t wealthRank;
  int32_t exp;
  int32_t expRank;
  int32_t bill;
  int32_t billLevel;
  int32_t billRank;
  int32_t charmMaxLevel;
  int32_t wealthMaxLevel;
  int64_t charm;
  int64_t billTick;
  int64_t charmExp;
  int64_t wealthExp;
  int64_t prevCharmExp;
  int64_t prevWealthExp;
  int64_t newWealth;
} PB3LevelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_Charm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_CharmLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "charmRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_CharmRank,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, charmRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_Wealth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, wealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_WealthLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_WealthRank,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, wealthRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "exp",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_Exp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, exp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "expRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_ExpRank,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, expRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "bill",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_Bill,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, bill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "billLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_BillLevel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, billLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "billRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_BillRank,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, billRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "billTick",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_BillTick,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, billTick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "charmExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_CharmExp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, charmExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "wealthExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_WealthExp,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, wealthExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "prevCharmExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_PrevCharmExp,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, prevCharmExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "prevWealthExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_PrevWealthExp,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, prevWealthExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "charmMaxLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_CharmMaxLevel,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, charmMaxLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthMaxLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_WealthMaxLevel,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, wealthMaxLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "newWealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelRes_FieldNumber_NewWealth,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3LevelRes__storage_, newWealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LevelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserInfoReq

@implementation PB3UserInfoReq

@dynamic type;
@dynamic nickname;
@dynamic sex;
@dynamic city;
@dynamic signature;
@dynamic mind;
@dynamic birthday;
@dynamic voiceURL;
@dynamic sourceType;
@dynamic presetIcon;
@dynamic isRobot;
@dynamic voiceTime;

typedef struct PB3UserInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  PB3SexType sex;
  PB3SourceType sourceType;
  int32_t voiceTime;
  NSString *nickname;
  NSString *city;
  NSString *signature;
  NSString *mind;
  NSString *birthday;
  NSString *voiceURL;
  NSString *presetIcon;
} PB3UserInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3UserInfoReq_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_City,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_Signature,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mind",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_Mind,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, mind),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "birthday",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_Birthday,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, birthday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_VoiceURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceType",
        .dataTypeSpecific.enumDescFunc = PB3SourceType_EnumDescriptor,
        .number = PB3UserInfoReq_FieldNumber_SourceType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, sourceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "presetIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_PresetIcon,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, presetIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRobot",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_IsRobot,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoReq_FieldNumber_VoiceTime,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3UserInfoReq__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserInfoReq_Sex_RawValue(PB3UserInfoReq *message) {
  GPBDescriptor *descriptor = [PB3UserInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoReq_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserInfoReq_Sex_RawValue(PB3UserInfoReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoReq_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserInfoReq_SourceType_RawValue(PB3UserInfoReq *message) {
  GPBDescriptor *descriptor = [PB3UserInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoReq_FieldNumber_SourceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserInfoReq_SourceType_RawValue(PB3UserInfoReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoReq_FieldNumber_SourceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserInfoRes

@implementation PB3UserInfoRes

@dynamic type;
@dynamic status;
@dynamic oldValue;
@dynamic newValue;

typedef struct PB3UserInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  PB3AuditStatus status;
  NSString *oldValue;
  NSString *newValue;
} PB3UserInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserInfoRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserInfoRes_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserInfoRes__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "oldValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoRes_FieldNumber_OldValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserInfoRes__storage_, oldValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserInfoRes_FieldNumber_NewValue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserInfoRes__storage_, newValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserInfoRes_Status_RawValue(PB3UserInfoRes *message) {
  GPBDescriptor *descriptor = [PB3UserInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoRes_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserInfoRes_Status_RawValue(PB3UserInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserInfoRes_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MultiSetUserInfoReq

@implementation PB3MultiSetUserInfoReq

@dynamic listArray, listArray_Count;

typedef struct PB3MultiSetUserInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3MultiSetUserInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserInfoReq),
        .number = PB3MultiSetUserInfoReq_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MultiSetUserInfoReq__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MultiSetUserInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MultiSetUserInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MultiSetUserInfoRes

@implementation PB3MultiSetUserInfoRes


typedef struct PB3MultiSetUserInfoRes__storage_ {
  uint32_t _has_storage_[1];
} PB3MultiSetUserInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MultiSetUserInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MultiSetUserInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationSexTypeReq

@implementation PB3CertificationSexTypeReq


typedef struct PB3CertificationSexTypeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CertificationSexTypeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationSexTypeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CertificationSexTypeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationSexTypeRes

@implementation PB3CertificationSexTypeRes

@dynamic sex;

typedef struct PB3CertificationSexTypeRes__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
} PB3CertificationSexTypeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3CertificationSexTypeRes_FieldNumber_Sex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CertificationSexTypeRes__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationSexTypeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CertificationSexTypeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CertificationSexTypeRes_Sex_RawValue(PB3CertificationSexTypeRes *message) {
  GPBDescriptor *descriptor = [PB3CertificationSexTypeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CertificationSexTypeRes_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CertificationSexTypeRes_Sex_RawValue(PB3CertificationSexTypeRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CertificationSexTypeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CertificationSexTypeRes_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserAuditDetailReq

@implementation PB3UserAuditDetailReq


typedef struct PB3UserAuditDetailReq__storage_ {
  uint32_t _has_storage_[1];
} PB3UserAuditDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserAuditDetailReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserAuditDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserAuditDetailRes

@implementation PB3UserAuditDetailRes

@dynamic playerId;
@dynamic nickName;
@dynamic nickNameStatus;
@dynamic icon;
@dynamic iconStatus;
@dynamic sign;
@dynamic signStatus;
@dynamic mind;
@dynamic mindStatus;
@dynamic voice;
@dynamic voiceTime;
@dynamic voiceStatus;
@dynamic hasVoiceTagInfo, voiceTagInfo;
@dynamic voiceTagStatus;

typedef struct PB3UserAuditDetailRes__storage_ {
  uint32_t _has_storage_[1];
  PB3AuditStatus nickNameStatus;
  PB3AuditStatus iconStatus;
  PB3AuditStatus signStatus;
  PB3AuditStatus mindStatus;
  int32_t voiceTime;
  PB3AuditStatus voiceStatus;
  PB3AuditStatus voiceTagStatus;
  NSString *nickName;
  NSString *icon;
  NSString *sign;
  NSString *mind;
  NSString *voice;
  PB3VoiceTagInfo *voiceTagInfo;
  int64_t playerId;
} PB3UserAuditDetailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickNameStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_NickNameStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, nickNameStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_IconStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, iconStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_Sign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_SignStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, signStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mind",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_Mind,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, mind),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mindStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_MindStatus,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, mindStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "voice",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_Voice,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserAuditDetailRes_FieldNumber_VoiceTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_VoiceStatus,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, voiceStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "voiceTagInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagInfo),
        .number = PB3UserAuditDetailRes_FieldNumber_VoiceTagInfo,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, voiceTagInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceTagStatus",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3UserAuditDetailRes_FieldNumber_VoiceTagStatus,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3UserAuditDetailRes__storage_, voiceTagStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserAuditDetailRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserAuditDetailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserAuditDetailRes_NickNameStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_NickNameStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_NickNameStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_NickNameStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserAuditDetailRes_IconStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_IconStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_IconStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_IconStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserAuditDetailRes_SignStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_SignStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_SignStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_SignStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserAuditDetailRes_MindStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_MindStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_MindStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_MindStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserAuditDetailRes_VoiceStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_VoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_VoiceStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_VoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserAuditDetailRes_VoiceTagStatus_RawValue(PB3UserAuditDetailRes *message) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_VoiceTagStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserAuditDetailRes_VoiceTagStatus_RawValue(PB3UserAuditDetailRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserAuditDetailRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserAuditDetailRes_FieldNumber_VoiceTagStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserSetting

@implementation PB3UserSetting

@dynamic userId;
@dynamic imFriend;
@dynamic imMessage;
@dynamic imWealthLevel;
@dynamic isInvite;
@dynamic isPosition;
@dynamic isWealth;
@dynamic isRemind;
@dynamic isTotalRemind;
@dynamic chatShowCity;

typedef struct PB3UserSetting__storage_ {
  uint32_t _has_storage_[1];
  uint32_t imWealthLevel;
  int64_t userId;
} PB3UserSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserSetting__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "imFriend",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_ImFriend,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "imMessage",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_ImMessage,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "imWealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_ImWealthLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UserSetting__storage_, imWealthLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isInvite",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_IsInvite,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isPosition",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_IsPosition,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isWealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_IsWealth,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isRemind",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_IsRemind,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isTotalRemind",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_IsTotalRemind,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chatShowCity",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserSetting_FieldNumber_ChatShowCity,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserSetting class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\006\000\002\010\000\003\t\000\004\r\000\005\010\000\006\n\000\007\010\000\010\010\000\t\r\000\014\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetUserSettingRes

@implementation PB3SetUserSettingRes


typedef struct PB3SetUserSettingRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetUserSettingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetUserSettingRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetUserSettingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangeBankBindReq

@implementation PB3ChangeBankBindReq

@dynamic oldPhone;
@dynamic name;
@dynamic identityCardNo;
@dynamic oldBankCard;
@dynamic newPhone;
@dynamic newBankCard;
@dynamic openBank;
@dynamic accountBank;

typedef struct PB3ChangeBankBindReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *oldPhone;
  NSString *name;
  NSString *identityCardNo;
  NSString *oldBankCard;
  NSString *newPhone;
  NSString *newBankCard;
  NSString *openBank;
  NSString *accountBank;
} PB3ChangeBankBindReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldPhone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_OldPhone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, oldPhone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_IdentityCardNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oldBankCard",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_OldBankCard,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, oldBankCard),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPhone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_NewPhone,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, newPhone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newBankCard",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_NewBankCard,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, newBankCard),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openBank",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_OpenBank,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, openBank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountBank",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindReq_FieldNumber_AccountBank,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindReq__storage_, accountBank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangeBankBindReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangeBankBindReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangeBankBindRes

@implementation PB3ChangeBankBindRes

@dynamic type;
@dynamic name;
@dynamic time;

typedef struct PB3ChangeBankBindRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  NSString *name;
  NSString *time;
} PB3ChangeBankBindRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3ChangeBankBindRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeBankBindRes_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ChangeBankBindRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangeBankBindRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangeBankBindRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ChangeBankBindRes_Type_RawValue(PB3ChangeBankBindRes *message) {
  GPBDescriptor *descriptor = [PB3ChangeBankBindRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChangeBankBindRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ChangeBankBindRes_Type_RawValue(PB3ChangeBankBindRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ChangeBankBindRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChangeBankBindRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ChangePasswdReq

@implementation PB3ChangePasswdReq

@dynamic value;
@dynamic playerId;

typedef struct PB3ChangePasswdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
  int64_t playerId;
} PB3ChangePasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangePasswdReq_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangePasswdReq__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangePasswdReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChangePasswdReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangePasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangePasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangePasswdRes

@implementation PB3ChangePasswdRes


typedef struct PB3ChangePasswdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ChangePasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangePasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ChangePasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GettingPasswdReq

@implementation PB3GettingPasswdReq


typedef struct PB3GettingPasswdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GettingPasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GettingPasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GettingPasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GettingPasswdRes

@implementation PB3GettingPasswdRes

@dynamic value;

typedef struct PB3GettingPasswdRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
} PB3GettingPasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3GettingPasswdRes_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GettingPasswdRes__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GettingPasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GettingPasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SuperManagerReq

@implementation PB3SuperManagerReq

@dynamic playerId;
@dynamic banType;
@dynamic time;
@dynamic opType;

typedef struct PB3SuperManagerReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t banType;
  uint32_t time;
  int32_t opType;
  int64_t playerId;
} PB3SuperManagerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SuperManagerReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SuperManagerReq__storage_, playerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "banType",
        .dataTypeSpecific.className = NULL,
        .number = PB3SuperManagerReq_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SuperManagerReq__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3SuperManagerReq_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SuperManagerReq__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = PB3SuperManagerReq_FieldNumber_OpType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SuperManagerReq__storage_, opType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SuperManagerReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SuperManagerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\007\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SuperManagerRes

@implementation PB3SuperManagerRes


typedef struct PB3SuperManagerRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SuperManagerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SuperManagerRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SuperManagerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetOnOffListReq

@implementation PB3GetOnOffListReq

@dynamic playerId;

typedef struct PB3GetOnOffListReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetOnOffListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetOnOffListReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetOnOffListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetOnOffListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetOnOffListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetOnOffListRes

@implementation PB3GetOnOffListRes

@dynamic statusListArray, statusListArray_Count;

typedef struct PB3GetOnOffListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *statusListArray;
} PB3GetOnOffListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3OnOffStatus),
        .number = PB3GetOnOffListRes_FieldNumber_StatusListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetOnOffListRes__storage_, statusListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetOnOffListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetOnOffListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchPlayersReq

@implementation PB3SearchPlayersReq

@dynamic page;
@dynamic pageSize;
@dynamic keyWord;

typedef struct PB3SearchPlayersReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  NSString *keyWord;
} PB3SearchPlayersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayersReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchPlayersReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayersReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchPlayersReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "keyWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayersReq_FieldNumber_KeyWord,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SearchPlayersReq__storage_, keyWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchPlayersReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchPlayersReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchPlayersRes

@implementation PB3SearchPlayersRes

@dynamic page;
@dynamic pageSize;
@dynamic listArray, listArray_Count;

typedef struct PB3SearchPlayersRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  NSMutableArray *listArray;
} PB3SearchPlayersRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayersRes_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchPlayersRes__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayersRes_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchPlayersRes__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SearchPlayerEntry),
        .number = PB3SearchPlayersRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchPlayersRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchPlayersRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchPlayersRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchPlayers

@implementation PB3SearchPlayers

@dynamic page;
@dynamic pageSize;
@dynamic keyWord;
@dynamic listArray, listArray_Count;

typedef struct PB3SearchPlayers__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  NSString *keyWord;
  NSMutableArray *listArray;
} PB3SearchPlayers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayers_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchPlayers__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayers_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchPlayers__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "keyWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchPlayers_FieldNumber_KeyWord,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SearchPlayers__storage_, keyWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SearchPlayerEntry),
        .number = PB3SearchPlayers_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchPlayers__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchPlayers class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchPlayers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerGainsReq

@implementation PB3GetPlayerGainsReq

@dynamic type;

typedef struct PB3GetPlayerGainsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
} PB3GetPlayerGainsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerGainsReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPlayerGainsReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerGainsReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerGainsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerGainsRes

@implementation PB3GetPlayerGainsRes

@dynamic today;
@dynamic week;
@dynamic month;
@dynamic lastMonth;

typedef struct PB3GetPlayerGainsRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *today;
  NSString *week;
  NSString *month;
  NSString *lastMonth;
} PB3GetPlayerGainsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "today",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerGainsRes_FieldNumber_Today,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPlayerGainsRes__storage_, today),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "week",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerGainsRes_FieldNumber_Week,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPlayerGainsRes__storage_, week),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "month",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerGainsRes_FieldNumber_Month,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPlayerGainsRes__storage_, month),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastMonth",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerGainsRes_FieldNumber_LastMonth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetPlayerGainsRes__storage_, lastMonth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerGainsRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerGainsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTotalGainReq

@implementation PB3GetTotalGainReq

@dynamic type;

typedef struct PB3GetTotalGainReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
} PB3GetTotalGainReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTotalGainReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetTotalGainReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTotalGainReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetTotalGainReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTotalGainRes

@implementation PB3GetTotalGainRes

@dynamic totalGain;

typedef struct PB3GetTotalGainRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *totalGain;
} PB3GetTotalGainRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalGain",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTotalGainRes_FieldNumber_TotalGain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetTotalGainRes__storage_, totalGain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTotalGainRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetTotalGainRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MailMsg

@implementation PB3MailMsg

@dynamic id_p;
@dynamic cmdId;
@dynamic createAt;
@dynamic data_p;
@dynamic type;

typedef struct PB3MailMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdId;
  int32_t createAt;
  PB3UserMailType type;
  NSData *data_p;
  int64_t id_p;
} PB3MailMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MailMsg_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MailMsg__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MailMsg_FieldNumber_CmdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MailMsg__storage_, cmdId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3MailMsg_FieldNumber_CreateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MailMsg__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MailMsg_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MailMsg__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UserMailType_EnumDescriptor,
        .number = PB3MailMsg_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3MailMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MailMsg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MailMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MailMsg_Type_RawValue(PB3MailMsg *message) {
  GPBDescriptor *descriptor = [PB3MailMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MailMsg_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MailMsg_Type_RawValue(PB3MailMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MailMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MailMsg_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MailMsgs

@implementation PB3MailMsgs

@dynamic msgsArray, msgsArray_Count;

typedef struct PB3MailMsgs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
} PB3MailMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MailMsg),
        .number = PB3MailMsgs_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MailMsgs__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MailMsgs class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MailMsgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReadMailReq

@implementation PB3ReadMailReq

@dynamic lastReadTime;
@dynamic type;

typedef struct PB3ReadMailReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t lastReadTime;
  PB3UserMailType type;
} PB3ReadMailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastReadTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReadMailReq_FieldNumber_LastReadTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReadMailReq__storage_, lastReadTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UserMailType_EnumDescriptor,
        .number = PB3ReadMailReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReadMailReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReadMailReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReadMailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReadMailReq_Type_RawValue(PB3ReadMailReq *message) {
  GPBDescriptor *descriptor = [PB3ReadMailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReadMailReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReadMailReq_Type_RawValue(PB3ReadMailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReadMailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReadMailReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReadMailRes

@implementation PB3ReadMailRes

@dynamic listArray, listArray_Count;
@dynamic msgIdArray, msgIdArray_Count;

typedef struct PB3ReadMailRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  GPBInt64Array *msgIdArray;
} PB3ReadMailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MailMsg),
        .number = PB3ReadMailRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ReadMailRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReadMailRes_FieldNumber_MsgIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ReadMailRes__storage_, msgIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReadMailRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReadMailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LastMailReq

@implementation PB3LastMailReq

@dynamic lastReadTime;
@dynamic type;

typedef struct PB3LastMailReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t lastReadTime;
  PB3UserMailType type;
} PB3LastMailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastReadTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3LastMailReq_FieldNumber_LastReadTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LastMailReq__storage_, lastReadTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UserMailType_EnumDescriptor,
        .number = PB3LastMailReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LastMailReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LastMailReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LastMailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LastMailReq_Type_RawValue(PB3LastMailReq *message) {
  GPBDescriptor *descriptor = [PB3LastMailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LastMailReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LastMailReq_Type_RawValue(PB3LastMailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LastMailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LastMailReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LastMailRes

@implementation PB3LastMailRes

@dynamic flag;

typedef struct PB3LastMailRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LastMailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3LastMailRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LastMailRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LastMailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastMailMsg

@implementation PB3BroadcastMailMsg

@dynamic hasMail, mail;

typedef struct PB3BroadcastMailMsg__storage_ {
  uint32_t _has_storage_[1];
  PB3MailMsg *mail;
} PB3BroadcastMailMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MailMsg),
        .number = PB3BroadcastMailMsg_FieldNumber_Mail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastMailMsg__storage_, mail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastMailMsg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastMailMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPhoneUsedReq

@implementation PB3GetPhoneUsedReq

@dynamic countryCode;
@dynamic phoneNo;
@dynamic phoneSign;

typedef struct PB3GetPhoneUsedReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *countryCode;
  NSString *phoneNo;
  NSString *phoneSign;
} PB3GetPhoneUsedReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "countryCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPhoneUsedReq_FieldNumber_CountryCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPhoneUsedReq__storage_, countryCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPhoneUsedReq_FieldNumber_PhoneNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPhoneUsedReq__storage_, phoneNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneSign",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPhoneUsedReq_FieldNumber_PhoneSign,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPhoneUsedReq__storage_, phoneSign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPhoneUsedReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPhoneUsedReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPhoneUsedRes

@implementation PB3GetPhoneUsedRes

@dynamic isUsed;

typedef struct PB3GetPhoneUsedRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetPhoneUsedRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isUsed",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPhoneUsedRes_FieldNumber_IsUsed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPhoneUsedRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPhoneUsedRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NewAuthTokenReq

@implementation PB3NewAuthTokenReq


typedef struct PB3NewAuthTokenReq__storage_ {
  uint32_t _has_storage_[1];
} PB3NewAuthTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NewAuthTokenReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3NewAuthTokenReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NewAuthTokenRes

@implementation PB3NewAuthTokenRes

@dynamic authReqToken;

typedef struct PB3NewAuthTokenRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *authReqToken;
} PB3NewAuthTokenRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authReqToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3NewAuthTokenRes_FieldNumber_AuthReqToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NewAuthTokenRes__storage_, authReqToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NewAuthTokenRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NewAuthTokenRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthReqTokenConfirmReq

@implementation PB3AuthReqTokenConfirmReq

@dynamic authReqToken;

typedef struct PB3AuthReqTokenConfirmReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *authReqToken;
} PB3AuthReqTokenConfirmReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authReqToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthReqTokenConfirmReq_FieldNumber_AuthReqToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthReqTokenConfirmReq__storage_, authReqToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthReqTokenConfirmReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthReqTokenConfirmReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthReqTokenConfirmRes

@implementation PB3AuthReqTokenConfirmRes


typedef struct PB3AuthReqTokenConfirmRes__storage_ {
  uint32_t _has_storage_[1];
} PB3AuthReqTokenConfirmRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthReqTokenConfirmRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuthReqTokenConfirmRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthReqResultReq

@implementation PB3AuthReqResultReq

@dynamic authReqToken;

typedef struct PB3AuthReqResultReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *authReqToken;
} PB3AuthReqResultReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authReqToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthReqResultReq_FieldNumber_AuthReqToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthReqResultReq__storage_, authReqToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthReqResultReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthReqResultReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthReqResultRes

@implementation PB3AuthReqResultRes

@dynamic result;
@dynamic loginToken;

typedef struct PB3AuthReqResultRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
  NSString *loginToken;
} PB3AuthReqResultRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthReqResultRes_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthReqResultRes__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "loginToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthReqResultRes_FieldNumber_LoginToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthReqResultRes__storage_, loginToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthReqResultRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthReqResultRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RoomGiftTicketReq

@implementation PB3RoomGiftTicketReq

@dynamic playerId;

typedef struct PB3RoomGiftTicketReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3RoomGiftTicketReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RoomGiftTicketReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RoomGiftTicketReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RoomGiftTicketReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RoomGiftTicketReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RoomGiftTicketRes

@implementation PB3RoomGiftTicketRes

@dynamic result;
@dynamic value;

typedef struct PB3RoomGiftTicketRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t result;
  int64_t value;
} PB3RoomGiftTicketRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = PB3RoomGiftTicketRes_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RoomGiftTicketRes__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3RoomGiftTicketRes_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RoomGiftTicketRes__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RoomGiftTicketRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RoomGiftTicketRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HasUpdateSexPasswdReq

@implementation PB3HasUpdateSexPasswdReq


typedef struct PB3HasUpdateSexPasswdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3HasUpdateSexPasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HasUpdateSexPasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3HasUpdateSexPasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HasUpdateSexPasswdRes

@implementation PB3HasUpdateSexPasswdRes

@dynamic isSet;
@dynamic isSetInterest;

typedef struct PB3HasUpdateSexPasswdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3HasUpdateSexPasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isSet",
        .dataTypeSpecific.className = NULL,
        .number = PB3HasUpdateSexPasswdRes_FieldNumber_IsSet,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isSetInterest",
        .dataTypeSpecific.className = NULL,
        .number = PB3HasUpdateSexPasswdRes_FieldNumber_IsSetInterest,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HasUpdateSexPasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HasUpdateSexPasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetUpdateSexPasswdReq

@implementation PB3SetUpdateSexPasswdReq


typedef struct PB3SetUpdateSexPasswdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SetUpdateSexPasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetUpdateSexPasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetUpdateSexPasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetUpdateSexPasswdRes

@implementation PB3SetUpdateSexPasswdRes


typedef struct PB3SetUpdateSexPasswdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetUpdateSexPasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetUpdateSexPasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetUpdateSexPasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSexReq

@implementation PB3UpdateSexReq


typedef struct PB3UpdateSexReq__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdateSexReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSexReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdateSexReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSexRes

@implementation PB3UpdateSexRes


typedef struct PB3UpdateSexRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdateSexRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSexRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdateSexRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdatePasswdReq

@implementation PB3UpdatePasswdReq

@dynamic oldPasswd;
@dynamic newPasswd1;
@dynamic newPasswd2;

typedef struct PB3UpdatePasswdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *oldPasswd;
  NSString *newPasswd1;
  NSString *newPasswd2;
} PB3UpdatePasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldPasswd",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdReq_FieldNumber_OldPasswd,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdReq__storage_, oldPasswd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPasswd1",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdReq_FieldNumber_NewPasswd1,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdReq__storage_, newPasswd1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPasswd2",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdReq_FieldNumber_NewPasswd2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdReq__storage_, newPasswd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdatePasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdatePasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdatePasswdRes

@implementation PB3UpdatePasswdRes


typedef struct PB3UpdatePasswdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdatePasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdatePasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdatePasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdatePasswdChangePhoneReq

@implementation PB3UpdatePasswdChangePhoneReq

@dynamic newPasswd1;
@dynamic newPasswd2;
@dynamic name;
@dynamic identityCardNo;
@dynamic identityCardPhoto;
@dynamic id_p;
@dynamic phone;

typedef struct PB3UpdatePasswdChangePhoneReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *newPasswd1;
  NSString *newPasswd2;
  NSString *name;
  NSString *identityCardNo;
  NSString *identityCardPhoto;
  NSString *phone;
  int64_t id_p;
} PB3UpdatePasswdChangePhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newPasswd1",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_NewPasswd1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, newPasswd1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPasswd2",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_NewPasswd2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, newPasswd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_IdentityCardNo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardPhoto",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_IdentityCardPhoto,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, identityCardPhoto),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_Id_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneReq_FieldNumber_Phone,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdatePasswdChangePhoneReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdatePasswdChangePhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdatePasswdChangePhoneRes

@implementation PB3UpdatePasswdChangePhoneRes

@dynamic type;
@dynamic name;
@dynamic time;

typedef struct PB3UpdatePasswdChangePhoneRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  NSString *name;
  NSString *time;
} PB3UpdatePasswdChangePhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3UpdatePasswdChangePhoneRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdatePasswdChangePhoneRes_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UpdatePasswdChangePhoneRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdatePasswdChangePhoneRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdatePasswdChangePhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UpdatePasswdChangePhoneRes_Type_RawValue(PB3UpdatePasswdChangePhoneRes *message) {
  GPBDescriptor *descriptor = [PB3UpdatePasswdChangePhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UpdatePasswdChangePhoneRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UpdatePasswdChangePhoneRes_Type_RawValue(PB3UpdatePasswdChangePhoneRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UpdatePasswdChangePhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UpdatePasswdChangePhoneRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ChangeExchangePasswdReq

@implementation PB3ChangeExchangePasswdReq

@dynamic newPasswd1;
@dynamic newPasswd2;
@dynamic name;
@dynamic identityCardNo;
@dynamic identityCardPhoto;
@dynamic cardNum;
@dynamic phone;

typedef struct PB3ChangeExchangePasswdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *newPasswd1;
  NSString *newPasswd2;
  NSString *name;
  NSString *identityCardNo;
  NSString *identityCardPhoto;
  NSString *cardNum;
  NSString *phone;
} PB3ChangeExchangePasswdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newPasswd1",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_NewPasswd1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, newPasswd1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPasswd2",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_NewPasswd2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, newPasswd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_IdentityCardNo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardPhoto",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_IdentityCardPhoto,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, identityCardPhoto),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_CardNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, cardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdReq_FieldNumber_Phone,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangeExchangePasswdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangeExchangePasswdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangeExchangePasswdRes

@implementation PB3ChangeExchangePasswdRes

@dynamic type;
@dynamic name;
@dynamic time;

typedef struct PB3ChangeExchangePasswdRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  NSString *name;
  NSString *time;
} PB3ChangeExchangePasswdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3ChangeExchangePasswdRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChangeExchangePasswdRes_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ChangeExchangePasswdRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangeExchangePasswdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangeExchangePasswdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ChangeExchangePasswdRes_Type_RawValue(PB3ChangeExchangePasswdRes *message) {
  GPBDescriptor *descriptor = [PB3ChangeExchangePasswdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChangeExchangePasswdRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ChangeExchangePasswdRes_Type_RawValue(PB3ChangeExchangePasswdRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ChangeExchangePasswdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChangeExchangePasswdRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BindPhoneReq

@implementation PB3BindPhoneReq

@dynamic phoneAreaCode;
@dynamic phone;
@dynamic code;
@dynamic opType;
@dynamic yidunToken;
@dynamic phoneSign;

typedef struct PB3BindPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UserBindPhoneOpType opType;
  NSString *phoneAreaCode;
  NSString *phone;
  NSString *code;
  NSString *yidunToken;
  NSString *phoneSign;
} PB3BindPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneAreaCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneReq_FieldNumber_PhoneAreaCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, phoneAreaCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneReq_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, phone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneReq_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opType",
        .dataTypeSpecific.enumDescFunc = PB3UserBindPhoneOpType_EnumDescriptor,
        .number = PB3BindPhoneReq_FieldNumber_OpType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, opType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "yidunToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneReq_FieldNumber_YidunToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, yidunToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneSign",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneReq_FieldNumber_PhoneSign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BindPhoneReq__storage_, phoneSign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BindPhoneReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BindPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001M\000\002E\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BindPhoneReq_OpType_RawValue(PB3BindPhoneReq *message) {
  GPBDescriptor *descriptor = [PB3BindPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneReq_FieldNumber_OpType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BindPhoneReq_OpType_RawValue(PB3BindPhoneReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BindPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneReq_FieldNumber_OpType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3H5BindPhoneReq

@implementation PB3H5BindPhoneReq

@dynamic phoneAreaCode;
@dynamic phone;
@dynamic code;
@dynamic opType;

typedef struct PB3H5BindPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UserBindPhoneOpType opType;
  NSString *phoneAreaCode;
  NSString *phone;
  NSString *code;
} PB3H5BindPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneAreaCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3H5BindPhoneReq_FieldNumber_PhoneAreaCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3H5BindPhoneReq__storage_, phoneAreaCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3H5BindPhoneReq_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3H5BindPhoneReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3H5BindPhoneReq_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3H5BindPhoneReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opType",
        .dataTypeSpecific.enumDescFunc = PB3UserBindPhoneOpType_EnumDescriptor,
        .number = PB3H5BindPhoneReq_FieldNumber_OpType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3H5BindPhoneReq__storage_, opType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3H5BindPhoneReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3H5BindPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3H5BindPhoneReq_OpType_RawValue(PB3H5BindPhoneReq *message) {
  GPBDescriptor *descriptor = [PB3H5BindPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3H5BindPhoneReq_FieldNumber_OpType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3H5BindPhoneReq_OpType_RawValue(PB3H5BindPhoneReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3H5BindPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3H5BindPhoneReq_FieldNumber_OpType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BindPhoneRes

@implementation PB3BindPhoneRes

@dynamic isSucc;
@dynamic phone;

typedef struct PB3BindPhoneRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
} PB3BindPhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isSucc",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneRes_FieldNumber_IsSucc,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneRes_FieldNumber_Phone,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BindPhoneRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BindPhoneRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BindPhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BindPhoneItem

@implementation PB3BindPhoneItem

@dynamic giftId;
@dynamic image;
@dynamic name;
@dynamic giftDescription;
@dynamic newUserGift;
@dynamic number;
@dynamic itemType;

typedef struct PB3BindPhoneItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t newUserGift;
  int32_t number;
  PB3UserBindPhoneItemType itemType;
  NSString *image;
  NSString *name;
  NSString *giftDescription;
} PB3BindPhoneItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_Image,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftDescription",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_GiftDescription,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, giftDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newUserGift",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_NewUserGift,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, newUserGift),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhoneItem_FieldNumber_Number,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "itemType",
        .dataTypeSpecific.enumDescFunc = PB3UserBindPhoneItemType_EnumDescriptor,
        .number = PB3BindPhoneItem_FieldNumber_ItemType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BindPhoneItem__storage_, itemType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BindPhoneItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BindPhoneItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BindPhoneItem_ItemType_RawValue(PB3BindPhoneItem *message) {
  GPBDescriptor *descriptor = [PB3BindPhoneItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneItem_FieldNumber_ItemType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BindPhoneItem_ItemType_RawValue(PB3BindPhoneItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BindPhoneItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhoneItem_FieldNumber_ItemType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetBindPhoneItemReq

@implementation PB3GetBindPhoneItemReq


typedef struct PB3GetBindPhoneItemReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetBindPhoneItemReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetBindPhoneItemReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetBindPhoneItemReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetBindPhoneItemRes

@implementation PB3GetBindPhoneItemRes

@dynamic listArray, listArray_Count;
@dynamic isForce;

typedef struct PB3GetBindPhoneItemRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3GetBindPhoneItemRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BindPhoneItem),
        .number = PB3GetBindPhoneItemRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetBindPhoneItemRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isForce",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetBindPhoneItemRes_FieldNumber_IsForce,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetBindPhoneItemRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetBindPhoneItemRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CanRechargeCreditReq

@implementation PB3CanRechargeCreditReq

@dynamic playerId;

typedef struct PB3CanRechargeCreditReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3CanRechargeCreditReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CanRechargeCreditReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CanRechargeCreditReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CanRechargeCreditReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CanRechargeCreditReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CanRechargeCreditRes

@implementation PB3CanRechargeCreditRes

@dynamic dayRemainCredit;
@dynamic totalRemainCredit;
@dynamic isLimit;

typedef struct PB3CanRechargeCreditRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dayRemainCredit;
  uint32_t totalRemainCredit;
} PB3CanRechargeCreditRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dayRemainCredit",
        .dataTypeSpecific.className = NULL,
        .number = PB3CanRechargeCreditRes_FieldNumber_DayRemainCredit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CanRechargeCreditRes__storage_, dayRemainCredit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalRemainCredit",
        .dataTypeSpecific.className = NULL,
        .number = PB3CanRechargeCreditRes_FieldNumber_TotalRemainCredit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CanRechargeCreditRes__storage_, totalRemainCredit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3CanRechargeCreditRes_FieldNumber_IsLimit,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CanRechargeCreditRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CanRechargeCreditRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BindPhonePlayer

@implementation PB3BindPhonePlayer

@dynamic id_p;
@dynamic id2;
@dynamic name;
@dynamic icon;
@dynamic type;

typedef struct PB3BindPhonePlayer__storage_ {
  uint32_t _has_storage_[1];
  PB3AccountChannelType type;
  NSString *name;
  NSString *icon;
  int64_t id_p;
  int64_t id2;
} PB3BindPhonePlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhonePlayer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BindPhonePlayer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhonePlayer_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BindPhonePlayer__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhonePlayer_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BindPhonePlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3BindPhonePlayer_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BindPhonePlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AccountChannelType_EnumDescriptor,
        .number = PB3BindPhonePlayer_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BindPhonePlayer__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BindPhonePlayer class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BindPhonePlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BindPhonePlayer_Type_RawValue(PB3BindPhonePlayer *message) {
  GPBDescriptor *descriptor = [PB3BindPhonePlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhonePlayer_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BindPhonePlayer_Type_RawValue(PB3BindPhonePlayer *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BindPhonePlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BindPhonePlayer_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ShowBindPhoneIdsReq

@implementation PB3ShowBindPhoneIdsReq


typedef struct PB3ShowBindPhoneIdsReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ShowBindPhoneIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ShowBindPhoneIdsReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ShowBindPhoneIdsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ShowBindPhoneIdsRes

@implementation PB3ShowBindPhoneIdsRes

@dynamic isBindPhone;
@dynamic listArray, listArray_Count;
@dynamic changePower;
@dynamic isOpen;
@dynamic isShowAdd;
@dynamic contentArray, contentArray_Count;
@dynamic phone;
@dynamic accountNum;
@dynamic isWechatOrQq;
@dynamic isShowIcon;

typedef struct PB3ShowBindPhoneIdsRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t accountNum;
  NSMutableArray *listArray;
  NSMutableArray *contentArray;
  NSString *phone;
} PB3ShowBindPhoneIdsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isBindPhone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_IsBindPhone,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BindPhonePlayer),
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ShowBindPhoneIdsRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "changePower",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_ChangePower,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_IsOpen,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isShowAdd",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_IsShowAdd,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ShowBindPhoneIdsRes__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_Phone,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3ShowBindPhoneIdsRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_AccountNum,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3ShowBindPhoneIdsRes__storage_, accountNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isWechatOrQq",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_IsWechatOrQq,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isShowIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShowBindPhoneIdsRes_FieldNumber_IsShowIcon,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ShowBindPhoneIdsRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ShowBindPhoneIdsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CreateNewTokenReq

@implementation PB3CreateNewTokenReq

@dynamic id_p;

typedef struct PB3CreateNewTokenReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3CreateNewTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CreateNewTokenReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CreateNewTokenReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CreateNewTokenReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CreateNewTokenReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CreateNewTokenRes

@implementation PB3CreateNewTokenRes

@dynamic key;

typedef struct PB3CreateNewTokenRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
} PB3CreateNewTokenRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3CreateNewTokenRes_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CreateNewTokenRes__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CreateNewTokenRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CreateNewTokenRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCertificationReq

@implementation PB3GetCertificationReq

@dynamic id_p;

typedef struct PB3GetCertificationReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3GetCertificationReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCertificationReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetCertificationReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCertificationReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCertificationReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCertificationRes

@implementation PB3GetCertificationRes

@dynamic flag;

typedef struct PB3GetCertificationRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetCertificationRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCertificationRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCertificationRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCertificationRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCertificationInfoReq

@implementation PB3GetCertificationInfoReq

@dynamic certifyId;

typedef struct PB3GetCertificationInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *certifyId;
} PB3GetCertificationInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certifyId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCertificationInfoReq_FieldNumber_CertifyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetCertificationInfoReq__storage_, certifyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCertificationInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCertificationInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCertificationInfoRes

@implementation PB3GetCertificationInfoRes

@dynamic name;
@dynamic identityCardNo;

typedef struct PB3GetCertificationInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *identityCardNo;
} PB3GetCertificationInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCertificationInfoRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetCertificationInfoRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCertificationInfoRes_FieldNumber_IdentityCardNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetCertificationInfoRes__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCertificationInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCertificationInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationInfoReq

@implementation PB3CertificationInfoReq


typedef struct PB3CertificationInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CertificationInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CertificationInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationInfoRes

@implementation PB3CertificationInfoRes

@dynamic name;
@dynamic identityCardNo;

typedef struct PB3CertificationInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *identityCardNo;
} PB3CertificationInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationInfoRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CertificationInfoRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationInfoRes_FieldNumber_IdentityCardNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CertificationInfoRes__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CertificationInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationUrlReq

@implementation PB3CertificationUrlReq

@dynamic name;
@dynamic identityCardNo;

typedef struct PB3CertificationUrlReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *identityCardNo;
} PB3CertificationUrlReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationUrlReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CertificationUrlReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationUrlReq_FieldNumber_IdentityCardNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CertificationUrlReq__storage_, identityCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationUrlReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CertificationUrlReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CertificationUrlRes

@implementation PB3CertificationUrlRes

@dynamic targetURL;
@dynamic bizNo;

typedef struct PB3CertificationUrlRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *targetURL;
  NSString *bizNo;
} PB3CertificationUrlRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationUrlRes_FieldNumber_TargetURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CertificationUrlRes__storage_, targetURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bizNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3CertificationUrlRes_FieldNumber_BizNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CertificationUrlRes__storage_, bizNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CertificationUrlRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CertificationUrlRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthGetCjIdReq

@implementation PB3AuthGetCjIdReq


typedef struct PB3AuthGetCjIdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AuthGetCjIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthGetCjIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuthGetCjIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthGetCjIdRes

@implementation PB3AuthGetCjIdRes

@dynamic mzId;
@dynamic cjId;

typedef struct PB3AuthGetCjIdRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t mzId;
  int64_t cjId;
} PB3AuthGetCjIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mzId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthGetCjIdRes_FieldNumber_MzId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthGetCjIdRes__storage_, mzId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cjId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthGetCjIdRes_FieldNumber_CjId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthGetCjIdRes__storage_, cjId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthGetCjIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthGetCjIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DialogCallbackReq

@implementation PB3DialogCallbackReq

@dynamic callbackData;
@dynamic type;

typedef struct PB3DialogCallbackReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DialogButtonType type;
  NSData *callbackData;
} PB3DialogCallbackReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callbackData",
        .dataTypeSpecific.className = NULL,
        .number = PB3DialogCallbackReq_FieldNumber_CallbackData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DialogCallbackReq__storage_, callbackData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3DialogButtonType_EnumDescriptor,
        .number = PB3DialogCallbackReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DialogCallbackReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DialogCallbackReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DialogCallbackReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3DialogCallbackReq_Type_RawValue(PB3DialogCallbackReq *message) {
  GPBDescriptor *descriptor = [PB3DialogCallbackReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DialogCallbackReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3DialogCallbackReq_Type_RawValue(PB3DialogCallbackReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3DialogCallbackReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DialogCallbackReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3DialogCallbackRes

@implementation PB3DialogCallbackRes


typedef struct PB3DialogCallbackRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DialogCallbackRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DialogCallbackRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DialogCallbackRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ImageInfo

@implementation PB3ImageInfo

@dynamic id_p;
@dynamic width;
@dynamic height;
@dynamic isVideo;
@dynamic URL;
@dynamic status;

typedef struct PB3ImageInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
  PB3AuditStatus status;
  NSString *URL;
  int64_t id_p;
} PB3ImageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ImageInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfo_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ImageInfo__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfo_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ImageInfo__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isVideo",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfo_FieldNumber_IsVideo,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfo_FieldNumber_URL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ImageInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3AuditStatus_EnumDescriptor,
        .number = PB3ImageInfo_FieldNumber_Status,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ImageInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImageInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ImageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ImageInfo_Status_RawValue(PB3ImageInfo *message) {
  GPBDescriptor *descriptor = [PB3ImageInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ImageInfo_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ImageInfo_Status_RawValue(PB3ImageInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ImageInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ImageInfo_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ImageInfoList

@implementation PB3ImageInfoList

@dynamic picsArray, picsArray_Count;

typedef struct PB3ImageInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *picsArray;
} PB3ImageInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "picsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ImageInfo),
        .number = PB3ImageInfoList_FieldNumber_PicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ImageInfoList__storage_, picsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImageInfoList class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ImageInfoList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ImageInfoListReq

@implementation PB3ImageInfoListReq

@dynamic playerId;

typedef struct PB3ImageInfoListReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3ImageInfoListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImageInfoListReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ImageInfoListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImageInfoListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ImageInfoListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ImageInfoListRes

@implementation PB3ImageInfoListRes

@dynamic hasImageInfoList, imageInfoList;

typedef struct PB3ImageInfoListRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ImageInfoList *imageInfoList;
} PB3ImageInfoListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageInfoList",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ImageInfoList),
        .number = PB3ImageInfoListRes_FieldNumber_ImageInfoList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ImageInfoListRes__storage_, imageInfoList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImageInfoListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ImageInfoListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YunpianSmsCodeReq

@implementation PB3YunpianSmsCodeReq

@dynamic phone;
@dynamic country;

typedef struct PB3YunpianSmsCodeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
  NSString *country;
} PB3YunpianSmsCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3YunpianSmsCodeReq_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YunpianSmsCodeReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3YunpianSmsCodeReq_FieldNumber_Country,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YunpianSmsCodeReq__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YunpianSmsCodeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YunpianSmsCodeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YunpianSmsCodeRes

@implementation PB3YunpianSmsCodeRes

@dynamic code;
@dynamic msg;

typedef struct PB3YunpianSmsCodeRes__storage_ {
  uint32_t _has_storage_[1];
  PB3SmsCode code;
  NSString *msg;
} PB3YunpianSmsCodeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = PB3SmsCode_EnumDescriptor,
        .number = PB3YunpianSmsCodeRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YunpianSmsCodeRes__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3YunpianSmsCodeRes_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YunpianSmsCodeRes__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YunpianSmsCodeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YunpianSmsCodeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YunpianSmsCodeRes_Code_RawValue(PB3YunpianSmsCodeRes *message) {
  GPBDescriptor *descriptor = [PB3YunpianSmsCodeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YunpianSmsCodeRes_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YunpianSmsCodeRes_Code_RawValue(PB3YunpianSmsCodeRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YunpianSmsCodeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YunpianSmsCodeRes_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3DeleteAccountCheckReq

@implementation PB3DeleteAccountCheckReq


typedef struct PB3DeleteAccountCheckReq__storage_ {
  uint32_t _has_storage_[1];
} PB3DeleteAccountCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountCheckReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DeleteAccountCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteAccountCheckRes

@implementation PB3DeleteAccountCheckRes

@dynamic accountSafe;
@dynamic accountBan;
@dynamic moneyEmpty;

typedef struct PB3DeleteAccountCheckRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DeleteAccountCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountSafe",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountCheckRes_FieldNumber_AccountSafe,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "accountBan",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountCheckRes_FieldNumber_AccountBan,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "moneyEmpty",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountCheckRes_FieldNumber_MoneyEmpty,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountCheckRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteAccountCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteAccountReq

@implementation PB3DeleteAccountReq


typedef struct PB3DeleteAccountReq__storage_ {
  uint32_t _has_storage_[1];
} PB3DeleteAccountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DeleteAccountReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteAccountRes

@implementation PB3DeleteAccountRes

@dynamic phone;

typedef struct PB3DeleteAccountRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
} PB3DeleteAccountRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountRes_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeleteAccountRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteAccountRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteAccountConfirmReq

@implementation PB3DeleteAccountConfirmReq

@dynamic code;

typedef struct PB3DeleteAccountConfirmReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} PB3DeleteAccountConfirmReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountConfirmReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeleteAccountConfirmReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountConfirmReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteAccountConfirmReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteAccountConfirmRes

@implementation PB3DeleteAccountConfirmRes

@dynamic keepDays;

typedef struct PB3DeleteAccountConfirmRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t keepDays;
} PB3DeleteAccountConfirmRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keepDays",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteAccountConfirmRes_FieldNumber_KeepDays,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeleteAccountConfirmRes__storage_, keepDays),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteAccountConfirmRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteAccountConfirmRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitNumReq

@implementation PB3VisitNumReq

@dynamic ownerId;

typedef struct PB3VisitNumReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t ownerId;
} PB3VisitNumReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitNumReq_FieldNumber_OwnerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitNumReq__storage_, ownerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitNumReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitNumReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitNumRes

@implementation PB3VisitNumRes

@dynamic totalVisitNum;
@dynamic addNum;

typedef struct PB3VisitNumRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalVisitNum;
  int64_t addNum;
} PB3VisitNumRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalVisitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitNumRes_FieldNumber_TotalVisitNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitNumRes__storage_, totalVisitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "addNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitNumRes_FieldNumber_AddNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VisitNumRes__storage_, addNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitNumRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitNumRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorStatReq

@implementation PB3VisitorStatReq


typedef struct PB3VisitorStatReq__storage_ {
  uint32_t _has_storage_[1];
} PB3VisitorStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorStatReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3VisitorStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorStatRes

@implementation PB3VisitorStatRes

@dynamic totalVisitNum;
@dynamic addNum;
@dynamic todayVisitor;
@dynamic todayVisitNum;

typedef struct PB3VisitorStatRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalVisitNum;
  int64_t addNum;
  int64_t todayVisitor;
  int64_t todayVisitNum;
} PB3VisitorStatRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalVisitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorStatRes_FieldNumber_TotalVisitNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitorStatRes__storage_, totalVisitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "addNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorStatRes_FieldNumber_AddNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VisitorStatRes__storage_, addNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "todayVisitor",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorStatRes_FieldNumber_TodayVisitor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VisitorStatRes__storage_, todayVisitor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "todayVisitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorStatRes_FieldNumber_TodayVisitNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3VisitorStatRes__storage_, todayVisitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorStatRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorStatRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorListReq

@implementation PB3VisitorListReq

@dynamic ownerId;
@dynamic page;

typedef struct PB3VisitorListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int64_t ownerId;
} PB3VisitorListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorListReq_FieldNumber_OwnerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitorListReq__storage_, ownerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorListReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VisitorListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorListRes

@implementation PB3VisitorListRes

@dynamic visitorInfoArray, visitorInfoArray_Count;

typedef struct PB3VisitorListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *visitorInfoArray;
} PB3VisitorListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visitorInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VisitorInfo),
        .number = PB3VisitorListRes_FieldNumber_VisitorInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VisitorListRes__storage_, visitorInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MyVisitListReq

@implementation PB3MyVisitListReq

@dynamic page;

typedef struct PB3MyVisitListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
} PB3MyVisitListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3MyVisitListReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MyVisitListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MyVisitListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MyVisitListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MyVisitListRes

@implementation PB3MyVisitListRes

@dynamic visitorInfoArray, visitorInfoArray_Count;

typedef struct PB3MyVisitListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *visitorInfoArray;
} PB3MyVisitListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visitorInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VisitorInfo),
        .number = PB3MyVisitListRes_FieldNumber_VisitorInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MyVisitListRes__storage_, visitorInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MyVisitListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MyVisitListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorOptReq

@implementation PB3VisitorOptReq

@dynamic ownId;
@dynamic id_p;
@dynamic optType;
@dynamic page;
@dynamic visitorId;

typedef struct PB3VisitorOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB3VisitorOptType optType;
  int32_t page;
  int64_t ownId;
  int64_t id_p;
  int64_t visitorId;
} PB3VisitorOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptReq_FieldNumber_OwnId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitorOptReq__storage_, ownId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptReq_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VisitorOptReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "optType",
        .dataTypeSpecific.enumDescFunc = PB3VisitorOptType_EnumDescriptor,
        .number = PB3VisitorOptReq_FieldNumber_OptType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VisitorOptReq__storage_, optType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptReq_FieldNumber_Page,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3VisitorOptReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "visitorId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptReq_FieldNumber_VisitorId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3VisitorOptReq__storage_, visitorId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorOptReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3VisitorOptReq_OptType_RawValue(PB3VisitorOptReq *message) {
  GPBDescriptor *descriptor = [PB3VisitorOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptReq_FieldNumber_OptType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3VisitorOptReq_OptType_RawValue(PB3VisitorOptReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3VisitorOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptReq_FieldNumber_OptType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3VisitorOptRes

@implementation PB3VisitorOptRes

@dynamic code;

typedef struct PB3VisitorOptRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} PB3VisitorOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitorOptRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorOptRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorOptLimitReq

@implementation PB3VisitorOptLimitReq


typedef struct PB3VisitorOptLimitReq__storage_ {
  uint32_t _has_storage_[1];
} PB3VisitorOptLimitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorOptLimitReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3VisitorOptLimitReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VisitorOptLimitRes

@implementation PB3VisitorOptLimitRes

@dynamic hideLimitType;
@dynamic hideLimitLv;
@dynamic invisible;
@dynamic invisibleLimitLv;
@dynamic hideDescribe;
@dynamic invisibleDescribe;

typedef struct PB3VisitorOptLimitRes__storage_ {
  uint32_t _has_storage_[1];
  PB3VisitorOptLimitType hideLimitType;
  int32_t hideLimitLv;
  PB3VisitorOptLimitType invisible;
  int32_t invisibleLimitLv;
  NSString *hideDescribe;
  NSString *invisibleDescribe;
} PB3VisitorOptLimitRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hideLimitType",
        .dataTypeSpecific.enumDescFunc = PB3VisitorOptLimitType_EnumDescriptor,
        .number = PB3VisitorOptLimitRes_FieldNumber_HideLimitType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, hideLimitType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "hideLimitLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptLimitRes_FieldNumber_HideLimitLv,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, hideLimitLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "invisible",
        .dataTypeSpecific.enumDescFunc = PB3VisitorOptLimitType_EnumDescriptor,
        .number = PB3VisitorOptLimitRes_FieldNumber_Invisible,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, invisible),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "invisibleLimitLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptLimitRes_FieldNumber_InvisibleLimitLv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, invisibleLimitLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hideDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptLimitRes_FieldNumber_HideDescribe,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, hideDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "invisibleDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB3VisitorOptLimitRes_FieldNumber_InvisibleDescribe,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3VisitorOptLimitRes__storage_, invisibleDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VisitorOptLimitRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VisitorOptLimitRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3VisitorOptLimitRes_HideLimitType_RawValue(PB3VisitorOptLimitRes *message) {
  GPBDescriptor *descriptor = [PB3VisitorOptLimitRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptLimitRes_FieldNumber_HideLimitType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3VisitorOptLimitRes_HideLimitType_RawValue(PB3VisitorOptLimitRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3VisitorOptLimitRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptLimitRes_FieldNumber_HideLimitType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3VisitorOptLimitRes_Invisible_RawValue(PB3VisitorOptLimitRes *message) {
  GPBDescriptor *descriptor = [PB3VisitorOptLimitRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptLimitRes_FieldNumber_Invisible];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3VisitorOptLimitRes_Invisible_RawValue(PB3VisitorOptLimitRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3VisitorOptLimitRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VisitorOptLimitRes_FieldNumber_Invisible];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IsChargeToday

@implementation PB3IsChargeToday

@dynamic isCharge;
@dynamic giftIcon;

typedef struct PB3IsChargeToday__storage_ {
  uint32_t _has_storage_[1];
  int32_t isCharge;
  int32_t giftIcon;
} PB3IsChargeToday__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isCharge",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsChargeToday_FieldNumber_IsCharge,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IsChargeToday__storage_, isCharge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsChargeToday_FieldNumber_GiftIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IsChargeToday__storage_, giftIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IsChargeToday class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IsChargeToday__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSimplePlayerReq

@implementation PB3GetSimplePlayerReq

@dynamic playerId;

typedef struct PB3GetSimplePlayerReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetSimplePlayerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetSimplePlayerReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSimplePlayerReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSimplePlayerReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSimplePlayerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSimplePlayerRes

@implementation PB3GetSimplePlayerRes

@dynamic hasPlayer, player;
@dynamic riskType;

typedef struct PB3GetSimplePlayerRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RiskType riskType;
  PB3SimplePlayer *player;
} PB3GetSimplePlayerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3GetSimplePlayerRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSimplePlayerRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "riskType",
        .dataTypeSpecific.enumDescFunc = PB3RiskType_EnumDescriptor,
        .number = PB3GetSimplePlayerRes_FieldNumber_RiskType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetSimplePlayerRes__storage_, riskType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSimplePlayerRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSimplePlayerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetSimplePlayerRes_RiskType_RawValue(PB3GetSimplePlayerRes *message) {
  GPBDescriptor *descriptor = [PB3GetSimplePlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetSimplePlayerRes_FieldNumber_RiskType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetSimplePlayerRes_RiskType_RawValue(PB3GetSimplePlayerRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetSimplePlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetSimplePlayerRes_FieldNumber_RiskType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UresOssCallbackReq

@implementation PB3UresOssCallbackReq

@dynamic type;

typedef struct PB3UresOssCallbackReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType type;
} PB3UresOssCallbackReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3UresOssCallbackReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UresOssCallbackReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UresOssCallbackReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UresOssCallbackReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UresOssCallbackReq_Type_RawValue(PB3UresOssCallbackReq *message) {
  GPBDescriptor *descriptor = [PB3UresOssCallbackReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UresOssCallbackReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UresOssCallbackReq_Type_RawValue(PB3UresOssCallbackReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UresOssCallbackReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UresOssCallbackReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UresOssCallbackRes

@implementation PB3UresOssCallbackRes


typedef struct PB3UresOssCallbackRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UresOssCallbackRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UresOssCallbackRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UresOssCallbackRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaveOssImageListReq

@implementation PB3SaveOssImageListReq

@dynamic type;
@dynamic URLArray, URLArray_Count;
@dynamic voiceTime;
@dynamic voiceTagId;
@dynamic voiceTagNum;
@dynamic voiceStyleId;
@dynamic voiceStyleNum;
@dynamic charTagsArray, charTagsArray_Count;

typedef struct PB3SaveOssImageListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType type;
  int32_t voiceTime;
  int32_t voiceTagId;
  int32_t voiceTagNum;
  int32_t voiceStyleId;
  int32_t voiceStyleNum;
  NSMutableArray *URLArray;
  NSMutableArray *charTagsArray;
} PB3SaveOssImageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3SaveOssImageListReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "URLArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_URLArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, URLArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_VoiceTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceTagId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_VoiceTagId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, voiceTagId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceTagNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_VoiceTagNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, voiceTagNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStyleId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_VoiceStyleId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, voiceStyleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStyleNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_VoiceStyleNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, voiceStyleNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charTagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveOssImageListReq_FieldNumber_CharTagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaveOssImageListReq__storage_, charTagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaveOssImageListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaveOssImageListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000url\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SaveOssImageListReq_Type_RawValue(PB3SaveOssImageListReq *message) {
  GPBDescriptor *descriptor = [PB3SaveOssImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SaveOssImageListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SaveOssImageListReq_Type_RawValue(PB3SaveOssImageListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SaveOssImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SaveOssImageListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SaveOssImageListRes

@implementation PB3SaveOssImageListRes


typedef struct PB3SaveOssImageListRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SaveOssImageListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaveOssImageListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SaveOssImageListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteOssImageListReq

@implementation PB3DeleteOssImageListReq

@dynamic id_p;
@dynamic type;
@dynamic URL;

typedef struct PB3DeleteOssImageListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType type;
  NSString *URL;
  int64_t id_p;
} PB3DeleteOssImageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteOssImageListReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeleteOssImageListReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3DeleteOssImageListReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DeleteOssImageListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteOssImageListReq_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3DeleteOssImageListReq__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteOssImageListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteOssImageListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3DeleteOssImageListReq_Type_RawValue(PB3DeleteOssImageListReq *message) {
  GPBDescriptor *descriptor = [PB3DeleteOssImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DeleteOssImageListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3DeleteOssImageListReq_Type_RawValue(PB3DeleteOssImageListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3DeleteOssImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DeleteOssImageListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3DeleteOssImageListRes

@implementation PB3DeleteOssImageListRes


typedef struct PB3DeleteOssImageListRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DeleteOssImageListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteOssImageListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DeleteOssImageListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NewVersionContent

@implementation PB3NewVersionContent

@dynamic contentsArray, contentsArray_Count;
@dynamic title;

typedef struct PB3NewVersionContent__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *contentsArray;
  NSString *title;
} PB3NewVersionContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3NewVersionContent_FieldNumber_ContentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3NewVersionContent__storage_, contentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3NewVersionContent_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NewVersionContent__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NewVersionContent class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NewVersionContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CountdownStart

@implementation PB3CountdownStart


typedef struct PB3CountdownStart__storage_ {
  uint32_t _has_storage_[1];
} PB3CountdownStart__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CountdownStart class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CountdownStart__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PrivacySettingReq

@implementation PB3PrivacySettingReq


typedef struct PB3PrivacySettingReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PrivacySettingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PrivacySettingReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PrivacySettingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PrivacySettingRes

@implementation PB3PrivacySettingRes

@dynamic onOffListArray, onOffListArray_Count;
@dynamic incognitoDescribe;

typedef struct PB3PrivacySettingRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *onOffListArray;
  NSString *incognitoDescribe;
} PB3PrivacySettingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOffListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PrivacyTypeVal),
        .number = PB3PrivacySettingRes_FieldNumber_OnOffListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PrivacySettingRes__storage_, onOffListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "incognitoDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB3PrivacySettingRes_FieldNumber_IncognitoDescribe,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PrivacySettingRes__storage_, incognitoDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PrivacySettingRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PrivacySettingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangePrivacyReq

@implementation PB3ChangePrivacyReq

@dynamic hasOnOff, onOff;

typedef struct PB3ChangePrivacyReq__storage_ {
  uint32_t _has_storage_[1];
  PB3PrivacyTypeVal *onOff;
} PB3ChangePrivacyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOff",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PrivacyTypeVal),
        .number = PB3ChangePrivacyReq_FieldNumber_OnOff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangePrivacyReq__storage_, onOff),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangePrivacyReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangePrivacyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChangePrivacyRes

@implementation PB3ChangePrivacyRes

@dynamic hasOnOff, onOff;

typedef struct PB3ChangePrivacyRes__storage_ {
  uint32_t _has_storage_[1];
  PB3PrivacyTypeVal *onOff;
} PB3ChangePrivacyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOff",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PrivacyTypeVal),
        .number = PB3ChangePrivacyRes_FieldNumber_OnOff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChangePrivacyRes__storage_, onOff),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChangePrivacyRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChangePrivacyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetNoAuthBeforeLoginReq

@implementation PB3GetNoAuthBeforeLoginReq

@dynamic device;
@dynamic version;
@dynamic deviceId;

typedef struct PB3GetNoAuthBeforeLoginReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType device;
  NSString *version;
  NSString *deviceId;
} PB3GetNoAuthBeforeLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "device",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3GetNoAuthBeforeLoginReq_FieldNumber_Device,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetNoAuthBeforeLoginReq__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetNoAuthBeforeLoginReq_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetNoAuthBeforeLoginReq__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetNoAuthBeforeLoginReq_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetNoAuthBeforeLoginReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetNoAuthBeforeLoginReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetNoAuthBeforeLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetNoAuthBeforeLoginReq_Device_RawValue(PB3GetNoAuthBeforeLoginReq *message) {
  GPBDescriptor *descriptor = [PB3GetNoAuthBeforeLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetNoAuthBeforeLoginReq_FieldNumber_Device];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetNoAuthBeforeLoginReq_Device_RawValue(PB3GetNoAuthBeforeLoginReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetNoAuthBeforeLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetNoAuthBeforeLoginReq_FieldNumber_Device];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetNoAuthBeforeLoginRes

@implementation PB3GetNoAuthBeforeLoginRes

@dynamic listArray, listArray_Count;

typedef struct PB3GetNoAuthBeforeLoginRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3GetNoAuthBeforeLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3OnOffStatus),
        .number = PB3GetNoAuthBeforeLoginRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetNoAuthBeforeLoginRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetNoAuthBeforeLoginRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetNoAuthBeforeLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BankInfoReq

@implementation PB3BankInfoReq

@dynamic isIos;

typedef struct PB3BankInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3BankInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isIos",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoReq_FieldNumber_IsIos,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BankInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BankInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BankInfoRes

@implementation PB3BankInfoRes

@dynamic cardNum;
@dynamic mayuncount;
@dynamic userName;
@dynamic identityCode;
@dynamic bankName;
@dynamic subName;
@dynamic phone;
@dynamic isAgreement;
@dynamic agreementAt;

typedef struct PB3BankInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *cardNum;
  NSString *mayuncount;
  NSString *userName;
  NSString *identityCode;
  NSString *bankName;
  NSString *subName;
  NSString *phone;
  int64_t agreementAt;
} PB3BankInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_CardNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, cardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mayuncount",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_Mayuncount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, mayuncount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_IdentityCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, identityCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_BankName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, bankName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_SubName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, subName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_Phone,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAgreement",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_IsAgreement,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "agreementAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfoRes_FieldNumber_AgreementAt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3BankInfoRes__storage_, agreementAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BankInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BankInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NewBankInfoReq

@implementation PB3NewBankInfoReq


typedef struct PB3NewBankInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3NewBankInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NewBankInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3NewBankInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NewBankInfoRes

@implementation PB3NewBankInfoRes

@dynamic hasBankInfo, bankInfo;
@dynamic hasFreelanceInfo, freelanceInfo;

typedef struct PB3NewBankInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3BankInfo *bankInfo;
  PB3FreelanceInfo *freelanceInfo;
} PB3NewBankInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bankInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BankInfo),
        .number = PB3NewBankInfoRes_FieldNumber_BankInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NewBankInfoRes__storage_, bankInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "freelanceInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3FreelanceInfo),
        .number = PB3NewBankInfoRes_FieldNumber_FreelanceInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3NewBankInfoRes__storage_, freelanceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NewBankInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NewBankInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BankInfo

@implementation PB3BankInfo

@dynamic playerId;
@dynamic payType;
@dynamic idCardNo;
@dynamic permanentAddress;
@dynamic bankName;
@dynamic subBankName;
@dynamic bankCode;
@dynamic swift;
@dynamic bankCardNo;
@dynamic contact;
@dynamic payAccount;
@dynamic name;
@dynamic subName;
@dynamic country;
@dynamic isDefault;
@dynamic postalCode;
@dynamic idCardState;
@dynamic idCardFront;
@dynamic idCardSide;
@dynamic autograph;
@dynamic agreement;
@dynamic auditExplain;
@dynamic street;
@dynamic province;
@dynamic city;
@dynamic alias;
@dynamic subBankCode;

typedef struct PB3BankInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t playerId;
  uint32_t payType;
  int32_t idCardState;
  NSString *idCardNo;
  NSString *permanentAddress;
  NSString *bankName;
  NSString *subBankName;
  NSString *bankCode;
  NSString *swift;
  NSString *bankCardNo;
  NSString *contact;
  NSString *payAccount;
  NSString *name;
  NSString *subName;
  NSString *country;
  NSString *postalCode;
  NSString *idCardFront;
  NSString *idCardSide;
  NSString *autograph;
  NSString *agreement;
  NSString *auditExplain;
  NSString *street;
  NSString *province;
  NSString *city;
  NSString *alias;
  NSString *subBankCode;
} PB3BankInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_PayType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, payType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "idCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_IdCardNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, idCardNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permanentAddress",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_PermanentAddress,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, permanentAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_BankName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, bankName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subBankName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_SubBankName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, subBankName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_BankCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, bankCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "swift",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Swift,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, swift),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bankCardNo",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_BankCardNo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, bankCardNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contact",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Contact,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, contact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payAccount",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_PayAccount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, payAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Name,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_SubName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, subName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Country,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_IsDefault,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "postalCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_PostalCode,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, postalCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idCardState",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_IdCardState,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, idCardState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idCardFront",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_IdCardFront,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, idCardFront),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idCardSide",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_IdCardSide,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, idCardSide),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autograph",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Autograph,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, autograph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agreement",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Agreement,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, agreement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "auditExplain",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_AuditExplain,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, auditExplain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "street",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Street,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, street),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Province,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_City,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_Alias,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subBankCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3BankInfo_FieldNumber_SubBankCode,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB3BankInfo__storage_, subBankCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BankInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BankInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003b\244\242\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FreelanceInfo

@implementation PB3FreelanceInfo

@dynamic playerId;
@dynamic autograph;
@dynamic agreement;
@dynamic signTime;

typedef struct PB3FreelanceInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *autograph;
  NSString *agreement;
  int64_t playerId;
  int64_t signTime;
} PB3FreelanceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FreelanceInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FreelanceInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "autograph",
        .dataTypeSpecific.className = NULL,
        .number = PB3FreelanceInfo_FieldNumber_Autograph,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FreelanceInfo__storage_, autograph),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agreement",
        .dataTypeSpecific.className = NULL,
        .number = PB3FreelanceInfo_FieldNumber_Agreement,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FreelanceInfo__storage_, agreement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FreelanceInfo_FieldNumber_SignTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FreelanceInfo__storage_, signTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FreelanceInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FreelanceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TypeImageListReq

@implementation PB3TypeImageListReq

@dynamic playerId;
@dynamic type;

typedef struct PB3TypeImageListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType type;
  int64_t playerId;
} PB3TypeImageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TypeImageListReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TypeImageListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3TypeImageListReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TypeImageListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TypeImageListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TypeImageListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TypeImageListReq_Type_RawValue(PB3TypeImageListReq *message) {
  GPBDescriptor *descriptor = [PB3TypeImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TypeImageListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TypeImageListReq_Type_RawValue(PB3TypeImageListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TypeImageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TypeImageListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TypeImageListRes

@implementation PB3TypeImageListRes

@dynamic picsArray, picsArray_Count;
@dynamic type;

typedef struct PB3TypeImageListRes__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType type;
  NSMutableArray *picsArray;
} PB3TypeImageListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "picsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ImageInfo),
        .number = PB3TypeImageListRes_FieldNumber_PicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TypeImageListRes__storage_, picsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3TypeImageListRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TypeImageListRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TypeImageListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TypeImageListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TypeImageListRes_Type_RawValue(PB3TypeImageListRes *message) {
  GPBDescriptor *descriptor = [PB3TypeImageListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TypeImageListRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TypeImageListRes_Type_RawValue(PB3TypeImageListRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TypeImageListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TypeImageListRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClearMsgRedReq

@implementation PB3ClearMsgRedReq

@dynamic msgType;

typedef struct PB3ClearMsgRedReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ClearMsgRedType msgType;
} PB3ClearMsgRedReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgType",
        .dataTypeSpecific.enumDescFunc = PB3ClearMsgRedType_EnumDescriptor,
        .number = PB3ClearMsgRedReq_FieldNumber_MsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClearMsgRedReq__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearMsgRedReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClearMsgRedReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClearMsgRedReq_MsgType_RawValue(PB3ClearMsgRedReq *message) {
  GPBDescriptor *descriptor = [PB3ClearMsgRedReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClearMsgRedReq_FieldNumber_MsgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClearMsgRedReq_MsgType_RawValue(PB3ClearMsgRedReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClearMsgRedReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClearMsgRedReq_FieldNumber_MsgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClearMsgRedRes

@implementation PB3ClearMsgRedRes


typedef struct PB3ClearMsgRedRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClearMsgRedRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearMsgRedRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClearMsgRedRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DynamicIconLevConfReq

@implementation PB3DynamicIconLevConfReq


typedef struct PB3DynamicIconLevConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3DynamicIconLevConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DynamicIconLevConfReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DynamicIconLevConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DynamicIconLevConfRes

@implementation PB3DynamicIconLevConfRes

@dynamic charmLevel;
@dynamic wealthLevel;
@dynamic logic;
@dynamic desc;

typedef struct PB3DynamicIconLevConfRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  int32_t wealthLevel;
  int32_t logic;
  NSString *desc;
} PB3DynamicIconLevConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3DynamicIconLevConfRes_FieldNumber_CharmLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DynamicIconLevConfRes__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3DynamicIconLevConfRes_FieldNumber_WealthLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DynamicIconLevConfRes__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "logic",
        .dataTypeSpecific.className = NULL,
        .number = PB3DynamicIconLevConfRes_FieldNumber_Logic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3DynamicIconLevConfRes__storage_, logic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3DynamicIconLevConfRes_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3DynamicIconLevConfRes__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DynamicIconLevConfRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DynamicIconLevConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeChatBindListReq

@implementation PB3WeChatBindListReq

@dynamic unionId;
@dynamic openId;
@dynamic appId;
@dynamic loginType;

typedef struct PB3WeChatBindListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeChatLogin loginType;
  NSString *unionId;
  NSString *openId;
  NSString *appId;
} PB3WeChatBindListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindListReq_FieldNumber_UnionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeChatBindListReq__storage_, unionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindListReq_FieldNumber_OpenId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeChatBindListReq__storage_, openId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindListReq_FieldNumber_AppId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeChatBindListReq__storage_, appId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginType",
        .dataTypeSpecific.enumDescFunc = PB3WeChatLogin_EnumDescriptor,
        .number = PB3WeChatBindListReq_FieldNumber_LoginType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeChatBindListReq__storage_, loginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeChatBindListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeChatBindListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeChatBindListReq_LoginType_RawValue(PB3WeChatBindListReq *message) {
  GPBDescriptor *descriptor = [PB3WeChatBindListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeChatBindListReq_FieldNumber_LoginType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeChatBindListReq_LoginType_RawValue(PB3WeChatBindListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeChatBindListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeChatBindListReq_FieldNumber_LoginType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeChatBindListRes

@implementation PB3WeChatBindListRes

@dynamic status;
@dynamic bindListArray, bindListArray_Count;

typedef struct PB3WeChatBindListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bindListArray;
} PB3WeChatBindListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindListRes_FieldNumber_Status,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bindListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeChatBind),
        .number = PB3WeChatBindListRes_FieldNumber_BindListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeChatBindListRes__storage_, bindListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeChatBindListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeChatBindListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeChatBind

@implementation PB3WeChatBind

@dynamic playerId;
@dynamic name;
@dynamic icon;

typedef struct PB3WeChatBind__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *icon;
  int64_t playerId;
} PB3WeChatBind__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBind_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeChatBind__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBind_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeChatBind__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBind_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeChatBind__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeChatBind class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeChatBind__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeChatBindIdReq

@implementation PB3WeChatBindIdReq

@dynamic unionId;
@dynamic openId;
@dynamic appId;
@dynamic playerId;

typedef struct PB3WeChatBindIdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *unionId;
  NSString *openId;
  NSString *appId;
  int64_t playerId;
} PB3WeChatBindIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindIdReq_FieldNumber_UnionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeChatBindIdReq__storage_, unionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindIdReq_FieldNumber_OpenId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeChatBindIdReq__storage_, openId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindIdReq_FieldNumber_AppId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeChatBindIdReq__storage_, appId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindIdReq_FieldNumber_PlayerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeChatBindIdReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeChatBindIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeChatBindIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeChatBindIdRes

@implementation PB3WeChatBindIdRes

@dynamic token;

typedef struct PB3WeChatBindIdRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} PB3WeChatBindIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeChatBindIdRes_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeChatBindIdRes__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeChatBindIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeChatBindIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CancelWeChatBindIdReq

@implementation PB3CancelWeChatBindIdReq


typedef struct PB3CancelWeChatBindIdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CancelWeChatBindIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelWeChatBindIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CancelWeChatBindIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CancelWeChatBindIdRes

@implementation PB3CancelWeChatBindIdRes


typedef struct PB3CancelWeChatBindIdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CancelWeChatBindIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelWeChatBindIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CancelWeChatBindIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DelProfileVoiceReq

@implementation PB3DelProfileVoiceReq


typedef struct PB3DelProfileVoiceReq__storage_ {
  uint32_t _has_storage_[1];
} PB3DelProfileVoiceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DelProfileVoiceReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DelProfileVoiceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DelProfileVoiceRes

@implementation PB3DelProfileVoiceRes

@dynamic isVoiceTag;

typedef struct PB3DelProfileVoiceRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DelProfileVoiceRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isVoiceTag",
        .dataTypeSpecific.className = NULL,
        .number = PB3DelProfileVoiceRes_FieldNumber_IsVoiceTag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DelProfileVoiceRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DelProfileVoiceRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatBindInfoReq

@implementation PB3WechatBindInfoReq


typedef struct PB3WechatBindInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WechatBindInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatBindInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WechatBindInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatBindInfoRes

@implementation PB3WechatBindInfoRes

@dynamic playerId;
@dynamic name;
@dynamic isBillAuthority;
@dynamic icon;

typedef struct PB3WechatBindInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t isBillAuthority;
  NSString *name;
  NSString *icon;
  int64_t playerId;
} PB3WechatBindInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatBindInfoRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WechatBindInfoRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatBindInfoRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WechatBindInfoRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isBillAuthority",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatBindInfoRes_FieldNumber_IsBillAuthority,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WechatBindInfoRes__storage_, isBillAuthority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatBindInfoRes_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WechatBindInfoRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatBindInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatBindInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetWeChatSubLoginReq

@implementation PB3GetWeChatSubLoginReq

@dynamic phone;
@dynamic smsCode;

typedef struct PB3GetWeChatSubLoginReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
  NSString *smsCode;
} PB3GetWeChatSubLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetWeChatSubLoginReq_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetWeChatSubLoginReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetWeChatSubLoginReq_FieldNumber_SmsCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetWeChatSubLoginReq__storage_, smsCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetWeChatSubLoginReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetWeChatSubLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetWeChatSubLoginRes

@implementation PB3GetWeChatSubLoginRes

@dynamic token;

typedef struct PB3GetWeChatSubLoginRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} PB3GetWeChatSubLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetWeChatSubLoginRes_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetWeChatSubLoginRes__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetWeChatSubLoginRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetWeChatSubLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthLevCfg

@implementation PB3AuthLevCfg

@dynamic level;
@dynamic name;
@dynamic URL;
@dynamic gainType;
@dynamic levExp;

typedef struct PB3AuthLevCfg__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  PB3AuthGainType gainType;
  NSString *name;
  NSString *URL;
  int64_t levExp;
} PB3AuthLevCfg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthLevCfg_FieldNumber_Level,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthLevCfg__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthLevCfg_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthLevCfg__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthLevCfg_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuthLevCfg__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gainType",
        .dataTypeSpecific.enumDescFunc = PB3AuthGainType_EnumDescriptor,
        .number = PB3AuthLevCfg_FieldNumber_GainType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AuthLevCfg__storage_, gainType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "levExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthLevCfg_FieldNumber_LevExp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AuthLevCfg__storage_, levExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthLevCfg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthLevCfg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuthLevCfg_GainType_RawValue(PB3AuthLevCfg *message) {
  GPBDescriptor *descriptor = [PB3AuthLevCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfg_FieldNumber_GainType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuthLevCfg_GainType_RawValue(PB3AuthLevCfg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuthLevCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfg_FieldNumber_GainType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuthLevCfgReq

@implementation PB3AuthLevCfgReq

@dynamic authType;

typedef struct PB3AuthLevCfgReq__storage_ {
  uint32_t _has_storage_[1];
  PB3AuthType authType;
} PB3AuthLevCfgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authType",
        .dataTypeSpecific.enumDescFunc = PB3AuthType_EnumDescriptor,
        .number = PB3AuthLevCfgReq_FieldNumber_AuthType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthLevCfgReq__storage_, authType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthLevCfgReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthLevCfgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuthLevCfgReq_AuthType_RawValue(PB3AuthLevCfgReq *message) {
  GPBDescriptor *descriptor = [PB3AuthLevCfgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfgReq_FieldNumber_AuthType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuthLevCfgReq_AuthType_RawValue(PB3AuthLevCfgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuthLevCfgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfgReq_FieldNumber_AuthType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuthLevCfgRes

@implementation PB3AuthLevCfgRes

@dynamic authType;
@dynamic authLevCfgArray, authLevCfgArray_Count;

typedef struct PB3AuthLevCfgRes__storage_ {
  uint32_t _has_storage_[1];
  PB3AuthType authType;
  NSMutableArray *authLevCfgArray;
} PB3AuthLevCfgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authType",
        .dataTypeSpecific.enumDescFunc = PB3AuthType_EnumDescriptor,
        .number = PB3AuthLevCfgRes_FieldNumber_AuthType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthLevCfgRes__storage_, authType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "authLevCfgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuthLevCfg),
        .number = PB3AuthLevCfgRes_FieldNumber_AuthLevCfgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuthLevCfgRes__storage_, authLevCfgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthLevCfgRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthLevCfgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuthLevCfgRes_AuthType_RawValue(PB3AuthLevCfgRes *message) {
  GPBDescriptor *descriptor = [PB3AuthLevCfgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfgRes_FieldNumber_AuthType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuthLevCfgRes_AuthType_RawValue(PB3AuthLevCfgRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuthLevCfgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthLevCfgRes_FieldNumber_AuthType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuthDelRes

@implementation PB3AuthDelRes

@dynamic authType;

typedef struct PB3AuthDelRes__storage_ {
  uint32_t _has_storage_[1];
  PB3AuthType authType;
} PB3AuthDelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authType",
        .dataTypeSpecific.enumDescFunc = PB3AuthType_EnumDescriptor,
        .number = PB3AuthDelRes_FieldNumber_AuthType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthDelRes__storage_, authType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthDelRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthDelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuthDelRes_AuthType_RawValue(PB3AuthDelRes *message) {
  GPBDescriptor *descriptor = [PB3AuthDelRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthDelRes_FieldNumber_AuthType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuthDelRes_AuthType_RawValue(PB3AuthDelRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuthDelRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthDelRes_FieldNumber_AuthType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuthClanReq

@implementation PB3AuthClanReq

@dynamic playerId;
@dynamic level;
@dynamic authType;
@dynamic isSet;

typedef struct PB3AuthClanReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  PB3AuthType authType;
  int64_t playerId;
} PB3AuthClanReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthClanReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthClanReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthClanReq_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthClanReq__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "authType",
        .dataTypeSpecific.enumDescFunc = PB3AuthType_EnumDescriptor,
        .number = PB3AuthClanReq_FieldNumber_AuthType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuthClanReq__storage_, authType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isSet",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthClanReq_FieldNumber_IsSet,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthClanReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthClanReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuthClanReq_AuthType_RawValue(PB3AuthClanReq *message) {
  GPBDescriptor *descriptor = [PB3AuthClanReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthClanReq_FieldNumber_AuthType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuthClanReq_AuthType_RawValue(PB3AuthClanReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuthClanReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuthClanReq_FieldNumber_AuthType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuthClanRes

@implementation PB3AuthClanRes

@dynamic playerId;
@dynamic hasAuthInfo, authInfo;

typedef struct PB3AuthClanRes__storage_ {
  uint32_t _has_storage_[1];
  PB3AuthInfo *authInfo;
  int64_t playerId;
} PB3AuthClanRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthClanRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthClanRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "authInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuthInfo),
        .number = PB3AuthClanRes_FieldNumber_AuthInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthClanRes__storage_, authInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthClanRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthClanRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagInfo

@implementation PB3VoiceTagInfo

@dynamic voiceTagId;
@dynamic voiceTagText;
@dynamic voiceTagNum;
@dynamic voiceStyleId;
@dynamic voiceStyleText;
@dynamic voiceStyleNum;
@dynamic charTagsArray, charTagsArray_Count;
@dynamic voiceURL;
@dynamic voiceTime;

typedef struct PB3VoiceTagInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t voiceTagId;
  int32_t voiceTagNum;
  int32_t voiceStyleId;
  int32_t voiceStyleNum;
  int32_t voiceTime;
  NSString *voiceTagText;
  NSString *voiceStyleText;
  NSMutableArray *charTagsArray;
  NSString *voiceURL;
} PB3VoiceTagInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceTagId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceTagId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceTagId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceTagText",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceTagText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceTagText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTagNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceTagNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceTagNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStyleId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceStyleId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceStyleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStyleText",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceStyleText,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceStyleText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceStyleNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceStyleNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceStyleNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charTagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_CharTagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, charTagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfo_FieldNumber_VoiceTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfo__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagInfoReq

@implementation PB3VoiceTagInfoReq


typedef struct PB3VoiceTagInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3VoiceTagInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3VoiceTagInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagInfoRes

@implementation PB3VoiceTagInfoRes

@dynamic hasVoiceTag, voiceTag;
@dynamic signature;
@dynamic voiceTagCfgArray, voiceTagCfgArray_Count;
@dynamic voiceStyleCfgArray, voiceStyleCfgArray_Count;

typedef struct PB3VoiceTagInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3VoiceTagInfo *voiceTag;
  NSString *signature;
  NSMutableArray *voiceTagCfgArray;
  NSMutableArray *voiceStyleCfgArray;
} PB3VoiceTagInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceTag",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagInfo),
        .number = PB3VoiceTagInfoRes_FieldNumber_VoiceTag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfoRes__storage_, voiceTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagInfoRes_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfoRes__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTagCfgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagCfg),
        .number = PB3VoiceTagInfoRes_FieldNumber_VoiceTagCfgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfoRes__storage_, voiceTagCfgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceStyleCfgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceStyleCfg),
        .number = PB3VoiceTagInfoRes_FieldNumber_VoiceStyleCfgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagInfoRes__storage_, voiceStyleCfgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagPlayerInfoReq

@implementation PB3VoiceTagPlayerInfoReq

@dynamic playerId;

typedef struct PB3VoiceTagPlayerInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3VoiceTagPlayerInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagPlayerInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagPlayerInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagPlayerInfoRes

@implementation PB3VoiceTagPlayerInfoRes

@dynamic playerId;
@dynamic nickName;
@dynamic signature;
@dynamic hasVoiceTag, voiceTag;
@dynamic icon;
@dynamic shortId;
@dynamic sex;

typedef struct PB3VoiceTagPlayerInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  NSString *nickName;
  NSString *signature;
  PB3VoiceTagInfo *voiceTag;
  NSString *icon;
  int64_t playerId;
  int64_t shortId;
} PB3VoiceTagPlayerInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_Signature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTag",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagInfo),
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_VoiceTag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, voiceTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shortId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_ShortId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, shortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3VoiceTagPlayerInfoRes_FieldNumber_Sex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3VoiceTagPlayerInfoRes__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagPlayerInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagPlayerInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3VoiceTagPlayerInfoRes_Sex_RawValue(PB3VoiceTagPlayerInfoRes *message) {
  GPBDescriptor *descriptor = [PB3VoiceTagPlayerInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VoiceTagPlayerInfoRes_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3VoiceTagPlayerInfoRes_Sex_RawValue(PB3VoiceTagPlayerInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3VoiceTagPlayerInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VoiceTagPlayerInfoRes_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3VoiceTagCfgList

@implementation PB3VoiceTagCfgList

@dynamic gender;
@dynamic voiceTagCfgArray, voiceTagCfgArray_Count;

typedef struct PB3VoiceTagCfgList__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType gender;
  NSMutableArray *voiceTagCfgArray;
} PB3VoiceTagCfgList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gender",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3VoiceTagCfgList_FieldNumber_Gender,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagCfgList__storage_, gender),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "voiceTagCfgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagCfg),
        .number = PB3VoiceTagCfgList_FieldNumber_VoiceTagCfgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagCfgList__storage_, voiceTagCfgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagCfgList class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagCfgList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3VoiceTagCfgList_Gender_RawValue(PB3VoiceTagCfgList *message) {
  GPBDescriptor *descriptor = [PB3VoiceTagCfgList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VoiceTagCfgList_FieldNumber_Gender];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3VoiceTagCfgList_Gender_RawValue(PB3VoiceTagCfgList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3VoiceTagCfgList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3VoiceTagCfgList_FieldNumber_Gender];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3VoiceTagCfg

@implementation PB3VoiceTagCfg

@dynamic voiceTagId;
@dynamic voiceTagText;

typedef struct PB3VoiceTagCfg__storage_ {
  uint32_t _has_storage_[1];
  int32_t voiceTagId;
  NSString *voiceTagText;
} PB3VoiceTagCfg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceTagId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagCfg_FieldNumber_VoiceTagId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceTagCfg__storage_, voiceTagId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceTagText",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceTagCfg_FieldNumber_VoiceTagText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VoiceTagCfg__storage_, voiceTagText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagCfg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagCfg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceStyleCfg

@implementation PB3VoiceStyleCfg

@dynamic voiceStyleId;
@dynamic voiceStyleText;

typedef struct PB3VoiceStyleCfg__storage_ {
  uint32_t _has_storage_[1];
  int32_t voiceStyleId;
  NSString *voiceStyleText;
} PB3VoiceStyleCfg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceStyleId",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceStyleCfg_FieldNumber_VoiceStyleId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VoiceStyleCfg__storage_, voiceStyleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceStyleText",
        .dataTypeSpecific.className = NULL,
        .number = PB3VoiceStyleCfg_FieldNumber_VoiceStyleText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VoiceStyleCfg__storage_, voiceStyleText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceStyleCfg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceStyleCfg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagReq

@implementation PB3VoiceTagReq


typedef struct PB3VoiceTagReq__storage_ {
  uint32_t _has_storage_[1];
} PB3VoiceTagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3VoiceTagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VoiceTagRes

@implementation PB3VoiceTagRes

@dynamic voiceTagArray, voiceTagArray_Count;
@dynamic voiceStyleArray, voiceStyleArray_Count;

typedef struct PB3VoiceTagRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *voiceTagArray;
  NSMutableArray *voiceStyleArray;
} PB3VoiceTagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceTagArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceTagCfgList),
        .number = PB3VoiceTagRes_FieldNumber_VoiceTagArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagRes__storage_, voiceTagArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceStyleArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VoiceStyleCfg),
        .number = PB3VoiceTagRes_FieldNumber_VoiceStyleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3VoiceTagRes__storage_, voiceStyleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VoiceTagRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VoiceTagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UmengQuickBindPhoneReq

@implementation PB3UmengQuickBindPhoneReq

@dynamic appKey;
@dynamic token;
@dynamic yidunToken;

typedef struct PB3UmengQuickBindPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *appKey;
  NSString *token;
  NSString *yidunToken;
} PB3UmengQuickBindPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appKey",
        .dataTypeSpecific.className = NULL,
        .number = PB3UmengQuickBindPhoneReq_FieldNumber_AppKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UmengQuickBindPhoneReq__storage_, appKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PB3UmengQuickBindPhoneReq_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UmengQuickBindPhoneReq__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "yidunToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3UmengQuickBindPhoneReq_FieldNumber_YidunToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UmengQuickBindPhoneReq__storage_, yidunToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UmengQuickBindPhoneReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UmengQuickBindPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UmengQuickBindPhoneRes

@implementation PB3UmengQuickBindPhoneRes

@dynamic phone;

typedef struct PB3UmengQuickBindPhoneRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
} PB3UmengQuickBindPhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3UmengQuickBindPhoneRes_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UmengQuickBindPhoneRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UmengQuickBindPhoneRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UmengQuickBindPhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateBillPlayerStatus

@implementation PB3UpdateBillPlayerStatus

@dynamic skillId;
@dynamic status;
@dynamic isNewStatus;

typedef struct PB3UpdateBillPlayerStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t skillId;
} PB3UpdateBillPlayerStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBillPlayerStatus_FieldNumber_SkillId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateBillPlayerStatus__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBillPlayerStatus_FieldNumber_Status,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isNewStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBillPlayerStatus_FieldNumber_IsNewStatus,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateBillPlayerStatus class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateBillPlayerStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IsCheckingReq

@implementation PB3IsCheckingReq

@dynamic id_p;
@dynamic type;

typedef struct PB3IsCheckingReq__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  int64_t id_p;
} PB3IsCheckingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsCheckingReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IsCheckingReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3IsCheckingReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IsCheckingReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IsCheckingReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IsCheckingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3IsCheckingReq_Type_RawValue(PB3IsCheckingReq *message) {
  GPBDescriptor *descriptor = [PB3IsCheckingReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IsCheckingReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3IsCheckingReq_Type_RawValue(PB3IsCheckingReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3IsCheckingReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IsCheckingReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IsCheckingRes

@implementation PB3IsCheckingRes

@dynamic flag;
@dynamic type;
@dynamic name;
@dynamic time;

typedef struct PB3IsCheckingRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  NSString *name;
  NSString *time;
} PB3IsCheckingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsCheckingRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3IsCheckingRes_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IsCheckingRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsCheckingRes_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IsCheckingRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3IsCheckingRes_FieldNumber_Time,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IsCheckingRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IsCheckingRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IsCheckingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3IsCheckingRes_Type_RawValue(PB3IsCheckingRes *message) {
  GPBDescriptor *descriptor = [PB3IsCheckingRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IsCheckingRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3IsCheckingRes_Type_RawValue(PB3IsCheckingRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3IsCheckingRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IsCheckingRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IndexLeaveMessageListReq

@implementation PB3IndexLeaveMessageListReq

@dynamic ownerId;

typedef struct PB3IndexLeaveMessageListReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t ownerId;
} PB3IndexLeaveMessageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexLeaveMessageListReq_FieldNumber_OwnerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexLeaveMessageListReq__storage_, ownerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexLeaveMessageListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexLeaveMessageListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexLeaveMessageListRes

@implementation PB3IndexLeaveMessageListRes

@dynamic leaveMessageInfoArray, leaveMessageInfoArray_Count;

typedef struct PB3IndexLeaveMessageListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *leaveMessageInfoArray;
} PB3IndexLeaveMessageListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leaveMessageInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LeaveMessageInfo),
        .number = PB3IndexLeaveMessageListRes_FieldNumber_LeaveMessageInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IndexLeaveMessageListRes__storage_, leaveMessageInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexLeaveMessageListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexLeaveMessageListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LeaveMessageListReq

@implementation PB3LeaveMessageListReq

@dynamic index;
@dynamic leaveMsgType;

typedef struct PB3LeaveMessageListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB3LeaveMessageType leaveMsgType;
} PB3LeaveMessageListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageListReq_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LeaveMessageListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "leaveMsgType",
        .dataTypeSpecific.enumDescFunc = PB3LeaveMessageType_EnumDescriptor,
        .number = PB3LeaveMessageListReq_FieldNumber_LeaveMsgType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LeaveMessageListReq__storage_, leaveMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LeaveMessageListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LeaveMessageListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LeaveMessageListReq_LeaveMsgType_RawValue(PB3LeaveMessageListReq *message) {
  GPBDescriptor *descriptor = [PB3LeaveMessageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LeaveMessageListReq_FieldNumber_LeaveMsgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LeaveMessageListReq_LeaveMsgType_RawValue(PB3LeaveMessageListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LeaveMessageListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LeaveMessageListReq_FieldNumber_LeaveMsgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LeaveMessageListRes

@implementation PB3LeaveMessageListRes

@dynamic leaveMessageInfoArray, leaveMessageInfoArray_Count;
@dynamic nextIndex;

typedef struct PB3LeaveMessageListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *leaveMessageInfoArray;
} PB3LeaveMessageListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leaveMessageInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LeaveMessageInfo),
        .number = PB3LeaveMessageListRes_FieldNumber_LeaveMessageInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LeaveMessageListRes__storage_, leaveMessageInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LeaveMessageListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LeaveMessageListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LeaveMessageListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LeaveMessageInfo

@implementation PB3LeaveMessageInfo

@dynamic id_p;
@dynamic nickName;
@dynamic icon;
@dynamic leaveMessage;
@dynamic createAt;
@dynamic sex;
@dynamic playerId;
@dynamic receivePlayerId;

typedef struct PB3LeaveMessageInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  NSString *nickName;
  NSString *icon;
  NSString *leaveMessage;
  int64_t id_p;
  int64_t createAt;
  int64_t playerId;
  int64_t receivePlayerId;
} PB3LeaveMessageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leaveMessage",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_LeaveMessage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, leaveMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3LeaveMessageInfo_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_PlayerId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "receivePlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LeaveMessageInfo_FieldNumber_ReceivePlayerId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3LeaveMessageInfo__storage_, receivePlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LeaveMessageInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LeaveMessageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LeaveMessageInfo_Sex_RawValue(PB3LeaveMessageInfo *message) {
  GPBDescriptor *descriptor = [PB3LeaveMessageInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LeaveMessageInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LeaveMessageInfo_Sex_RawValue(PB3LeaveMessageInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LeaveMessageInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LeaveMessageInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SendLeaveMessageReq

@implementation PB3SendLeaveMessageReq

@dynamic receivePlayerId;
@dynamic leaveMessage;

typedef struct PB3SendLeaveMessageReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *leaveMessage;
  int64_t receivePlayerId;
} PB3SendLeaveMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receivePlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendLeaveMessageReq_FieldNumber_ReceivePlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SendLeaveMessageReq__storage_, receivePlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leaveMessage",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendLeaveMessageReq_FieldNumber_LeaveMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SendLeaveMessageReq__storage_, leaveMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendLeaveMessageReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SendLeaveMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SendLeaveMessageRes

@implementation PB3SendLeaveMessageRes


typedef struct PB3SendLeaveMessageRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SendLeaveMessageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendLeaveMessageRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SendLeaveMessageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeleteLeaveMessageReq

@implementation PB3DeleteLeaveMessageReq

@dynamic id_p;
@dynamic deleteAll;
@dynamic leaveMsgType;

typedef struct PB3DeleteLeaveMessageReq__storage_ {
  uint32_t _has_storage_[1];
  PB3LeaveMessageType leaveMsgType;
  int64_t id_p;
} PB3DeleteLeaveMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteLeaveMessageReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeleteLeaveMessageReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deleteAll",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeleteLeaveMessageReq_FieldNumber_DeleteAll,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "leaveMsgType",
        .dataTypeSpecific.enumDescFunc = PB3LeaveMessageType_EnumDescriptor,
        .number = PB3DeleteLeaveMessageReq_FieldNumber_LeaveMsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3DeleteLeaveMessageReq__storage_, leaveMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteLeaveMessageReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeleteLeaveMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3DeleteLeaveMessageReq_LeaveMsgType_RawValue(PB3DeleteLeaveMessageReq *message) {
  GPBDescriptor *descriptor = [PB3DeleteLeaveMessageReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DeleteLeaveMessageReq_FieldNumber_LeaveMsgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3DeleteLeaveMessageReq_LeaveMsgType_RawValue(PB3DeleteLeaveMessageReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3DeleteLeaveMessageReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3DeleteLeaveMessageReq_FieldNumber_LeaveMsgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3DeleteLeaveMessageRes

@implementation PB3DeleteLeaveMessageRes


typedef struct PB3DeleteLeaveMessageRes__storage_ {
  uint32_t _has_storage_[1];
} PB3DeleteLeaveMessageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeleteLeaveMessageRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3DeleteLeaveMessageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SimplePlayerListReq

@implementation PB3SimplePlayerListReq

@dynamic idsArray, idsArray_Count;

typedef struct PB3SimplePlayerListReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *idsArray;
} PB3SimplePlayerListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3SimplePlayerListReq_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SimplePlayerListReq__storage_, idsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SimplePlayerListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SimplePlayerListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SimplePlayerListRes

@implementation PB3SimplePlayerListRes

@dynamic listArray, listArray_Count;

typedef struct PB3SimplePlayerListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SimplePlayerListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3SimplePlayerListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SimplePlayerListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SimplePlayerListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SimplePlayerListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetLeaveMessageRedPointReq

@implementation PB3GetLeaveMessageRedPointReq


typedef struct PB3GetLeaveMessageRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetLeaveMessageRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetLeaveMessageRedPointReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetLeaveMessageRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetLeaveMessageRedPointRes

@implementation PB3GetLeaveMessageRedPointRes

@dynamic total;

typedef struct PB3GetLeaveMessageRedPointRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
} PB3GetLeaveMessageRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetLeaveMessageRedPointRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetLeaveMessageRedPointRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetLeaveMessageRedPointRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetLeaveMessageRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAttributeReq

@implementation PB3PlayerAttributeReq

@dynamic attributes, attributes_Count;

typedef struct PB3PlayerAttributeReq__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt32Dictionary *attributes;
} PB3PlayerAttributeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributes",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAttributeReq_FieldNumber_Attributes,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerAttributeReq__storage_, attributes),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAttributeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAttributeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAttributeRes

@implementation PB3PlayerAttributeRes

@dynamic attributes, attributes_Count;

typedef struct PB3PlayerAttributeRes__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt32Dictionary *attributes;
} PB3PlayerAttributeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributes",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAttributeRes_FieldNumber_Attributes,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerAttributeRes__storage_, attributes),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAttributeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAttributeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleReq

@implementation PB3BlackWhaleReq


typedef struct PB3BlackWhaleReq__storage_ {
  uint32_t _has_storage_[1];
} PB3BlackWhaleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3BlackWhaleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleRes

@implementation PB3BlackWhaleRes

@dynamic isBlackWhale;

typedef struct PB3BlackWhaleRes__storage_ {
  uint32_t _has_storage_[1];
} PB3BlackWhaleRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isBlackWhale",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleRes_FieldNumber_IsBlackWhale,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3JoinIntimateFansReq

@implementation PB3JoinIntimateFansReq

@dynamic playerId;
@dynamic day;
@dynamic type;
@dynamic gold;
@dynamic id_p;

typedef struct PB3JoinIntimateFansReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t day;
  PB3IntimateFansDayConf type;
  int32_t gold;
  int32_t id_p;
  int64_t playerId;
} PB3JoinIntimateFansReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansReq_FieldNumber_Day,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansReq__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3IntimateFansDayConf_EnumDescriptor,
        .number = PB3JoinIntimateFansReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansReq_FieldNumber_Gold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansReq_FieldNumber_Id_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3JoinIntimateFansReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3JoinIntimateFansReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3JoinIntimateFansReq_Type_RawValue(PB3JoinIntimateFansReq *message) {
  GPBDescriptor *descriptor = [PB3JoinIntimateFansReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3JoinIntimateFansReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3JoinIntimateFansReq_Type_RawValue(PB3JoinIntimateFansReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3JoinIntimateFansReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3JoinIntimateFansReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3JoinIntimateFansRes

@implementation PB3JoinIntimateFansRes

@dynamic validAt;

typedef struct PB3JoinIntimateFansRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t validAt;
} PB3JoinIntimateFansRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansRes_FieldNumber_ValidAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansRes__storage_, validAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3JoinIntimateFansRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3JoinIntimateFansRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3JoinIntimateFansQueryReq

@implementation PB3JoinIntimateFansQueryReq

@dynamic playerId;

typedef struct PB3JoinIntimateFansQueryReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3JoinIntimateFansQueryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansQueryReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansQueryReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3JoinIntimateFansQueryReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3JoinIntimateFansQueryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3JoinIntimateFansQueryRes

@implementation PB3JoinIntimateFansQueryRes

@dynamic hasPlayer, player;
@dynamic fansNum;
@dynamic validAt;
@dynamic confArray, confArray_Count;

typedef struct PB3JoinIntimateFansQueryRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t fansNum;
  PB3Player *player;
  NSMutableArray *confArray;
  int64_t validAt;
} PB3JoinIntimateFansQueryRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Player),
        .number = PB3JoinIntimateFansQueryRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansQueryRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fansNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansQueryRes_FieldNumber_FansNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansQueryRes__storage_, fansNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "validAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3JoinIntimateFansQueryRes_FieldNumber_ValidAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansQueryRes__storage_, validAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "confArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansConf),
        .number = PB3JoinIntimateFansQueryRes_FieldNumber_ConfArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3JoinIntimateFansQueryRes__storage_, confArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3JoinIntimateFansQueryRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3JoinIntimateFansQueryRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansConf

@implementation PB3IntimateFansConf

@dynamic id_p;
@dynamic day;
@dynamic type;
@dynamic price;
@dynamic discount;

typedef struct PB3IntimateFansConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t day;
  PB3IntimateFansDayConf type;
  int32_t price;
  int32_t discount;
} PB3IntimateFansConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansConf_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansConf__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansConf_FieldNumber_Day,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansConf__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3IntimateFansDayConf_EnumDescriptor,
        .number = PB3IntimateFansConf_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansConf__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansConf_FieldNumber_Price,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IntimateFansConf__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "discount",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansConf_FieldNumber_Discount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IntimateFansConf__storage_, discount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansConf class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3IntimateFansConf_Type_RawValue(PB3IntimateFansConf *message) {
  GPBDescriptor *descriptor = [PB3IntimateFansConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IntimateFansConf_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3IntimateFansConf_Type_RawValue(PB3IntimateFansConf *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3IntimateFansConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IntimateFansConf_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IntimateFansLevConf

@implementation PB3IntimateFansLevConf

@dynamic lev;
@dynamic levName;
@dynamic androidIconURL;
@dynamic androidBannerURL;
@dynamic iosHeadIconURL;
@dynamic iosTailIconURL;
@dynamic iosIconURL;
@dynamic iosIconBannerURL;
@dynamic pcIconURL;
@dynamic pcHeadIconURL;
@dynamic pcMiddleIconURL;
@dynamic pcTailIconURL;
@dynamic pcIconTagURL;
@dynamic pcIconBannerURL;
@dynamic androidIconTagURL;
@dynamic webIconHeadURL;
@dynamic webIconBodyURL;
@dynamic webIconTailURL;

typedef struct PB3IntimateFansLevConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t lev;
  NSString *levName;
  NSString *androidIconURL;
  NSString *androidBannerURL;
  NSString *iosHeadIconURL;
  NSString *iosTailIconURL;
  NSString *iosIconURL;
  NSString *iosIconBannerURL;
  NSString *pcIconURL;
  NSString *pcHeadIconURL;
  NSString *pcMiddleIconURL;
  NSString *pcTailIconURL;
  NSString *pcIconTagURL;
  NSString *pcIconBannerURL;
  NSString *androidIconTagURL;
  NSString *webIconHeadURL;
  NSString *webIconBodyURL;
  NSString *webIconTailURL;
} PB3IntimateFansLevConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lev",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_Lev,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, lev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levName",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_LevName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, levName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_AndroidIconURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, androidIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidBannerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_AndroidBannerURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, androidBannerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosHeadIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_IosHeadIconURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, iosHeadIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosTailIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_IosTailIconURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, iosTailIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_IosIconURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, iosIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosIconBannerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_IosIconBannerURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, iosIconBannerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcIconURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcHeadIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcHeadIconURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcHeadIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcMiddleIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcMiddleIconURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcMiddleIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcTailIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcTailIconURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcTailIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconTagURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcIconTagURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcIconTagURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconBannerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_PcIconBannerURL,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, pcIconBannerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidIconTagURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_AndroidIconTagURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, androidIconTagURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "webIconHeadURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_WebIconHeadURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, webIconHeadURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "webIconBodyURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_WebIconBodyURL,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, webIconBodyURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "webIconTailURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevConf_FieldNumber_WebIconTailURL,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConf__storage_, webIconTailURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansLevConf class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansLevConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\020\003\007\244\241!!\000\004\007\246\241!!\000\005\003\244\244\241!!\000\006\003\244\244\241!!\000\007\003\244\241!!\000\010\003"
        "\244\246\241!!\000\t\002\244\241!!\000\n\002\244\244\241!!\000\013\002\246\244\241!!\000\014\002\244\244\241!!\000\r\002\244"
        "\243\241!!\000\016\002\244\246\241!!\000\017\007\244\243\241!!\000\020\003\244\244\241!!\000\021\003\244\244\241!!\000\022\003\244"
        "\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansLevConfReq

@implementation PB3IntimateFansLevConfReq


typedef struct PB3IntimateFansLevConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3IntimateFansLevConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansLevConfReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3IntimateFansLevConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansLevConfRes

@implementation PB3IntimateFansLevConfRes

@dynamic confListArray, confListArray_Count;

typedef struct PB3IntimateFansLevConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confListArray;
} PB3IntimateFansLevConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansLevConf),
        .number = PB3IntimateFansLevConfRes_FieldNumber_ConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevConfRes__storage_, confListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansLevConfRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansLevConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PushIntimateFansCardInfo

@implementation PB3PushIntimateFansCardInfo

@dynamic playerId;
@dynamic cardName;
@dynamic lev;
@dynamic pushType;

typedef struct PB3PushIntimateFansCardInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t lev;
  PB3PushIntimateFansCardInfoType pushType;
  NSString *cardName;
  int64_t playerId;
} PB3PushIntimateFansCardInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PushIntimateFansCardInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PushIntimateFansCardInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PushIntimateFansCardInfo_FieldNumber_CardName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PushIntimateFansCardInfo__storage_, cardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lev",
        .dataTypeSpecific.className = NULL,
        .number = PB3PushIntimateFansCardInfo_FieldNumber_Lev,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PushIntimateFansCardInfo__storage_, lev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.enumDescFunc = PB3PushIntimateFansCardInfoType_EnumDescriptor,
        .number = PB3PushIntimateFansCardInfo_FieldNumber_PushType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PushIntimateFansCardInfo__storage_, pushType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PushIntimateFansCardInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PushIntimateFansCardInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PushIntimateFansCardInfo_PushType_RawValue(PB3PushIntimateFansCardInfo *message) {
  GPBDescriptor *descriptor = [PB3PushIntimateFansCardInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PushIntimateFansCardInfo_FieldNumber_PushType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PushIntimateFansCardInfo_PushType_RawValue(PB3PushIntimateFansCardInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PushIntimateFansCardInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PushIntimateFansCardInfo_FieldNumber_PushType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IntimateFansCardInfo

@implementation PB3IntimateFansCardInfo

@dynamic playerId;
@dynamic lev;
@dynamic cardName;

typedef struct PB3IntimateFansCardInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t lev;
  NSString *cardName;
  int64_t playerId;
} PB3IntimateFansCardInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lev",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardInfo_FieldNumber_Lev,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardInfo__storage_, lev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardInfo_FieldNumber_CardName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardInfo__storage_, cardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansCardInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansCardInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansCardInfoReq

@implementation PB3IntimateFansCardInfoReq


typedef struct PB3IntimateFansCardInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3IntimateFansCardInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansCardInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3IntimateFansCardInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansCardInfoRes

@implementation PB3IntimateFansCardInfoRes

@dynamic usedPlayerId;
@dynamic cardListArray, cardListArray_Count;

typedef struct PB3IntimateFansCardInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cardListArray;
  int64_t usedPlayerId;
} PB3IntimateFansCardInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usedPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardInfoRes_FieldNumber_UsedPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardInfoRes__storage_, usedPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cardListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansCardInfo),
        .number = PB3IntimateFansCardInfoRes_FieldNumber_CardListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardInfoRes__storage_, cardListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansCardInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansCardInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetIntimateFansCardReq

@implementation PB3SetIntimateFansCardReq

@dynamic playerId;

typedef struct PB3SetIntimateFansCardReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3SetIntimateFansCardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetIntimateFansCardReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetIntimateFansCardReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetIntimateFansCardReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetIntimateFansCardReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetIntimateFansCardRes

@implementation PB3SetIntimateFansCardRes

@dynamic playerId;

typedef struct PB3SetIntimateFansCardRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3SetIntimateFansCardRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetIntimateFansCardRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetIntimateFansCardRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetIntimateFansCardRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetIntimateFansCardRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansHostInfo

@implementation PB3IntimateFansHostInfo

@dynamic playerId;
@dynamic playerSid;
@dynamic icon;
@dynamic intimateFansNum;
@dynamic intimateVal;
@dynamic intimateRank;
@dynamic rankIconListArray, rankIconListArray_Count;
@dynamic playerName;

typedef struct PB3IntimateFansHostInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  NSMutableArray *rankIconListArray;
  NSString *playerName;
  int64_t playerId;
  int64_t playerSid;
  int64_t intimateFansNum;
  int64_t intimateVal;
  int64_t intimateRank;
} PB3IntimateFansHostInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerSid",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_PlayerSid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, playerSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intimateFansNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_IntimateFansNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, intimateFansNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "intimateVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_IntimateVal,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, intimateVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "intimateRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_IntimateRank,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, intimateRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rankIconListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_RankIconListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, rankIconListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansHostInfo_FieldNumber_PlayerName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostInfo__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansHostInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansHostInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansCardSetting

@implementation PB3IntimateFansCardSetting

@dynamic status;
@dynamic cardName;
@dynamic auditName;

typedef struct PB3IntimateFansCardSetting__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *cardName;
  NSString *auditName;
} PB3IntimateFansCardSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardSetting_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardSetting__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardSetting_FieldNumber_CardName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardSetting__storage_, cardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "auditName",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansCardSetting_FieldNumber_AuditName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansCardSetting__storage_, auditName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansCardSetting class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansCardSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansLevInfo

@implementation PB3IntimateFansLevInfo

@dynamic lev;
@dynamic exp;
@dynamic gapExp;
@dynamic expiredTime;
@dynamic myIcon;
@dynamic hostIcon;
@dynamic levExp;

typedef struct PB3IntimateFansLevInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t lev;
  NSString *myIcon;
  NSString *hostIcon;
  int64_t exp;
  int64_t gapExp;
  int64_t expiredTime;
  int64_t levExp;
} PB3IntimateFansLevInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lev",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_Lev,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, lev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exp",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_Exp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, exp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gapExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_GapExp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, gapExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_ExpiredTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, expiredTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "myIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_MyIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, myIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_HostIcon,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levExp",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansLevInfo_FieldNumber_LevExp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IntimateFansLevInfo__storage_, levExp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansLevInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansLevInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansHostViewReq

@implementation PB3IntimateFansHostViewReq


typedef struct PB3IntimateFansHostViewReq__storage_ {
  uint32_t _has_storage_[1];
} PB3IntimateFansHostViewReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansHostViewReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3IntimateFansHostViewReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansHostViewRes

@implementation PB3IntimateFansHostViewRes

@dynamic hasHostInfo, hostInfo;
@dynamic hasCardSetting, cardSetting;

typedef struct PB3IntimateFansHostViewRes__storage_ {
  uint32_t _has_storage_[1];
  PB3IntimateFansHostInfo *hostInfo;
  PB3IntimateFansCardSetting *cardSetting;
} PB3IntimateFansHostViewRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansHostInfo),
        .number = PB3IntimateFansHostViewRes_FieldNumber_HostInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostViewRes__storage_, hostInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cardSetting",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansCardSetting),
        .number = PB3IntimateFansHostViewRes_FieldNumber_CardSetting,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansHostViewRes__storage_, cardSetting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansHostViewRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansHostViewRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansViewReq

@implementation PB3IntimateFansViewReq

@dynamic playerId;

typedef struct PB3IntimateFansViewReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3IntimateFansViewReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansViewReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansViewReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansViewReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansViewReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansViewRes

@implementation PB3IntimateFansViewRes

@dynamic hasHostInfo, hostInfo;

typedef struct PB3IntimateFansViewRes__storage_ {
  uint32_t _has_storage_[1];
  PB3IntimateFansHostInfo *hostInfo;
} PB3IntimateFansViewRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansHostInfo),
        .number = PB3IntimateFansViewRes_FieldNumber_HostInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansViewRes__storage_, hostInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansViewRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansViewRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetIntimateFansCardInfoReq

@implementation PB3SetIntimateFansCardInfoReq

@dynamic cardName;

typedef struct PB3SetIntimateFansCardInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *cardName;
} PB3SetIntimateFansCardInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetIntimateFansCardInfoReq_FieldNumber_CardName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetIntimateFansCardInfoReq__storage_, cardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetIntimateFansCardInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetIntimateFansCardInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetIntimateFansCardInfoRes

@implementation PB3SetIntimateFansCardInfoRes

@dynamic hasCardSetting, cardSetting;

typedef struct PB3SetIntimateFansCardInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3IntimateFansCardSetting *cardSetting;
} PB3SetIntimateFansCardInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardSetting",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansCardSetting),
        .number = PB3SetIntimateFansCardInfoRes_FieldNumber_CardSetting,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetIntimateFansCardInfoRes__storage_, cardSetting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetIntimateFansCardInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetIntimateFansCardInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansTarget

@implementation PB3IntimateFansTarget

@dynamic id_p;
@dynamic type;
@dynamic name;
@dynamic desc;
@dynamic status;
@dynamic progressVal;
@dynamic targetVal;
@dynamic intimateVal;

typedef struct PB3IntimateFansTarget__storage_ {
  uint32_t _has_storage_[1];
  PB3IntimateFansTargetType type;
  int32_t status;
  NSString *name;
  NSString *desc;
  int64_t id_p;
  int64_t progressVal;
  int64_t targetVal;
  int64_t intimateVal;
} PB3IntimateFansTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3IntimateFansTargetType_EnumDescriptor,
        .number = PB3IntimateFansTarget_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "progressVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_ProgressVal,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, progressVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_TargetVal,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, targetVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "intimateVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansTarget_FieldNumber_IntimateVal,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3IntimateFansTarget__storage_, intimateVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansTarget class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3IntimateFansTarget_Type_RawValue(PB3IntimateFansTarget *message) {
  GPBDescriptor *descriptor = [PB3IntimateFansTarget descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IntimateFansTarget_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3IntimateFansTarget_Type_RawValue(PB3IntimateFansTarget *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3IntimateFansTarget descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3IntimateFansTarget_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3IntimateFansDetailReq

@implementation PB3IntimateFansDetailReq

@dynamic playerId;

typedef struct PB3IntimateFansDetailReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3IntimateFansDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansDetailReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansDetailReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansDetailReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansDetailRes

@implementation PB3IntimateFansDetailRes

@dynamic isValid;
@dynamic targetListArray, targetListArray_Count;
@dynamic hasLevInfo, levInfo;
@dynamic confListArray, confListArray_Count;

typedef struct PB3IntimateFansDetailRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *targetListArray;
  PB3IntimateFansLevInfo *levInfo;
  NSMutableArray *confListArray;
} PB3IntimateFansDetailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isValid",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansDetailRes_FieldNumber_IsValid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansTarget),
        .number = PB3IntimateFansDetailRes_FieldNumber_TargetListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IntimateFansDetailRes__storage_, targetListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "levInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansLevInfo),
        .number = PB3IntimateFansDetailRes_FieldNumber_LevInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IntimateFansDetailRes__storage_, levInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IntimateFansConf),
        .number = PB3IntimateFansDetailRes_FieldNumber_ConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IntimateFansDetailRes__storage_, confListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansDetailRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansDetailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveListReq

@implementation PB3GuardLiveListReq


typedef struct PB3GuardLiveListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GuardLiveListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GuardLiveListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveListRes

@implementation PB3GuardLiveListRes

@dynamic onOff;
@dynamic listArray, listArray_Count;
@dynamic timeoutListArray, timeoutListArray_Count;
@dynamic recommendListArray, recommendListArray_Count;
@dynamic liveId;

typedef struct PB3GuardLiveListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  NSMutableArray *timeoutListArray;
  NSMutableArray *recommendListArray;
  int64_t liveId;
} PB3GuardLiveListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOff",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveListRes_FieldNumber_OnOff,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveInfo),
        .number = PB3GuardLiveListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GuardLiveListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeoutListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveTimeoutInfo),
        .number = PB3GuardLiveListRes_FieldNumber_TimeoutListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GuardLiveListRes__storage_, timeoutListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recommendListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveRecommendInfo),
        .number = PB3GuardLiveListRes_FieldNumber_RecommendListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GuardLiveListRes__storage_, recommendListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveListRes_FieldNumber_LiveId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GuardLiveListRes__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GuardLiveListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveCommonInfo

@implementation PB3GuardLiveCommonInfo

@dynamic lev;
@dynamic bannerName;
@dynamic liveIcon;
@dynamic liveName;
@dynamic liveId;
@dynamic liveSid;

typedef struct PB3GuardLiveCommonInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t lev;
  NSString *bannerName;
  NSString *liveIcon;
  NSString *liveName;
  int64_t liveId;
  int64_t liveSid;
} PB3GuardLiveCommonInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lev",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_Lev,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, lev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "bannerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_BannerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, bannerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "liveIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_LiveIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, liveIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "liveName",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_LiveName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, liveName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "liveId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_LiveId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "liveSid",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveCommonInfo_FieldNumber_LiveSid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GuardLiveCommonInfo__storage_, liveSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveCommonInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GuardLiveCommonInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveInfo

@implementation PB3GuardLiveInfo

@dynamic hasInfo, info;
@dynamic validAt;

typedef struct PB3GuardLiveInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3GuardLiveCommonInfo *info;
  int64_t validAt;
} PB3GuardLiveInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveCommonInfo),
        .number = PB3GuardLiveInfo_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GuardLiveInfo__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveInfo_FieldNumber_ValidAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GuardLiveInfo__storage_, validAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GuardLiveInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveTimeoutInfo

@implementation PB3GuardLiveTimeoutInfo

@dynamic hasInfo, info;

typedef struct PB3GuardLiveTimeoutInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3GuardLiveCommonInfo *info;
} PB3GuardLiveTimeoutInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveCommonInfo),
        .number = PB3GuardLiveTimeoutInfo_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GuardLiveTimeoutInfo__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveTimeoutInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GuardLiveTimeoutInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GuardLiveRecommendInfo

@implementation PB3GuardLiveRecommendInfo

@dynamic hasInfo, info;
@dynamic fansNum;

typedef struct PB3GuardLiveRecommendInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t fansNum;
  PB3GuardLiveCommonInfo *info;
} PB3GuardLiveRecommendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GuardLiveCommonInfo),
        .number = PB3GuardLiveRecommendInfo_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GuardLiveRecommendInfo__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fansNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3GuardLiveRecommendInfo_FieldNumber_FansNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GuardLiveRecommendInfo__storage_, fansNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GuardLiveRecommendInfo class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GuardLiveRecommendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansJumpUrlReq

@implementation PB3IntimateFansJumpUrlReq

@dynamic liveId;

typedef struct PB3IntimateFansJumpUrlReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t liveId;
} PB3IntimateFansJumpUrlReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansJumpUrlReq_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansJumpUrlReq__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansJumpUrlReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansJumpUrlReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IntimateFansJumpUrlRes

@implementation PB3IntimateFansJumpUrlRes

@dynamic liveId;

typedef struct PB3IntimateFansJumpUrlRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t liveId;
} PB3IntimateFansJumpUrlRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.className = NULL,
        .number = PB3IntimateFansJumpUrlRes_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IntimateFansJumpUrlRes__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IntimateFansJumpUrlRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IntimateFansJumpUrlRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SwitchStatusReq

@implementation PB3SwitchStatusReq

@dynamic typeListArray, typeListArray_Count;

typedef struct PB3SwitchStatusReq__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *typeListArray;
} PB3SwitchStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "typeListArray",
        .dataTypeSpecific.enumDescFunc = PB3PrivacyType_EnumDescriptor,
        .number = PB3SwitchStatusReq_FieldNumber_TypeListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SwitchStatusReq__storage_, typeListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SwitchStatusReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SwitchStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SwitchStatusRes

@implementation PB3SwitchStatusRes

@dynamic onOffListArray, onOffListArray_Count;

typedef struct PB3SwitchStatusRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *onOffListArray;
} PB3SwitchStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOffListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PrivacyTypeVal),
        .number = PB3SwitchStatusRes_FieldNumber_OnOffListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SwitchStatusRes__storage_, onOffListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SwitchStatusRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SwitchStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WhaleBossStatusReq

@implementation PB3WhaleBossStatusReq


typedef struct PB3WhaleBossStatusReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WhaleBossStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WhaleBossStatusReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WhaleBossStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WhaleBossStatusRes

@implementation PB3WhaleBossStatusRes

@dynamic dayTimes;
@dynamic nextTime;

typedef struct PB3WhaleBossStatusRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t dayTimes;
  int64_t nextTime;
} PB3WhaleBossStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dayTimes",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBossStatusRes_FieldNumber_DayTimes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WhaleBossStatusRes__storage_, dayTimes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBossStatusRes_FieldNumber_NextTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WhaleBossStatusRes__storage_, nextTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WhaleBossStatusRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WhaleBossStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WhaleBoss

@implementation PB3WhaleBoss

@dynamic playerId;
@dynamic playerSid;
@dynamic name;
@dynamic sex;
@dynamic wealthLev;
@dynamic charmLev;
@dynamic potential;
@dynamic icon;

typedef struct PB3WhaleBoss__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  int32_t wealthLev;
  int32_t charmLev;
  int32_t potential;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t playerSid;
} PB3WhaleBoss__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerSid",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_PlayerSid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, playerSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3WhaleBoss_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wealthLev",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_WealthLev,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, wealthLev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLev",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_CharmLev,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, charmLev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "potential",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_Potential,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, potential),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WhaleBoss_FieldNumber_Icon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3WhaleBoss__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WhaleBoss class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WhaleBoss__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WhaleBoss_Sex_RawValue(PB3WhaleBoss *message) {
  GPBDescriptor *descriptor = [PB3WhaleBoss descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WhaleBoss_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WhaleBoss_Sex_RawValue(PB3WhaleBoss *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WhaleBoss descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WhaleBoss_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WhaleBossListReq

@implementation PB3WhaleBossListReq


typedef struct PB3WhaleBossListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WhaleBossListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WhaleBossListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WhaleBossListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WhaleBossListRes

@implementation PB3WhaleBossListRes

@dynamic bossListArray, bossListArray_Count;

typedef struct PB3WhaleBossListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bossListArray;
} PB3WhaleBossListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bossListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WhaleBoss),
        .number = PB3WhaleBossListRes_FieldNumber_BossListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WhaleBossListRes__storage_, bossListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WhaleBossListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WhaleBossListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CatchWhaleBossReq

@implementation PB3CatchWhaleBossReq


typedef struct PB3CatchWhaleBossReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CatchWhaleBossReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CatchWhaleBossReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CatchWhaleBossReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CatchWhaleBossRes

@implementation PB3CatchWhaleBossRes

@dynamic bossListArray, bossListArray_Count;
@dynamic dayTimes;
@dynamic nextTime;

typedef struct PB3CatchWhaleBossRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t dayTimes;
  NSMutableArray *bossListArray;
  int64_t nextTime;
} PB3CatchWhaleBossRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bossListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WhaleBoss),
        .number = PB3CatchWhaleBossRes_FieldNumber_BossListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CatchWhaleBossRes__storage_, bossListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dayTimes",
        .dataTypeSpecific.className = NULL,
        .number = PB3CatchWhaleBossRes_FieldNumber_DayTimes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CatchWhaleBossRes__storage_, dayTimes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CatchWhaleBossRes_FieldNumber_NextTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CatchWhaleBossRes__storage_, nextTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CatchWhaleBossRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CatchWhaleBossRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaveSongImgReq

@implementation PB3SaveSongImgReq

@dynamic img;

typedef struct PB3SaveSongImgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *img;
} PB3SaveSongImgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaveSongImgReq_FieldNumber_Img,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaveSongImgReq__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaveSongImgReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaveSongImgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaveSongImgRes

@implementation PB3SaveSongImgRes


typedef struct PB3SaveSongImgRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SaveSongImgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaveSongImgRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SaveSongImgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HomeLoadSuccessReq

@implementation PB3HomeLoadSuccessReq

@dynamic timestamp;

typedef struct PB3HomeLoadSuccessReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t timestamp;
} PB3HomeLoadSuccessReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3HomeLoadSuccessReq_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HomeLoadSuccessReq__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HomeLoadSuccessReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HomeLoadSuccessReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HomeLoadSuccessRes

@implementation PB3HomeLoadSuccessRes


typedef struct PB3HomeLoadSuccessRes__storage_ {
  uint32_t _has_storage_[1];
} PB3HomeLoadSuccessRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HomeLoadSuccessRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3HomeLoadSuccessRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetChannelFilterReq

@implementation PB3SetChannelFilterReq

@dynamic channelListArray, channelListArray_Count;

typedef struct PB3SetChannelFilterReq__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *channelListArray;
} PB3SetChannelFilterReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelListArray",
        .dataTypeSpecific.enumDescFunc = PB3ChannelType_EnumDescriptor,
        .number = PB3SetChannelFilterReq_FieldNumber_ChannelListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SetChannelFilterReq__storage_, channelListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetChannelFilterReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetChannelFilterReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetChannelFilterRes

@implementation PB3SetChannelFilterRes


typedef struct PB3SetChannelFilterRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetChannelFilterRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetChannelFilterRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetChannelFilterRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChannelSubscribeReq

@implementation PB3ChannelSubscribeReq

@dynamic channelId;
@dynamic channelType;

typedef struct PB3ChannelSubscribeReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ChannelPrefix channelType;
  int64_t channelId;
} PB3ChannelSubscribeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ChannelSubscribeReq_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChannelSubscribeReq__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = PB3ChannelPrefix_EnumDescriptor,
        .number = PB3ChannelSubscribeReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ChannelSubscribeReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChannelSubscribeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChannelSubscribeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ChannelSubscribeReq_ChannelType_RawValue(PB3ChannelSubscribeReq *message) {
  GPBDescriptor *descriptor = [PB3ChannelSubscribeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChannelSubscribeReq_FieldNumber_ChannelType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ChannelSubscribeReq_ChannelType_RawValue(PB3ChannelSubscribeReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ChannelSubscribeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChannelSubscribeReq_FieldNumber_ChannelType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ChannelSubscribeRes

@implementation PB3ChannelSubscribeRes


typedef struct PB3ChannelSubscribeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ChannelSubscribeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChannelSubscribeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ChannelSubscribeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ChannelDesubscribeReq

@implementation PB3ChannelDesubscribeReq

@dynamic channelType;

typedef struct PB3ChannelDesubscribeReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ChannelPrefix channelType;
} PB3ChannelDesubscribeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = PB3ChannelPrefix_EnumDescriptor,
        .number = PB3ChannelDesubscribeReq_FieldNumber_ChannelType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ChannelDesubscribeReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChannelDesubscribeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ChannelDesubscribeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ChannelDesubscribeReq_ChannelType_RawValue(PB3ChannelDesubscribeReq *message) {
  GPBDescriptor *descriptor = [PB3ChannelDesubscribeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChannelDesubscribeReq_FieldNumber_ChannelType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ChannelDesubscribeReq_ChannelType_RawValue(PB3ChannelDesubscribeReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ChannelDesubscribeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ChannelDesubscribeReq_FieldNumber_ChannelType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ChannelDesubscribeRes

@implementation PB3ChannelDesubscribeRes


typedef struct PB3ChannelDesubscribeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ChannelDesubscribeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ChannelDesubscribeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ChannelDesubscribeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateBindPhoneReq

@implementation PB3UpdateBindPhoneReq

@dynamic identityCardPhoto;
@dynamic phone;

typedef struct PB3UpdateBindPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *identityCardPhoto;
  NSString *phone;
} PB3UpdateBindPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityCardPhoto",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBindPhoneReq_FieldNumber_IdentityCardPhoto,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateBindPhoneReq__storage_, identityCardPhoto),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBindPhoneReq_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UpdateBindPhoneReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateBindPhoneReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateBindPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateBindPhoneRes

@implementation PB3UpdateBindPhoneRes

@dynamic type;
@dynamic name;
@dynamic time;

typedef struct PB3UpdateBindPhoneRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CheckType type;
  NSString *name;
  NSString *time;
} PB3UpdateBindPhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CheckType_EnumDescriptor,
        .number = PB3UpdateBindPhoneRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateBindPhoneRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBindPhoneRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UpdateBindPhoneRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateBindPhoneRes_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UpdateBindPhoneRes__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateBindPhoneRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateBindPhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UpdateBindPhoneRes_Type_RawValue(PB3UpdateBindPhoneRes *message) {
  GPBDescriptor *descriptor = [PB3UpdateBindPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UpdateBindPhoneRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UpdateBindPhoneRes_Type_RawValue(PB3UpdateBindPhoneRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UpdateBindPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UpdateBindPhoneRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SettingOnOffReq

@implementation PB3SettingOnOffReq

@dynamic hasOnOff, onOff;

typedef struct PB3SettingOnOffReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SettingOnOffStatus *onOff;
} PB3SettingOnOffReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOff",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SettingOnOffStatus),
        .number = PB3SettingOnOffReq_FieldNumber_OnOff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SettingOnOffReq__storage_, onOff),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SettingOnOffReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SettingOnOffReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SettingOnOffStatus

@implementation PB3SettingOnOffStatus

@dynamic onOffType;
@dynamic isOpen;

typedef struct PB3SettingOnOffStatus__storage_ {
  uint32_t _has_storage_[1];
  PB3SettingType onOffType;
} PB3SettingOnOffStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOffType",
        .dataTypeSpecific.enumDescFunc = PB3SettingType_EnumDescriptor,
        .number = PB3SettingOnOffStatus_FieldNumber_OnOffType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SettingOnOffStatus__storage_, onOffType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3SettingOnOffStatus_FieldNumber_IsOpen,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SettingOnOffStatus class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SettingOnOffStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SettingOnOffStatus_OnOffType_RawValue(PB3SettingOnOffStatus *message) {
  GPBDescriptor *descriptor = [PB3SettingOnOffStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SettingOnOffStatus_FieldNumber_OnOffType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SettingOnOffStatus_OnOffType_RawValue(PB3SettingOnOffStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SettingOnOffStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SettingOnOffStatus_FieldNumber_OnOffType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SettingOnOffRes

@implementation PB3SettingOnOffRes


typedef struct PB3SettingOnOffRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SettingOnOffRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SettingOnOffRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SettingOnOffRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SettingOnOffListReq

@implementation PB3SettingOnOffListReq


typedef struct PB3SettingOnOffListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SettingOnOffListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SettingOnOffListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SettingOnOffListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SettingOnOffListRes

@implementation PB3SettingOnOffListRes

@dynamic listArray, listArray_Count;

typedef struct PB3SettingOnOffListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SettingOnOffListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SettingOnOffStatus),
        .number = PB3SettingOnOffListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SettingOnOffListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SettingOnOffListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SettingOnOffListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReceivePushReq

@implementation PB3ReceivePushReq


typedef struct PB3ReceivePushReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ReceivePushReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceivePushReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReceivePushReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReceivePushRes

@implementation PB3ReceivePushRes


typedef struct PB3ReceivePushRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReceivePushRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceivePushRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReceivePushRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommGetUserOnOffReq

@implementation PB3GameCommGetUserOnOffReq

@dynamic onOffListArray, onOffListArray_Count;

typedef struct PB3GameCommGetUserOnOffReq__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *onOffListArray;
} PB3GameCommGetUserOnOffReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onOffListArray",
        .dataTypeSpecific.enumDescFunc = PB3UserOnOffType_EnumDescriptor,
        .number = PB3GameCommGetUserOnOffReq_FieldNumber_OnOffListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserOnOffReq__storage_, onOffListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommGetUserOnOffReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommGetUserOnOffReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommChangeUserOnOffRes

@implementation PB3GameCommChangeUserOnOffRes


typedef struct PB3GameCommChangeUserOnOffRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GameCommChangeUserOnOffRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommChangeUserOnOffRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GameCommChangeUserOnOffRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommSelfHomePageReq

@implementation PB3GameCommSelfHomePageReq


typedef struct PB3GameCommSelfHomePageReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GameCommSelfHomePageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommSelfHomePageReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GameCommSelfHomePageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommSelfHomePageRes

@implementation PB3GameCommSelfHomePageRes

@dynamic hasPlayer, player;
@dynamic concern;
@dynamic fans;
@dynamic trendsPhotoArray, trendsPhotoArray_Count;

typedef struct PB3GameCommSelfHomePageRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t concern;
  int32_t fans;
  PB3GameCommPlayer *player;
  NSMutableArray *trendsPhotoArray;
} PB3GameCommSelfHomePageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3GameCommSelfHomePageRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommSelfHomePageRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "concern",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommSelfHomePageRes_FieldNumber_Concern,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommSelfHomePageRes__storage_, concern),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fans",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommSelfHomePageRes_FieldNumber_Fans,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameCommSelfHomePageRes__storage_, fans),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendsPhotoArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommSelfHomePageRes_FieldNumber_TrendsPhotoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommSelfHomePageRes__storage_, trendsPhotoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommSelfHomePageRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommSelfHomePageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommOtherHomePageReq

@implementation PB3GameCommOtherHomePageReq

@dynamic playerId;

typedef struct PB3GameCommOtherHomePageReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GameCommOtherHomePageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommOtherHomePageReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommOtherHomePageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommOtherHomePageRes

@implementation PB3GameCommOtherHomePageRes

@dynamic hasPlayer, player;
@dynamic playCount;
@dynamic achieve;
@dynamic totalAchieve;
@dynamic concern;
@dynamic fans;
@dynamic trendsPhotoArray, trendsPhotoArray_Count;
@dynamic friendType;

typedef struct PB3GameCommOtherHomePageRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t playCount;
  int32_t achieve;
  int32_t totalAchieve;
  int32_t concern;
  int32_t fans;
  PB3FriendType friendType;
  PB3GameCommPlayer *player;
  NSMutableArray *trendsPhotoArray;
} PB3GameCommOtherHomePageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3GameCommOtherHomePageRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_PlayCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, playCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "achieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_Achieve,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, achieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalAchieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_TotalAchieve,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, totalAchieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "concern",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_Concern,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, concern),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fans",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_Fans,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, fans),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendsPhotoArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_TrendsPhotoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, trendsPhotoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendType",
        .dataTypeSpecific.enumDescFunc = PB3FriendType_EnumDescriptor,
        .number = PB3GameCommOtherHomePageRes_FieldNumber_FriendType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GameCommOtherHomePageRes__storage_, friendType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommOtherHomePageRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommOtherHomePageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GameCommOtherHomePageRes_FriendType_RawValue(PB3GameCommOtherHomePageRes *message) {
  GPBDescriptor *descriptor = [PB3GameCommOtherHomePageRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GameCommOtherHomePageRes_FieldNumber_FriendType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GameCommOtherHomePageRes_FriendType_RawValue(PB3GameCommOtherHomePageRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GameCommOtherHomePageRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GameCommOtherHomePageRes_FieldNumber_FriendType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GameAchievementItem

@implementation PB3GameAchievementItem

@dynamic title;
@dynamic icon;
@dynamic desc;
@dynamic achieveCount;
@dynamic finishCount;
@dynamic isFinish;
@dynamic achieveAt;
@dynamic finishType;
@dynamic weight;

typedef struct PB3GameAchievementItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t achieveCount;
  int32_t finishCount;
  int32_t finishType;
  int32_t weight;
  NSString *title;
  NSString *icon;
  NSString *desc;
  int64_t achieveAt;
} PB3GameAchievementItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "achieveCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_AchieveCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, achieveCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "finishCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_FinishCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, finishCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isFinish",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_IsFinish,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "achieveAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_AchieveAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, achieveAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "finishType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_FinishType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, finishType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameAchievementItem_FieldNumber_Weight,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3GameAchievementItem__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameAchievementItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameAchievementItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameScoreItem

@implementation PB3GameScoreItem

@dynamic hasIcon, icon;
@dynamic score;
@dynamic scoreType;

typedef struct PB3GameScoreItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t scoreType;
  PB3GameCommGameIcon *icon;
  int64_t score;
} PB3GameScoreItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommGameIcon),
        .number = PB3GameScoreItem_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameScoreItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreItem_FieldNumber_Score,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameScoreItem__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "scoreType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreItem_FieldNumber_ScoreType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameScoreItem__storage_, scoreType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameScoreItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameScoreItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommUserAchievementReq

@implementation PB3GameCommUserAchievementReq

@dynamic playerId;
@dynamic gameId;

typedef struct PB3GameCommUserAchievementReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
  int64_t gameId;
} PB3GameCommUserAchievementReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserAchievementReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserAchievementReq_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommUserAchievementReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommUserAchievementReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommUserAchievementRes

@implementation PB3GameCommUserAchievementRes

@dynamic hasPlayer, player;
@dynamic playCount;
@dynamic achieve;
@dynamic totalAchieve;
@dynamic finishArray, finishArray_Count;
@dynamic notFinishArray, notFinishArray_Count;
@dynamic recentFinishArray, recentFinishArray_Count;

typedef struct PB3GameCommUserAchievementRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t playCount;
  int32_t achieve;
  int32_t totalAchieve;
  PB3GameCommPlayer *player;
  NSMutableArray *finishArray;
  NSMutableArray *notFinishArray;
  NSMutableArray *recentFinishArray;
} PB3GameCommUserAchievementRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3GameCommUserAchievementRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserAchievementRes_FieldNumber_PlayCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, playCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "achieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserAchievementRes_FieldNumber_Achieve,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, achieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalAchieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserAchievementRes_FieldNumber_TotalAchieve,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, totalAchieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "finishArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameAchievementItem),
        .number = PB3GameCommUserAchievementRes_FieldNumber_FinishArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, finishArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notFinishArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameAchievementItem),
        .number = PB3GameCommUserAchievementRes_FieldNumber_NotFinishArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, notFinishArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recentFinishArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameAchievementItem),
        .number = PB3GameCommUserAchievementRes_FieldNumber_RecentFinishArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommUserAchievementRes__storage_, recentFinishArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommUserAchievementRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommUserAchievementRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommUserGameScoreReq

@implementation PB3GameCommUserGameScoreReq

@dynamic playerId;

typedef struct PB3GameCommUserGameScoreReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GameCommUserGameScoreReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserGameScoreReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommUserGameScoreReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommUserGameScoreReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommUserGameScoreReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommUserGameScoreRes

@implementation PB3GameCommUserGameScoreRes

@dynamic hasPlayer, player;
@dynamic playCount;
@dynamic scoresArray, scoresArray_Count;

typedef struct PB3GameCommUserGameScoreRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t playCount;
  PB3GameCommPlayer *player;
  NSMutableArray *scoresArray;
} PB3GameCommUserGameScoreRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3GameCommUserGameScoreRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommUserGameScoreRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommUserGameScoreRes_FieldNumber_PlayCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommUserGameScoreRes__storage_, playCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scoresArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameScoreItem),
        .number = PB3GameCommUserGameScoreRes_FieldNumber_ScoresArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommUserGameScoreRes__storage_, scoresArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommUserGameScoreRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommUserGameScoreRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommGetUserInfoReq

@implementation PB3GameCommGetUserInfoReq

@dynamic playerId;
@dynamic withAchieve;

typedef struct PB3GameCommGetUserInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GameCommGetUserInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommGetUserInfoReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserInfoReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "withAchieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommGetUserInfoReq_FieldNumber_WithAchieve,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommGetUserInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommGetUserInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommGetUserInfoRes

@implementation PB3GameCommGetUserInfoRes

@dynamic hasPlayer, player;
@dynamic playCount;
@dynamic achieve;
@dynamic totalAchieve;

typedef struct PB3GameCommGetUserInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t playCount;
  int32_t achieve;
  int32_t totalAchieve;
  PB3GameCommPlayer *player;
} PB3GameCommGetUserInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommPlayer),
        .number = PB3GameCommGetUserInfoRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserInfoRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommGetUserInfoRes_FieldNumber_PlayCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserInfoRes__storage_, playCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "achieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommGetUserInfoRes_FieldNumber_Achieve,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserInfoRes__storage_, achieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalAchieve",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommGetUserInfoRes_FieldNumber_TotalAchieve,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GameCommGetUserInfoRes__storage_, totalAchieve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommGetUserInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommGetUserInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommGameIconListReq

@implementation PB3GameCommGameIconListReq


typedef struct PB3GameCommGameIconListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GameCommGameIconListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommGameIconListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GameCommGameIconListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommGameIconListRes

@implementation PB3GameCommGameIconListRes

@dynamic iconListArray, iconListArray_Count;

typedef struct PB3GameCommGameIconListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *iconListArray;
} PB3GameCommGameIconListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iconListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommGameIcon),
        .number = PB3GameCommGameIconListRes_FieldNumber_IconListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommGameIconListRes__storage_, iconListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommGameIconListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommGameIconListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FeedbackReq

@implementation PB3FeedbackReq

@dynamic content;
@dynamic imgUrlsArray, imgUrlsArray_Count;
@dynamic wayOfContact;

typedef struct PB3FeedbackReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  NSMutableArray *imgUrlsArray;
  NSString *wayOfContact;
} PB3FeedbackReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3FeedbackReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FeedbackReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgUrlsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3FeedbackReq_FieldNumber_ImgUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FeedbackReq__storage_, imgUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wayOfContact",
        .dataTypeSpecific.className = NULL,
        .number = PB3FeedbackReq_FieldNumber_WayOfContact,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FeedbackReq__storage_, wayOfContact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FeedbackReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FeedbackReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FeedbackRes

@implementation PB3FeedbackRes


typedef struct PB3FeedbackRes__storage_ {
  uint32_t _has_storage_[1];
} PB3FeedbackRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FeedbackRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FeedbackRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckInItem

@implementation PB3CheckInItem

@dynamic bonusType;
@dynamic icon;
@dynamic bonusText;
@dynamic value;
@dynamic isCheck;
@dynamic day;
@dynamic extraArray, extraArray_Count;
@dynamic isBingo;
@dynamic dayText;

typedef struct PB3CheckInItem__storage_ {
  uint32_t _has_storage_[1];
  PB3BonusType bonusType;
  int32_t value;
  int32_t day;
  NSString *icon;
  NSString *bonusText;
  NSMutableArray *extraArray;
  NSString *dayText;
} PB3CheckInItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bonusType",
        .dataTypeSpecific.enumDescFunc = PB3BonusType_EnumDescriptor,
        .number = PB3CheckInItem_FieldNumber_BonusType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, bonusType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusText",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_BonusText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, bonusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isCheck",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_IsCheck,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_Day,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extraArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CheckInItem),
        .number = PB3CheckInItem_FieldNumber_ExtraArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, extraArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isBingo",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_IsBingo,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dayText",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInItem_FieldNumber_DayText,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3CheckInItem__storage_, dayText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckInItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckInItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CheckInItem_BonusType_RawValue(PB3CheckInItem *message) {
  GPBDescriptor *descriptor = [PB3CheckInItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CheckInItem_FieldNumber_BonusType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CheckInItem_BonusType_RawValue(PB3CheckInItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CheckInItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CheckInItem_FieldNumber_BonusType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CheckInReq

@implementation PB3CheckInReq


typedef struct PB3CheckInReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckInReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckInReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckInReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckInRes

@implementation PB3CheckInRes

@dynamic listArray, listArray_Count;

typedef struct PB3CheckInRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3CheckInRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CheckInItem),
        .number = PB3CheckInRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CheckInRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckInRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckInRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckInListReq

@implementation PB3CheckInListReq


typedef struct PB3CheckInListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckInListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckInListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckInListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckInListRes

@implementation PB3CheckInListRes

@dynamic listArray, listArray_Count;
@dynamic day;
@dynamic todayIsCheck;

typedef struct PB3CheckInListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t day;
  NSMutableArray *listArray;
} PB3CheckInListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CheckInItem),
        .number = PB3CheckInListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CheckInListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInListRes_FieldNumber_Day,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CheckInListRes__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "todayIsCheck",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckInListRes_FieldNumber_TodayIsCheck,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckInListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckInListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReceiveMissionBonusReq

@implementation PB3ReceiveMissionBonusReq

@dynamic missId;
@dynamic missClass;

typedef struct PB3ReceiveMissionBonusReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t missId;
  PB3AppMissionClass missClass;
} PB3ReceiveMissionBonusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveMissionBonusReq_FieldNumber_MissId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReceiveMissionBonusReq__storage_, missId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "missClass",
        .dataTypeSpecific.enumDescFunc = PB3AppMissionClass_EnumDescriptor,
        .number = PB3ReceiveMissionBonusReq_FieldNumber_MissClass,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReceiveMissionBonusReq__storage_, missClass),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceiveMissionBonusReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReceiveMissionBonusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReceiveMissionBonusReq_MissClass_RawValue(PB3ReceiveMissionBonusReq *message) {
  GPBDescriptor *descriptor = [PB3ReceiveMissionBonusReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReceiveMissionBonusReq_FieldNumber_MissClass];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReceiveMissionBonusReq_MissClass_RawValue(PB3ReceiveMissionBonusReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReceiveMissionBonusReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReceiveMissionBonusReq_FieldNumber_MissClass];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReceiveMissionBonusRes

@implementation PB3ReceiveMissionBonusRes

@dynamic value;
@dynamic icon;
@dynamic bonusText;

typedef struct PB3ReceiveMissionBonusRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *icon;
  NSString *bonusText;
} PB3ReceiveMissionBonusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveMissionBonusRes_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReceiveMissionBonusRes__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveMissionBonusRes_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReceiveMissionBonusRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusText",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveMissionBonusRes_FieldNumber_BonusText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ReceiveMissionBonusRes__storage_, bonusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceiveMissionBonusRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReceiveMissionBonusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetPlayerRegionReq

@implementation PB3SetPlayerRegionReq

@dynamic region;

typedef struct PB3SetPlayerRegionReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *region;
} PB3SetPlayerRegionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "region",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetPlayerRegionReq_FieldNumber_Region,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetPlayerRegionReq__storage_, region),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetPlayerRegionReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetPlayerRegionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetPlayerRegionRes

@implementation PB3SetPlayerRegionRes


typedef struct PB3SetPlayerRegionRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetPlayerRegionRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetPlayerRegionRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetPlayerRegionRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateFcmDeviceTokenReq

@implementation PB3UpdateFcmDeviceTokenReq

@dynamic token;

typedef struct PB3UpdateFcmDeviceTokenReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} PB3UpdateFcmDeviceTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateFcmDeviceTokenReq_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateFcmDeviceTokenReq__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateFcmDeviceTokenReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateFcmDeviceTokenReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateFcmDeviceTokenRes

@implementation PB3UpdateFcmDeviceTokenRes


typedef struct PB3UpdateFcmDeviceTokenRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdateFcmDeviceTokenRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateFcmDeviceTokenRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdateFcmDeviceTokenRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginReportReq

@implementation PB3LoginReportReq


typedef struct PB3LoginReportReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LoginReportReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginReportReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LoginReportReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginReportRes

@implementation PB3LoginReportRes


typedef struct PB3LoginReportRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LoginReportRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginReportRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LoginReportRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerPhoneLoginReq

@implementation PB3GetPlayerPhoneLoginReq

@dynamic phone;
@dynamic date;

typedef struct PB3GetPlayerPhoneLoginReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
  NSString *date;
} PB3GetPlayerPhoneLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerPhoneLoginReq_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPlayerPhoneLoginReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerPhoneLoginReq_FieldNumber_Date,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPlayerPhoneLoginReq__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerPhoneLoginReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerPhoneLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerPhoneLoginRes

@implementation PB3GetPlayerPhoneLoginRes

@dynamic isLogin;

typedef struct PB3GetPlayerPhoneLoginRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetPlayerPhoneLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isLogin",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerPhoneLoginRes_FieldNumber_IsLogin,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerPhoneLoginRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerPhoneLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WarningData

@implementation PB3WarningData

@dynamic id_p;
@dynamic msg;

typedef struct PB3WarningData__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
  int64_t id_p;
} PB3WarningData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WarningData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WarningData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3WarningData_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WarningData__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WarningData class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WarningData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AchieveHint

@implementation PB3AchieveHint

@dynamic id_p;
@dynamic gameId;
@dynamic achieveId;
@dynamic icon;
@dynamic title;
@dynamic desc;
@dynamic weight;

typedef struct PB3AchieveHint__storage_ {
  uint32_t _has_storage_[1];
  int32_t gameId;
  int32_t achieveId;
  int32_t weight;
  NSString *icon;
  NSString *title;
  NSString *desc;
  int64_t id_p;
} PB3AchieveHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "achieveId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_AchieveId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, achieveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_Desc,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3AchieveHint_FieldNumber_Weight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AchieveHint__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AchieveHint class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AchieveHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FetchWarningDialogReq

@implementation PB3FetchWarningDialogReq


typedef struct PB3FetchWarningDialogReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FetchWarningDialogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchWarningDialogReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FetchWarningDialogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FetchWarningDialogRes

@implementation PB3FetchWarningDialogRes

@dynamic itemsArray, itemsArray_Count;
@dynamic hintsArray, hintsArray_Count;

typedef struct PB3FetchWarningDialogRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSMutableArray *hintsArray;
} PB3FetchWarningDialogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WarningData),
        .number = PB3FetchWarningDialogRes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FetchWarningDialogRes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AchieveHint),
        .number = PB3FetchWarningDialogRes_FieldNumber_HintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FetchWarningDialogRes__storage_, hintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchWarningDialogRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchWarningDialogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WarningDialogCbReq

@implementation PB3WarningDialogCbReq

@dynamic id_p;
@dynamic hintIdsArray, hintIdsArray_Count;

typedef struct PB3WarningDialogCbReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *hintIdsArray;
  int64_t id_p;
} PB3WarningDialogCbReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WarningDialogCbReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WarningDialogCbReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hintIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3WarningDialogCbReq_FieldNumber_HintIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WarningDialogCbReq__storage_, hintIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WarningDialogCbReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WarningDialogCbReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WarningDialogCbRes

@implementation PB3WarningDialogCbRes


typedef struct PB3WarningDialogCbRes__storage_ {
  uint32_t _has_storage_[1];
} PB3WarningDialogCbRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WarningDialogCbRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WarningDialogCbRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SubmitScoreFeedbackReq

@implementation PB3SubmitScoreFeedbackReq

@dynamic feedbackContent;

typedef struct PB3SubmitScoreFeedbackReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *feedbackContent;
} PB3SubmitScoreFeedbackReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "feedbackContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubmitScoreFeedbackReq_FieldNumber_FeedbackContent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SubmitScoreFeedbackReq__storage_, feedbackContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubmitScoreFeedbackReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SubmitScoreFeedbackReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SubmitScoreFeedbackRes

@implementation PB3SubmitScoreFeedbackRes


typedef struct PB3SubmitScoreFeedbackRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SubmitScoreFeedbackRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubmitScoreFeedbackRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SubmitScoreFeedbackRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetJumpPageLinkConfReq

@implementation PB3GetJumpPageLinkConfReq

@dynamic jumpPageLinkListArray, jumpPageLinkListArray_Count;

typedef struct PB3GetJumpPageLinkConfReq__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *jumpPageLinkListArray;
} PB3GetJumpPageLinkConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "jumpPageLinkListArray",
        .dataTypeSpecific.enumDescFunc = PB3JumpPageLinkType_EnumDescriptor,
        .number = PB3GetJumpPageLinkConfReq_FieldNumber_JumpPageLinkListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetJumpPageLinkConfReq__storage_, jumpPageLinkListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetJumpPageLinkConfReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetJumpPageLinkConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetJumpPageLinkConfRes

@implementation PB3GetJumpPageLinkConfRes

@dynamic jumpPageLinkMap, jumpPageLinkMap_Count;

typedef struct PB3GetJumpPageLinkConfRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *jumpPageLinkMap;
} PB3GetJumpPageLinkConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "jumpPageLinkMap",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetJumpPageLinkConfRes_FieldNumber_JumpPageLinkMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetJumpPageLinkConfRes__storage_, jumpPageLinkMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetJumpPageLinkConfRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetJumpPageLinkConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPresetIconsReq

@implementation PB3GetPresetIconsReq


typedef struct PB3GetPresetIconsReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetPresetIconsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPresetIconsReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetPresetIconsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPresetIconsRes

@implementation PB3GetPresetIconsRes

@dynamic iconListArray, iconListArray_Count;

typedef struct PB3GetPresetIconsRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *iconListArray;
} PB3GetPresetIconsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iconListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPresetIconsRes_FieldNumber_IconListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetPresetIconsRes__storage_, iconListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPresetIconsRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPresetIconsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameScoreDetailsReq

@implementation PB3GameScoreDetailsReq

@dynamic gameId;
@dynamic index;
@dynamic pageSize;

typedef struct PB3GameScoreDetailsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t gameId;
  int32_t pageSize;
  int64_t index;
} PB3GameScoreDetailsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailsReq_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailsReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailsReq_FieldNumber_PageSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameScoreDetailsReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameScoreDetailsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameScoreDetailItem

@implementation PB3GameScoreDetailItem

@dynamic medalType;
@dynamic score;
@dynamic scoreType;
@dynamic content;
@dynamic startAt;
@dynamic playTime;

typedef struct PB3GameScoreDetailItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t medalType;
  int32_t score;
  int32_t scoreType;
  NSString *content;
  NSString *playTime;
  int64_t startAt;
} PB3GameScoreDetailItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "medalType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_MedalType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, medalType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_Score,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scoreType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_ScoreType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, scoreType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_StartAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, startAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailItem_FieldNumber_PlayTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailItem__storage_, playTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameScoreDetailItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameScoreDetailItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TextItem

@implementation PB3TextItem

@dynamic name;
@dynamic value;
@dynamic valueType;

typedef struct PB3TextItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t valueType;
  NSString *name;
  NSString *value;
} PB3TextItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3TextItem_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TextItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3TextItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TextItem__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valueType",
        .dataTypeSpecific.className = NULL,
        .number = PB3TextItem_FieldNumber_ValueType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TextItem__storage_, valueType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TextItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TextItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameScoreDetailsRes

@implementation PB3GameScoreDetailsRes

@dynamic total;
@dynamic hasGameIcon, gameIcon;
@dynamic textsArray, textsArray_Count;
@dynamic nextIndex;
@dynamic itemsArray, itemsArray_Count;

typedef struct PB3GameScoreDetailsRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  PB3GameCommGameIcon *gameIcon;
  NSMutableArray *textsArray;
  NSMutableArray *itemsArray;
  int64_t nextIndex;
} PB3GameScoreDetailsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailsRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameIcon",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommGameIcon),
        .number = PB3GameScoreDetailsRes_FieldNumber_GameIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsRes__storage_, gameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TextItem),
        .number = PB3GameScoreDetailsRes_FieldNumber_TextsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsRes__storage_, textsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameScoreDetailsRes_FieldNumber_NextIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameScoreDetailItem),
        .number = PB3GameScoreDetailsRes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameScoreDetailsRes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameScoreDetailsRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameScoreDetailsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MissionItem

@implementation PB3MissionItem

@dynamic missType;
@dynamic bonusType;
@dynamic bonusText;
@dynamic missText;
@dynamic value;
@dynamic total;
@dynamic progress;
@dynamic status;
@dynamic icon;
@dynamic missId;
@dynamic router;
@dynamic sortWeight;

typedef struct PB3MissionItem__storage_ {
  uint32_t _has_storage_[1];
  PB3MissionType missType;
  PB3BonusType bonusType;
  int32_t value;
  int32_t total;
  int32_t progress;
  int32_t missId;
  int32_t sortWeight;
  NSString *bonusText;
  NSString *missText;
  NSString *icon;
  NSString *router;
} PB3MissionItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missType",
        .dataTypeSpecific.enumDescFunc = PB3MissionType_EnumDescriptor,
        .number = PB3MissionItem_FieldNumber_MissType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, missType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bonusType",
        .dataTypeSpecific.enumDescFunc = PB3BonusType_EnumDescriptor,
        .number = PB3MissionItem_FieldNumber_BonusType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, bonusType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bonusText",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_BonusText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, bonusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "missText",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_MissText,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, missText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Total,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "progress",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Progress,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, progress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Status,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Icon,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "missId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_MissId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, missId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_Router,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sortWeight",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionItem_FieldNumber_SortWeight,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3MissionItem__storage_, sortWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MissionItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MissionItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MissionItem_MissType_RawValue(PB3MissionItem *message) {
  GPBDescriptor *descriptor = [PB3MissionItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MissionItem_FieldNumber_MissType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MissionItem_MissType_RawValue(PB3MissionItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MissionItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MissionItem_FieldNumber_MissType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3MissionItem_BonusType_RawValue(PB3MissionItem *message) {
  GPBDescriptor *descriptor = [PB3MissionItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MissionItem_FieldNumber_BonusType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MissionItem_BonusType_RawValue(PB3MissionItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MissionItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MissionItem_FieldNumber_BonusType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FetchMissionListReq

@implementation PB3FetchMissionListReq

@dynamic missClass;

typedef struct PB3FetchMissionListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3AppMissionClass missClass;
} PB3FetchMissionListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missClass",
        .dataTypeSpecific.enumDescFunc = PB3AppMissionClass_EnumDescriptor,
        .number = PB3FetchMissionListReq_FieldNumber_MissClass,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchMissionListReq__storage_, missClass),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchMissionListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchMissionListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FetchMissionListReq_MissClass_RawValue(PB3FetchMissionListReq *message) {
  GPBDescriptor *descriptor = [PB3FetchMissionListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FetchMissionListReq_FieldNumber_MissClass];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FetchMissionListReq_MissClass_RawValue(PB3FetchMissionListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FetchMissionListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FetchMissionListReq_FieldNumber_MissClass];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FetchMissionListRes

@implementation PB3FetchMissionListRes

@dynamic itemArray, itemArray_Count;

typedef struct PB3FetchMissionListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB3FetchMissionListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MissionItem),
        .number = PB3FetchMissionListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FetchMissionListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchMissionListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchMissionListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MissionUnReceiveRedPointReq

@implementation PB3MissionUnReceiveRedPointReq


typedef struct PB3MissionUnReceiveRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3MissionUnReceiveRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MissionUnReceiveRedPointReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MissionUnReceiveRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MissionUnReceiveRedPointRes

@implementation PB3MissionUnReceiveRedPointRes

@dynamic count;

typedef struct PB3MissionUnReceiveRedPointRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} PB3MissionUnReceiveRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PB3MissionUnReceiveRedPointRes_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MissionUnReceiveRedPointRes__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MissionUnReceiveRedPointRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MissionUnReceiveRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ShareAppCbReq

@implementation PB3ShareAppCbReq


typedef struct PB3ShareAppCbReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ShareAppCbReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ShareAppCbReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ShareAppCbReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ShareAppCbRes

@implementation PB3ShareAppCbRes


typedef struct PB3ShareAppCbRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ShareAppCbRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ShareAppCbRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ShareAppCbRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserIPAddrReq

@implementation PB3GetUserIPAddrReq

@dynamic playerId;

typedef struct PB3GetUserIPAddrReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetUserIPAddrReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetUserIPAddrReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserIPAddrReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserIPAddrReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserIPAddrRes

@implementation PB3GetUserIPAddrRes

@dynamic nation;
@dynamic province;
@dynamic city;
@dynamic ip;
@dynamic isWhilte;

typedef struct PB3GetUserIPAddrRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *nation;
  NSString *province;
  NSString *city;
  NSString *ip;
} PB3GetUserIPAddrRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nation",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrRes_FieldNumber_Nation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetUserIPAddrRes__storage_, nation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrRes_FieldNumber_Province,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetUserIPAddrRes__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrRes_FieldNumber_City,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetUserIPAddrRes__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrRes_FieldNumber_Ip,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetUserIPAddrRes__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isWhilte",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIPAddrRes_FieldNumber_IsWhilte,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserIPAddrRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserIPAddrRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserEventReq

@implementation PB3UserEventReq

@dynamic typ;
@dynamic targetId;

typedef struct PB3UserEventReq__storage_ {
  uint32_t _has_storage_[1];
  PB3PlayerEventType typ;
  int64_t targetId;
} PB3UserEventReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "typ",
        .dataTypeSpecific.enumDescFunc = PB3PlayerEventType_EnumDescriptor,
        .number = PB3UserEventReq_FieldNumber_Typ,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserEventReq__storage_, typ),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserEventReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserEventReq__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserEventReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserEventReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserEventReq_Typ_RawValue(PB3UserEventReq *message) {
  GPBDescriptor *descriptor = [PB3UserEventReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserEventReq_FieldNumber_Typ];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserEventReq_Typ_RawValue(PB3UserEventReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserEventReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserEventReq_FieldNumber_Typ];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserEventRes

@implementation PB3UserEventRes


typedef struct PB3UserEventRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UserEventRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserEventRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserEventRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MyAwardInfoReq

@implementation PB3MyAwardInfoReq

@dynamic playerId;

typedef struct PB3MyAwardInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3MyAwardInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MyAwardInfoReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MyAwardInfoReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MyAwardInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MyAwardInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MyAwardInfoRes

@implementation PB3MyAwardInfoRes

@dynamic invite;

typedef struct PB3MyAwardInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteAwardType invite;
} PB3MyAwardInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invite",
        .dataTypeSpecific.enumDescFunc = PB3InviteAwardType_EnumDescriptor,
        .number = PB3MyAwardInfoRes_FieldNumber_Invite,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MyAwardInfoRes__storage_, invite),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MyAwardInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MyAwardInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MyAwardInfoRes_Invite_RawValue(PB3MyAwardInfoRes *message) {
  GPBDescriptor *descriptor = [PB3MyAwardInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MyAwardInfoRes_FieldNumber_Invite];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MyAwardInfoRes_Invite_RawValue(PB3MyAwardInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MyAwardInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MyAwardInfoRes_FieldNumber_Invite];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviterDataReq

@implementation PB3InviterDataReq


typedef struct PB3InviterDataReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InviterDataReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterDataReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InviterDataReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterDataRes

@implementation PB3InviterDataRes

@dynamic sucNum;
@dynamic regAwardGold;
@dynamic chargeNum;
@dynamic chargeAwardGold;
@dynamic isShowChuzhi;
@dynamic explainImg;
@dynamic isRecommend;

typedef struct PB3InviterDataRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *explainImg;
  int64_t sucNum;
  int64_t regAwardGold;
  int64_t chargeNum;
  int64_t chargeAwardGold;
} PB3InviterDataRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sucNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_SucNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviterDataRes__storage_, sucNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "regAwardGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_RegAwardGold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviterDataRes__storage_, regAwardGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chargeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_ChargeNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviterDataRes__storage_, chargeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chargeAwardGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_ChargeAwardGold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviterDataRes__storage_, chargeAwardGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isShowChuzhi",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_IsShowChuzhi,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "explainImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_ExplainImg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3InviterDataRes__storage_, explainImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterDataRes_FieldNumber_IsRecommend,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterDataRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviterDataRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterFriend

@implementation PB3InviterFriend

@dynamic playerId;
@dynamic icon;
@dynamic name;
@dynamic inviteTime;

typedef struct PB3InviterFriend__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  NSString *name;
  int64_t playerId;
  int64_t inviteTime;
} PB3InviterFriend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFriend_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviterFriend__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFriend_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviterFriend__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFriend_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviterFriend__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFriend_FieldNumber_InviteTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviterFriend__storage_, inviteTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterFriend class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviterFriend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterFiendsListReq

@implementation PB3InviterFiendsListReq

@dynamic page;
@dynamic pageSize;

typedef struct PB3InviterFiendsListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
} PB3InviterFiendsListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFiendsListReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviterFiendsListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterFiendsListReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviterFiendsListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterFiendsListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviterFiendsListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterFiendsListRes

@implementation PB3InviterFiendsListRes

@dynamic listArray, listArray_Count;

typedef struct PB3InviterFiendsListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3InviterFiendsListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviterFriend),
        .number = PB3InviterFiendsListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviterFiendsListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterFiendsListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviterFiendsListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterIdReq

@implementation PB3InviterIdReq

@dynamic inviteId;

typedef struct PB3InviterIdReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t inviteId;
} PB3InviterIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviterIdReq_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviterIdReq__storage_, inviteId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviterIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\202\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviterIdRes

@implementation PB3InviterIdRes


typedef struct PB3InviterIdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3InviterIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviterIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InviterIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ActivateLoginInviteCodeReq

@implementation PB3ActivateLoginInviteCodeReq

@dynamic inviteCode;

typedef struct PB3ActivateLoginInviteCodeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} PB3ActivateLoginInviteCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivateLoginInviteCodeReq_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ActivateLoginInviteCodeReq__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ActivateLoginInviteCodeReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ActivateLoginInviteCodeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ActivateLoginInviteCodeRes

@implementation PB3ActivateLoginInviteCodeRes


typedef struct PB3ActivateLoginInviteCodeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ActivateLoginInviteCodeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ActivateLoginInviteCodeRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ActivateLoginInviteCodeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ConfShareInviteReq

@implementation PB3ConfShareInviteReq

@dynamic playerId;

typedef struct PB3ConfShareInviteReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3ConfShareInviteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ConfShareInviteReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ConfShareInviteReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ConfShareInviteReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ConfShareInviteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ConfShareInviteRes

@implementation PB3ConfShareInviteRes

@dynamic name;
@dynamic icon;
@dynamic type;
@dynamic amount;

typedef struct PB3ConfShareInviteRes__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteMoneyType type;
  int32_t amount;
  NSString *name;
  NSString *icon;
} PB3ConfShareInviteRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ConfShareInviteRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ConfShareInviteRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ConfShareInviteRes_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ConfShareInviteRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3ConfShareInviteRes_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ConfShareInviteRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3ConfShareInviteRes_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ConfShareInviteRes__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ConfShareInviteRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ConfShareInviteRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ConfShareInviteRes_Type_RawValue(PB3ConfShareInviteRes *message) {
  GPBDescriptor *descriptor = [PB3ConfShareInviteRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ConfShareInviteRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ConfShareInviteRes_Type_RawValue(PB3ConfShareInviteRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ConfShareInviteRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ConfShareInviteRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteInfoReq

@implementation PB3InviteInfoReq


typedef struct PB3InviteInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InviteInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InviteInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteTaskItem

@implementation PB3InviteTaskItem

@dynamic id_p;
@dynamic type;
@dynamic amount;

typedef struct PB3InviteTaskItem__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteTaskID id_p;
  PB3InviteMoneyType type;
  int32_t amount;
} PB3InviteTaskItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.enumDescFunc = PB3InviteTaskID_EnumDescriptor,
        .number = PB3InviteTaskItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteTaskItem__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3InviteTaskItem_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteTaskItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteTaskItem_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteTaskItem__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteTaskItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteTaskItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InviteTaskItem_Id_p_RawValue(PB3InviteTaskItem *message) {
  GPBDescriptor *descriptor = [PB3InviteTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteTaskItem_FieldNumber_Id_p];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteTaskItem_Id_p_RawValue(PB3InviteTaskItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteTaskItem_FieldNumber_Id_p];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3InviteTaskItem_Type_RawValue(PB3InviteTaskItem *message) {
  GPBDescriptor *descriptor = [PB3InviteTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteTaskItem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteTaskItem_Type_RawValue(PB3InviteTaskItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteTaskItem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteInfoRes

@implementation PB3InviteInfoRes

@dynamic type;
@dynamic amount;
@dynamic isBindPhone;
@dynamic isAward;
@dynamic storeRate;
@dynamic storeMinAmount;
@dynamic dayInviteCount;
@dynamic inviteAmount;
@dynamic listArray, listArray_Count;

typedef struct PB3InviteInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteMoneyType type;
  int32_t amount;
  int32_t storeRate;
  int32_t storeMinAmount;
  int32_t dayInviteCount;
  int32_t inviteAmount;
  NSMutableArray *listArray;
} PB3InviteInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3InviteInfoRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isBindPhone",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_IsBindPhone,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAward",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_IsAward,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "storeRate",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_StoreRate,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, storeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "storeMinAmount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_StoreMinAmount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, storeMinAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dayInviteCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_DayInviteCount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, dayInviteCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteAmount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteInfoRes_FieldNumber_InviteAmount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, inviteAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviteTaskItem),
        .number = PB3InviteInfoRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviteInfoRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InviteInfoRes_Type_RawValue(PB3InviteInfoRes *message) {
  GPBDescriptor *descriptor = [PB3InviteInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteInfoRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteInfoRes_Type_RawValue(PB3InviteInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteInfoRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteRecordReq

@implementation PB3InviteRecordReq


typedef struct PB3InviteRecordReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InviteRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteRecordReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InviteRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteRecordItem

@implementation PB3InviteRecordItem

@dynamic name;
@dynamic amount;
@dynamic count;
@dynamic type;

typedef struct PB3InviteRecordItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t amount;
  int32_t count;
  PB3InviteMoneyType type;
  NSString *name;
} PB3InviteRecordItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteRecordItem_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteRecordItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteRecordItem_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteRecordItem__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteRecordItem_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteRecordItem__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3InviteRecordItem_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviteRecordItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteRecordItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteRecordItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InviteRecordItem_Type_RawValue(PB3InviteRecordItem *message) {
  GPBDescriptor *descriptor = [PB3InviteRecordItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteRecordItem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteRecordItem_Type_RawValue(PB3InviteRecordItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteRecordItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteRecordItem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteRecordRes

@implementation PB3InviteRecordRes

@dynamic listArray, listArray_Count;

typedef struct PB3InviteRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3InviteRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviteRecordItem),
        .number = PB3InviteRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviteRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteRecordRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteFriendReq

@implementation PB3InviteFriendReq

@dynamic page;

typedef struct PB3InviteFriendReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
} PB3InviteFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteFriendReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteFriendReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteFriendItem

@implementation PB3InviteFriendItem

@dynamic playerId;
@dynamic phone;
@dynamic name;
@dynamic icon;
@dynamic listArray, listArray_Count;

typedef struct PB3InviteFriendItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *phone;
  NSString *name;
  NSString *icon;
  NSMutableArray *listArray;
  int64_t playerId;
} PB3InviteFriendItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendItem_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteFriendItem__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendItem_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteFriendItem__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendItem_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteFriendItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendItem_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviteFriendItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviteFriendTaskItem),
        .number = PB3InviteFriendItem_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviteFriendItem__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteFriendItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteFriendItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteFriendTaskItem

@implementation PB3InviteFriendTaskItem

@dynamic taskId;
@dynamic type;
@dynamic taskState;
@dynamic state;
@dynamic amount;
@dynamic name;

typedef struct PB3InviteFriendTaskItem__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteTaskID taskId;
  PB3InviteMoneyType type;
  int32_t taskState;
  int32_t state;
  int32_t amount;
  NSString *name;
} PB3InviteFriendTaskItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "taskId",
        .dataTypeSpecific.enumDescFunc = PB3InviteTaskID_EnumDescriptor,
        .number = PB3InviteFriendTaskItem_FieldNumber_TaskId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, taskId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3InviteFriendTaskItem_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "taskState",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendTaskItem_FieldNumber_TaskState,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, taskState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendTaskItem_FieldNumber_State,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendTaskItem_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendTaskItem_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3InviteFriendTaskItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteFriendTaskItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteFriendTaskItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InviteFriendTaskItem_TaskId_RawValue(PB3InviteFriendTaskItem *message) {
  GPBDescriptor *descriptor = [PB3InviteFriendTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendTaskItem_FieldNumber_TaskId];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteFriendTaskItem_TaskId_RawValue(PB3InviteFriendTaskItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteFriendTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendTaskItem_FieldNumber_TaskId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3InviteFriendTaskItem_Type_RawValue(PB3InviteFriendTaskItem *message) {
  GPBDescriptor *descriptor = [PB3InviteFriendTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendTaskItem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteFriendTaskItem_Type_RawValue(PB3InviteFriendTaskItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteFriendTaskItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendTaskItem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteFriendRes

@implementation PB3InviteFriendRes

@dynamic listArray, listArray_Count;
@dynamic amount;
@dynamic count;
@dynamic type;

typedef struct PB3InviteFriendRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t amount;
  int32_t count;
  PB3InviteMoneyType type;
  NSMutableArray *listArray;
} PB3InviteFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviteFriendItem),
        .number = PB3InviteFriendRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviteFriendRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendRes_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteFriendRes__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteFriendRes_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteFriendRes__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3InviteMoneyType_EnumDescriptor,
        .number = PB3InviteFriendRes_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteFriendRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteFriendRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InviteFriendRes_Type_RawValue(PB3InviteFriendRes *message) {
  GPBDescriptor *descriptor = [PB3InviteFriendRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InviteFriendRes_Type_RawValue(PB3InviteFriendRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InviteFriendRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InviteFriendRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InviteAwardReq

@implementation PB3InviteAwardReq

@dynamic page;
@dynamic pageSize;

typedef struct PB3InviteAwardReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
} PB3InviteAwardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteAwardReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteAwardReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteAwardReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteAwardReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteAwardItem

@implementation PB3InviteAwardItem

@dynamic inviteCode;
@dynamic inviteAmount;
@dynamic playerId;
@dynamic playerName;
@dynamic playerIcon;
@dynamic createAt;

typedef struct PB3InviteAwardItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t inviteAmount;
  NSString *inviteCode;
  NSString *playerName;
  NSString *playerIcon;
  int64_t playerId;
  int64_t createAt;
} PB3InviteAwardItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteAmount",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_InviteAmount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, inviteAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_PlayerName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_PlayerIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, playerIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardItem_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3InviteAwardItem__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteAwardItem class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteAwardItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteAwardRes

@implementation PB3InviteAwardRes

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PB3InviteAwardRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PB3InviteAwardRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InviteAwardItem),
        .number = PB3InviteAwardRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InviteAwardRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteAwardRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteAwardRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteAwardRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteAwardRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReceiveInviteAwardReq

@implementation PB3ReceiveInviteAwardReq

@dynamic phone;
@dynamic taskId;
@dynamic type;

typedef struct PB3ReceiveInviteAwardReq__storage_ {
  uint32_t _has_storage_[1];
  PB3InviteTaskID taskId;
  int32_t type;
  NSString *phone;
} PB3ReceiveInviteAwardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveInviteAwardReq_FieldNumber_Phone,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReceiveInviteAwardReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "taskId",
        .dataTypeSpecific.enumDescFunc = PB3InviteTaskID_EnumDescriptor,
        .number = PB3ReceiveInviteAwardReq_FieldNumber_TaskId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReceiveInviteAwardReq__storage_, taskId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveInviteAwardReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ReceiveInviteAwardReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceiveInviteAwardReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReceiveInviteAwardReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReceiveInviteAwardReq_TaskId_RawValue(PB3ReceiveInviteAwardReq *message) {
  GPBDescriptor *descriptor = [PB3ReceiveInviteAwardReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReceiveInviteAwardReq_FieldNumber_TaskId];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReceiveInviteAwardReq_TaskId_RawValue(PB3ReceiveInviteAwardReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReceiveInviteAwardReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReceiveInviteAwardReq_FieldNumber_TaskId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReceiveInviteAwardRes

@implementation PB3ReceiveInviteAwardRes

@dynamic code;

typedef struct PB3ReceiveInviteAwardRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} PB3ReceiveInviteAwardRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReceiveInviteAwardRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReceiveInviteAwardRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReceiveInviteAwardRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReceiveInviteAwardRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NeteaseTokenReq

@implementation PB3NeteaseTokenReq


typedef struct PB3NeteaseTokenReq__storage_ {
  uint32_t _has_storage_[1];
} PB3NeteaseTokenReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NeteaseTokenReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3NeteaseTokenReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NeteaseTokenRes

@implementation PB3NeteaseTokenRes

@dynamic token;
@dynamic expireAt;
@dynamic deviceType;

typedef struct PB3NeteaseTokenRes__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *token;
  int64_t expireAt;
} PB3NeteaseTokenRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PB3NeteaseTokenRes_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NeteaseTokenRes__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expireAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3NeteaseTokenRes_FieldNumber_ExpireAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3NeteaseTokenRes__storage_, expireAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3NeteaseTokenRes_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3NeteaseTokenRes__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NeteaseTokenRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NeteaseTokenRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3NeteaseTokenRes_DeviceType_RawValue(PB3NeteaseTokenRes *message) {
  GPBDescriptor *descriptor = [PB3NeteaseTokenRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NeteaseTokenRes_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3NeteaseTokenRes_DeviceType_RawValue(PB3NeteaseTokenRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3NeteaseTokenRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3NeteaseTokenRes_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CancelAccountCheckReq

@implementation PB3CancelAccountCheckReq

@dynamic playerId;

typedef struct PB3CancelAccountCheckReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3CancelAccountCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountCheckReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CancelAccountCheckReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelAccountCheckReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CancelAccountCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CancelAccountCheckRes

@implementation PB3CancelAccountCheckRes


typedef struct PB3CancelAccountCheckRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CancelAccountCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelAccountCheckRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CancelAccountCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCancelAccountCheckReq

@implementation PB3GetCancelAccountCheckReq

@dynamic playerId;

typedef struct PB3GetCancelAccountCheckReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetCancelAccountCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCancelAccountCheckReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCancelAccountCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetCancelAccountCheckRes

@implementation PB3GetCancelAccountCheckRes

@dynamic notPassArray, notPassArray_Count;
@dynamic applyStatus;
@dynamic isPopupWindow;
@dynamic isOldAccount;
@dynamic registerChannel;
@dynamic userBindType;
@dynamic country;
@dynamic phone;
@dynamic email;

typedef struct PB3GetCancelAccountCheckRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RegisterChannel registerChannel;
  PB3UserBindType userBindType;
  uint32_t country;
  GPBEnumArray *notPassArray;
  NSString *phone;
  NSString *email;
} PB3GetCancelAccountCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notPassArray",
        .dataTypeSpecific.enumDescFunc = PB3NotPassType_EnumDescriptor,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_NotPassArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, notPassArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "applyStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_ApplyStatus,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isPopupWindow",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_IsPopupWindow,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isOldAccount",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_IsOldAccount,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "registerChannel",
        .dataTypeSpecific.enumDescFunc = PB3RegisterChannel_EnumDescriptor,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_RegisterChannel,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, registerChannel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userBindType",
        .dataTypeSpecific.enumDescFunc = PB3UserBindType_EnumDescriptor,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_UserBindType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, userBindType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_Country,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_Phone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetCancelAccountCheckRes_FieldNumber_Email,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3GetCancelAccountCheckRes__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetCancelAccountCheckRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetCancelAccountCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetCancelAccountCheckRes_RegisterChannel_RawValue(PB3GetCancelAccountCheckRes *message) {
  GPBDescriptor *descriptor = [PB3GetCancelAccountCheckRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetCancelAccountCheckRes_FieldNumber_RegisterChannel];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetCancelAccountCheckRes_RegisterChannel_RawValue(PB3GetCancelAccountCheckRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetCancelAccountCheckRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetCancelAccountCheckRes_FieldNumber_RegisterChannel];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3GetCancelAccountCheckRes_UserBindType_RawValue(PB3GetCancelAccountCheckRes *message) {
  GPBDescriptor *descriptor = [PB3GetCancelAccountCheckRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetCancelAccountCheckRes_FieldNumber_UserBindType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetCancelAccountCheckRes_UserBindType_RawValue(PB3GetCancelAccountCheckRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetCancelAccountCheckRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetCancelAccountCheckRes_FieldNumber_UserBindType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CancelAccountApplyReq

@implementation PB3CancelAccountApplyReq

@dynamic country;
@dynamic phone;
@dynamic code;
@dynamic type;
@dynamic email;

typedef struct PB3CancelAccountApplyReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t country;
  PB3VerifyType type;
  NSString *phone;
  NSString *code;
  NSString *email;
} PB3CancelAccountApplyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyReq_FieldNumber_Country,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyReq__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyReq_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyReq__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyReq_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3VerifyType_EnumDescriptor,
        .number = PB3CancelAccountApplyReq_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyReq_FieldNumber_Email,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyReq__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelAccountApplyReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CancelAccountApplyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CancelAccountApplyReq_Type_RawValue(PB3CancelAccountApplyReq *message) {
  GPBDescriptor *descriptor = [PB3CancelAccountApplyReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CancelAccountApplyReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CancelAccountApplyReq_Type_RawValue(PB3CancelAccountApplyReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CancelAccountApplyReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CancelAccountApplyReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CancelAccountApplyRes

@implementation PB3CancelAccountApplyRes

@dynamic applyStatus;
@dynamic expectCancelTime;

typedef struct PB3CancelAccountApplyRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t expectCancelTime;
} PB3CancelAccountApplyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyRes_FieldNumber_ApplyStatus,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expectCancelTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CancelAccountApplyRes_FieldNumber_ExpectCancelTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CancelAccountApplyRes__storage_, expectCancelTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CancelAccountApplyRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CancelAccountApplyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginAppleReq

@implementation PB3LoginAppleReq

@dynamic identityToken;
@dynamic authorizationCode;

typedef struct PB3LoginAppleReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *identityToken;
  NSString *authorizationCode;
} PB3LoginAppleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginAppleReq_FieldNumber_IdentityToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginAppleReq__storage_, identityToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authorizationCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginAppleReq_FieldNumber_AuthorizationCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LoginAppleReq__storage_, authorizationCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginAppleReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginAppleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginWechatReq

@implementation PB3LoginWechatReq

@dynamic accessToken;

typedef struct PB3LoginWechatReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *accessToken;
} PB3LoginWechatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginWechatReq_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginWechatReq__storage_, accessToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginWechatReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginWechatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginGoogleReq

@implementation PB3LoginGoogleReq

@dynamic idToken;

typedef struct PB3LoginGoogleReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *idToken;
} PB3LoginGoogleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginGoogleReq_FieldNumber_IdToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginGoogleReq__storage_, idToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginGoogleReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginGoogleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoginFacebookReq

@implementation PB3LoginFacebookReq

@dynamic appid;
@dynamic accessToken;

typedef struct PB3LoginFacebookReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *appid;
  NSString *accessToken;
} PB3LoginFacebookReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appid",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginFacebookReq_FieldNumber_Appid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoginFacebookReq__storage_, appid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoginFacebookReq_FieldNumber_AccessToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LoginFacebookReq__storage_, accessToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoginFacebookReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoginFacebookReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VerifyCancelAccountRes

@implementation PB3VerifyCancelAccountRes

@dynamic applyStatus;
@dynamic expectCancelTime;

typedef struct PB3VerifyCancelAccountRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t expectCancelTime;
} PB3VerifyCancelAccountRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3VerifyCancelAccountRes_FieldNumber_ApplyStatus,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expectCancelTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3VerifyCancelAccountRes_FieldNumber_ExpectCancelTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3VerifyCancelAccountRes__storage_, expectCancelTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VerifyCancelAccountRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VerifyCancelAccountRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EnterAgentCenterReq

@implementation PB3EnterAgentCenterReq


typedef struct PB3EnterAgentCenterReq__storage_ {
  uint32_t _has_storage_[1];
} PB3EnterAgentCenterReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EnterAgentCenterReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3EnterAgentCenterReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EnterAgentCenterRes

@implementation PB3EnterAgentCenterRes

@dynamic agentGold;
@dynamic presentGold;

typedef struct PB3EnterAgentCenterRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t agentGold;
  int64_t presentGold;
} PB3EnterAgentCenterRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3EnterAgentCenterRes_FieldNumber_AgentGold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EnterAgentCenterRes__storage_, agentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "presentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3EnterAgentCenterRes_FieldNumber_PresentGold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3EnterAgentCenterRes__storage_, presentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EnterAgentCenterRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EnterAgentCenterRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AgentDeliverRecord

@implementation PB3AgentDeliverRecord

@dynamic atTime;
@dynamic type;
@dynamic playerId;
@dynamic playerName;
@dynamic agentGold;

typedef struct PB3AgentDeliverRecord__storage_ {
  uint32_t _has_storage_[1];
  PB3AgentType type;
  NSString *playerName;
  int64_t atTime;
  int64_t playerId;
  int64_t agentGold;
} PB3AgentDeliverRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "atTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgentDeliverRecord_FieldNumber_AtTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AgentDeliverRecord__storage_, atTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AgentType_EnumDescriptor,
        .number = PB3AgentDeliverRecord_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AgentDeliverRecord__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgentDeliverRecord_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AgentDeliverRecord__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgentDeliverRecord_FieldNumber_PlayerName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AgentDeliverRecord__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgentDeliverRecord_FieldNumber_AgentGold,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AgentDeliverRecord__storage_, agentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AgentDeliverRecord class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AgentDeliverRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AgentDeliverRecord_Type_RawValue(PB3AgentDeliverRecord *message) {
  GPBDescriptor *descriptor = [PB3AgentDeliverRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AgentDeliverRecord_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AgentDeliverRecord_Type_RawValue(PB3AgentDeliverRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AgentDeliverRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AgentDeliverRecord_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FetchDeliverRecordReq

@implementation PB3FetchDeliverRecordReq

@dynamic page;
@dynamic pageSize;
@dynamic beginTime;
@dynamic endTime;

typedef struct PB3FetchDeliverRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t page;
  int64_t pageSize;
  int64_t beginTime;
  int64_t endTime;
} PB3FetchDeliverRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "beginTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordReq_FieldNumber_BeginTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordReq__storage_, beginTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordReq_FieldNumber_EndTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchDeliverRecordReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchDeliverRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FetchDeliverRecordRes

@implementation PB3FetchDeliverRecordRes

@dynamic totalChargeGold;
@dynamic totalDeliverGold;
@dynamic totalLeftGold;
@dynamic chargeGold;
@dynamic deliverGold;
@dynamic recordsArray, recordsArray_Count;
@dynamic totalCount;
@dynamic totalPresentGold;
@dynamic totalLeftPresentGold;
@dynamic presentGold;

typedef struct PB3FetchDeliverRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *recordsArray;
  int64_t totalChargeGold;
  int64_t totalDeliverGold;
  int64_t totalLeftGold;
  int64_t chargeGold;
  int64_t deliverGold;
  int64_t totalCount;
  int64_t totalPresentGold;
  int64_t totalLeftPresentGold;
  int64_t presentGold;
} PB3FetchDeliverRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalChargeGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalChargeGold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalChargeGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalDeliverGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalDeliverGold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalDeliverGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalLeftGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalLeftGold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalLeftGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chargeGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_ChargeGold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, chargeGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deliverGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_DeliverGold,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, deliverGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "recordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AgentDeliverRecord),
        .number = PB3FetchDeliverRecordRes_FieldNumber_RecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, recordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalPresentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalPresentGold,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalPresentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalLeftPresentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_TotalLeftPresentGold,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, totalLeftPresentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "presentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchDeliverRecordRes_FieldNumber_PresentGold,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3FetchDeliverRecordRes__storage_, presentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchDeliverRecordRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchDeliverRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeliverAgentGoldReq

@implementation PB3DeliverAgentGoldReq

@dynamic deliverPlayerId;
@dynamic deliverGold;

typedef struct PB3DeliverAgentGoldReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t deliverPlayerId;
  int64_t deliverGold;
} PB3DeliverAgentGoldReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deliverPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeliverAgentGoldReq_FieldNumber_DeliverPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeliverAgentGoldReq__storage_, deliverPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deliverGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeliverAgentGoldReq_FieldNumber_DeliverGold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DeliverAgentGoldReq__storage_, deliverGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeliverAgentGoldReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeliverAgentGoldReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DeliverAgentGoldRes

@implementation PB3DeliverAgentGoldRes

@dynamic agentGold;
@dynamic presentGold;

typedef struct PB3DeliverAgentGoldRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t agentGold;
  int64_t presentGold;
} PB3DeliverAgentGoldRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeliverAgentGoldRes_FieldNumber_AgentGold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DeliverAgentGoldRes__storage_, agentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "presentGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3DeliverAgentGoldRes_FieldNumber_PresentGold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3DeliverAgentGoldRes__storage_, presentGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DeliverAgentGoldRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DeliverAgentGoldRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListShortIdReq

@implementation PB3ListShortIdReq


typedef struct PB3ListShortIdReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ListShortIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListShortIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ListShortIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ShortId

@implementation PB3ShortId

@dynamic shortId;

typedef struct PB3ShortId__storage_ {
  uint32_t _has_storage_[1];
  int64_t shortId;
} PB3ShortId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ShortId_FieldNumber_ShortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ShortId__storage_, shortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ShortId class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ShortId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListShortIdRes

@implementation PB3ListShortIdRes

@dynamic listArray, listArray_Count;

typedef struct PB3ListShortIdRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListShortIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ShortId),
        .number = PB3ListShortIdRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListShortIdRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListShortIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListShortIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetShortIdReq

@implementation PB3SetShortIdReq

@dynamic shortId;
@dynamic oldShortId;

typedef struct PB3SetShortIdReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t shortId;
  int64_t oldShortId;
} PB3SetShortIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetShortIdReq_FieldNumber_ShortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetShortIdReq__storage_, shortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "oldShortId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetShortIdReq_FieldNumber_OldShortId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SetShortIdReq__storage_, oldShortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetShortIdReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetShortIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetShortIdRes

@implementation PB3SetShortIdRes


typedef struct PB3SetShortIdRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetShortIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetShortIdRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SetShortIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3H5LogoutReq

@implementation PB3H5LogoutReq


typedef struct PB3H5LogoutReq__storage_ {
  uint32_t _has_storage_[1];
} PB3H5LogoutReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3H5LogoutReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3H5LogoutReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3H5LogoutRes

@implementation PB3H5LogoutRes


typedef struct PB3H5LogoutRes__storage_ {
  uint32_t _has_storage_[1];
} PB3H5LogoutRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3H5LogoutRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3H5LogoutRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncVerifyReq

@implementation PB3SyncVerifyReq

@dynamic data_p;

typedef struct PB3SyncVerifyReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
} PB3SyncVerifyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SyncVerifyReq_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SyncVerifyReq__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncVerifyReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SyncVerifyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncVerifyRes

@implementation PB3SyncVerifyRes

@dynamic code;

typedef struct PB3SyncVerifyRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t code;
} PB3SyncVerifyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3SyncVerifyRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SyncVerifyRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncVerifyRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SyncVerifyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WaiveCancelAccountApplyReq

@implementation PB3WaiveCancelAccountApplyReq


typedef struct PB3WaiveCancelAccountApplyReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WaiveCancelAccountApplyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WaiveCancelAccountApplyReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WaiveCancelAccountApplyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WaiveCancelAccountApplyRes

@implementation PB3WaiveCancelAccountApplyRes


typedef struct PB3WaiveCancelAccountApplyRes__storage_ {
  uint32_t _has_storage_[1];
} PB3WaiveCancelAccountApplyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WaiveCancelAccountApplyRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WaiveCancelAccountApplyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AgreementReq

@implementation PB3AgreementReq


typedef struct PB3AgreementReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AgreementReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AgreementReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AgreementReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AgreementRes

@implementation PB3AgreementRes

@dynamic code;
@dynamic agreedAt;

typedef struct PB3AgreementRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int64_t agreedAt;
} PB3AgreementRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgreementRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AgreementRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "agreedAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3AgreementRes_FieldNumber_AgreedAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AgreementRes__storage_, agreedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AgreementRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AgreementRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnchorAgreementReq

@implementation PB3AnchorAgreementReq


typedef struct PB3AnchorAgreementReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AnchorAgreementReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnchorAgreementReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AnchorAgreementReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnchorAgreementRes

@implementation PB3AnchorAgreementRes

@dynamic code;
@dynamic path;

typedef struct PB3AnchorAgreementRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *path;
} PB3AnchorAgreementRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnchorAgreementRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AnchorAgreementRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnchorAgreementRes_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AnchorAgreementRes__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnchorAgreementRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AnchorAgreementRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserUploadFileReq

@implementation PB3UserUploadFileReq

@dynamic uploadType;
@dynamic uploadSubType;
@dynamic file;
@dynamic suffix;

typedef struct PB3UserUploadFileReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType uploadType;
  PB3UploadSubType uploadSubType;
  NSData *file;
  NSString *suffix;
} PB3UserUploadFileReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uploadType",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3UserUploadFileReq_FieldNumber_UploadType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserUploadFileReq__storage_, uploadType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "uploadSubType",
        .dataTypeSpecific.enumDescFunc = PB3UploadSubType_EnumDescriptor,
        .number = PB3UserUploadFileReq_FieldNumber_UploadSubType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserUploadFileReq__storage_, uploadSubType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "file",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserUploadFileReq_FieldNumber_File,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserUploadFileReq__storage_, file),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "suffix",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserUploadFileReq_FieldNumber_Suffix,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserUploadFileReq__storage_, suffix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserUploadFileReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserUploadFileReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserUploadFileReq_UploadType_RawValue(PB3UserUploadFileReq *message) {
  GPBDescriptor *descriptor = [PB3UserUploadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserUploadFileReq_FieldNumber_UploadType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserUploadFileReq_UploadType_RawValue(PB3UserUploadFileReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserUploadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserUploadFileReq_FieldNumber_UploadType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserUploadFileReq_UploadSubType_RawValue(PB3UserUploadFileReq *message) {
  GPBDescriptor *descriptor = [PB3UserUploadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserUploadFileReq_FieldNumber_UploadSubType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserUploadFileReq_UploadSubType_RawValue(PB3UserUploadFileReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserUploadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserUploadFileReq_FieldNumber_UploadSubType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserUploadFileRes

@implementation PB3UserUploadFileRes

@dynamic uploadPath;

typedef struct PB3UserUploadFileRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *uploadPath;
} PB3UserUploadFileRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uploadPath",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserUploadFileRes_FieldNumber_UploadPath,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserUploadFileRes__storage_, uploadPath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserUploadFileRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserUploadFileRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExtraDownloadParam

@implementation PB3ExtraDownloadParam

@dynamic payType;

typedef struct PB3ExtraDownloadParam__storage_ {
  uint32_t _has_storage_[1];
  int32_t payType;
} PB3ExtraDownloadParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExtraDownloadParam_FieldNumber_PayType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExtraDownloadParam__storage_, payType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExtraDownloadParam class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExtraDownloadParam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserDownloadFileReq

@implementation PB3UserDownloadFileReq

@dynamic uploadType;
@dynamic uploadSubType;
@dynamic hasExtParam, extParam;

typedef struct PB3UserDownloadFileReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UploadType uploadType;
  PB3UploadSubType uploadSubType;
  PB3ExtraDownloadParam *extParam;
} PB3UserDownloadFileReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uploadType",
        .dataTypeSpecific.enumDescFunc = PB3UploadType_EnumDescriptor,
        .number = PB3UserDownloadFileReq_FieldNumber_UploadType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDownloadFileReq__storage_, uploadType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "uploadSubType",
        .dataTypeSpecific.enumDescFunc = PB3UploadSubType_EnumDescriptor,
        .number = PB3UserDownloadFileReq_FieldNumber_UploadSubType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserDownloadFileReq__storage_, uploadSubType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extParam",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExtraDownloadParam),
        .number = PB3UserDownloadFileReq_FieldNumber_ExtParam,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserDownloadFileReq__storage_, extParam),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDownloadFileReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDownloadFileReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserDownloadFileReq_UploadType_RawValue(PB3UserDownloadFileReq *message) {
  GPBDescriptor *descriptor = [PB3UserDownloadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDownloadFileReq_FieldNumber_UploadType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserDownloadFileReq_UploadType_RawValue(PB3UserDownloadFileReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserDownloadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDownloadFileReq_FieldNumber_UploadType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3UserDownloadFileReq_UploadSubType_RawValue(PB3UserDownloadFileReq *message) {
  GPBDescriptor *descriptor = [PB3UserDownloadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDownloadFileReq_FieldNumber_UploadSubType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserDownloadFileReq_UploadSubType_RawValue(PB3UserDownloadFileReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserDownloadFileReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDownloadFileReq_FieldNumber_UploadSubType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserDownloadFileRes

@implementation PB3UserDownloadFileRes

@dynamic data_p;

typedef struct PB3UserDownloadFileRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} PB3UserDownloadFileRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDownloadFileRes_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDownloadFileRes__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDownloadFileRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDownloadFileRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetBasicPlayerInfoListReq

@implementation PB3GetBasicPlayerInfoListReq

@dynamic idsArray, idsArray_Count;

typedef struct PB3GetBasicPlayerInfoListReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *idsArray;
} PB3GetBasicPlayerInfoListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetBasicPlayerInfoListReq_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetBasicPlayerInfoListReq__storage_, idsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetBasicPlayerInfoListReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetBasicPlayerInfoListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetBasicPlayerInfoListRes

@implementation PB3GetBasicPlayerInfoListRes

@dynamic listArray, listArray_Count;

typedef struct PB3GetBasicPlayerInfoListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3GetBasicPlayerInfoListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BasicPlayerInfo),
        .number = PB3GetBasicPlayerInfoListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetBasicPlayerInfoListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetBasicPlayerInfoListRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetBasicPlayerInfoListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserWelcomeMsg

@implementation PB3UserWelcomeMsg

@dynamic textData;
@dynamic voiceURL;
@dynamic voiceLength;

typedef struct PB3UserWelcomeMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *textData;
  NSString *voiceURL;
  int64_t voiceLength;
} PB3UserWelcomeMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textData",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserWelcomeMsg_FieldNumber_TextData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserWelcomeMsg__storage_, textData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserWelcomeMsg_FieldNumber_VoiceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserWelcomeMsg__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceLength",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserWelcomeMsg_FieldNumber_VoiceLength,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserWelcomeMsg__storage_, voiceLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserWelcomeMsg class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserWelcomeMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SetUserWelcomeMsgReq

@implementation PB3SetUserWelcomeMsgReq

@dynamic welcomeType;
@dynamic listArray, listArray_Count;

typedef struct PB3SetUserWelcomeMsgReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WelcomeType welcomeType;
  NSMutableArray *listArray;
} PB3SetUserWelcomeMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "welcomeType",
        .dataTypeSpecific.enumDescFunc = PB3WelcomeType_EnumDescriptor,
        .number = PB3SetUserWelcomeMsgReq_FieldNumber_WelcomeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SetUserWelcomeMsgReq__storage_, welcomeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserWelcomeMsg),
        .number = PB3SetUserWelcomeMsgReq_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SetUserWelcomeMsgReq__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetUserWelcomeMsgReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetUserWelcomeMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SetUserWelcomeMsgReq_WelcomeType_RawValue(PB3SetUserWelcomeMsgReq *message) {
  GPBDescriptor *descriptor = [PB3SetUserWelcomeMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SetUserWelcomeMsgReq_FieldNumber_WelcomeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SetUserWelcomeMsgReq_WelcomeType_RawValue(PB3SetUserWelcomeMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SetUserWelcomeMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SetUserWelcomeMsgReq_FieldNumber_WelcomeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SetUserWelcomeMsgRes

@implementation PB3SetUserWelcomeMsgRes

@dynamic setStatus;

typedef struct PB3SetUserWelcomeMsgRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SetUserWelcomeMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "setStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3SetUserWelcomeMsgRes_FieldNumber_SetStatus,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SetUserWelcomeMsgRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SetUserWelcomeMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3QueryUserWelcomeMsgReq

@implementation PB3QueryUserWelcomeMsgReq

@dynamic welcomeType;

typedef struct PB3QueryUserWelcomeMsgReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WelcomeType welcomeType;
} PB3QueryUserWelcomeMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "welcomeType",
        .dataTypeSpecific.enumDescFunc = PB3WelcomeType_EnumDescriptor,
        .number = PB3QueryUserWelcomeMsgReq_FieldNumber_WelcomeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3QueryUserWelcomeMsgReq__storage_, welcomeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3QueryUserWelcomeMsgReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3QueryUserWelcomeMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3QueryUserWelcomeMsgReq_WelcomeType_RawValue(PB3QueryUserWelcomeMsgReq *message) {
  GPBDescriptor *descriptor = [PB3QueryUserWelcomeMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3QueryUserWelcomeMsgReq_FieldNumber_WelcomeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3QueryUserWelcomeMsgReq_WelcomeType_RawValue(PB3QueryUserWelcomeMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3QueryUserWelcomeMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3QueryUserWelcomeMsgReq_FieldNumber_WelcomeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3QueryUserWelcomeMsgRes

@implementation PB3QueryUserWelcomeMsgRes

@dynamic welcomeType;
@dynamic listArray, listArray_Count;
@dynamic validDate;
@dynamic defaultMsg;

typedef struct PB3QueryUserWelcomeMsgRes__storage_ {
  uint32_t _has_storage_[1];
  PB3WelcomeType welcomeType;
  NSMutableArray *listArray;
  NSString *defaultMsg;
  int64_t validDate;
} PB3QueryUserWelcomeMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "welcomeType",
        .dataTypeSpecific.enumDescFunc = PB3WelcomeType_EnumDescriptor,
        .number = PB3QueryUserWelcomeMsgRes_FieldNumber_WelcomeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3QueryUserWelcomeMsgRes__storage_, welcomeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserWelcomeMsg),
        .number = PB3QueryUserWelcomeMsgRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3QueryUserWelcomeMsgRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validDate",
        .dataTypeSpecific.className = NULL,
        .number = PB3QueryUserWelcomeMsgRes_FieldNumber_ValidDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3QueryUserWelcomeMsgRes__storage_, validDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "defaultMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3QueryUserWelcomeMsgRes_FieldNumber_DefaultMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3QueryUserWelcomeMsgRes__storage_, defaultMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3QueryUserWelcomeMsgRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3QueryUserWelcomeMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3QueryUserWelcomeMsgRes_WelcomeType_RawValue(PB3QueryUserWelcomeMsgRes *message) {
  GPBDescriptor *descriptor = [PB3QueryUserWelcomeMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3QueryUserWelcomeMsgRes_FieldNumber_WelcomeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3QueryUserWelcomeMsgRes_WelcomeType_RawValue(PB3QueryUserWelcomeMsgRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3QueryUserWelcomeMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3QueryUserWelcomeMsgRes_FieldNumber_WelcomeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SendWelcomeMsgReq

@implementation PB3SendWelcomeMsgReq

@dynamic roomId;

typedef struct PB3SendWelcomeMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t roomId;
} PB3SendWelcomeMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendWelcomeMsgReq_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SendWelcomeMsgReq__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendWelcomeMsgReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SendWelcomeMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SendWelcomeMsgRes

@implementation PB3SendWelcomeMsgRes


typedef struct PB3SendWelcomeMsgRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SendWelcomeMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendWelcomeMsgRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SendWelcomeMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerInfosReq

@implementation PB3GetPlayerInfosReq


typedef struct PB3GetPlayerInfosReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetPlayerInfosReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerInfosReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetPlayerInfosReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerInfosRes

@implementation PB3GetPlayerInfosRes

@dynamic listArray, listArray_Count;

typedef struct PB3GetPlayerInfosRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3GetPlayerInfosRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerInfo),
        .number = PB3GetPlayerInfosRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetPlayerInfosRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerInfosRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerInfosRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserIsExistByNicknameReq

@implementation PB3GetUserIsExistByNicknameReq

@dynamic nickname;

typedef struct PB3GetUserIsExistByNicknameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickname;
} PB3GetUserIsExistByNicknameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIsExistByNicknameReq_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetUserIsExistByNicknameReq__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserIsExistByNicknameReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserIsExistByNicknameReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserIsExistByNicknameRes

@implementation PB3GetUserIsExistByNicknameRes

@dynamic isExist;

typedef struct PB3GetUserIsExistByNicknameRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetUserIsExistByNicknameRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isExist",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserIsExistByNicknameRes_FieldNumber_IsExist,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserIsExistByNicknameRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserIsExistByNicknameRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AccountInteractInfoReq

@implementation PB3AccountInteractInfoReq

@dynamic playerId;

typedef struct PB3AccountInteractInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3AccountInteractInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AccountInteractInfoReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AccountInteractInfoReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AccountInteractInfoReq class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AccountInteractInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AccountInteractInfoRes

@implementation PB3AccountInteractInfoRes

@dynamic inNum;
@dynamic outNum;
@dynamic concern;
@dynamic fans;

typedef struct PB3AccountInteractInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t concern;
  int32_t fans;
  int64_t inNum;
  int64_t outNum;
} PB3AccountInteractInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3AccountInteractInfoRes_FieldNumber_InNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AccountInteractInfoRes__storage_, inNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "outNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3AccountInteractInfoRes_FieldNumber_OutNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AccountInteractInfoRes__storage_, outNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "concern",
        .dataTypeSpecific.className = NULL,
        .number = PB3AccountInteractInfoRes_FieldNumber_Concern,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AccountInteractInfoRes__storage_, concern),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fans",
        .dataTypeSpecific.className = NULL,
        .number = PB3AccountInteractInfoRes_FieldNumber_Fans,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AccountInteractInfoRes__storage_, fans),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AccountInteractInfoRes class]
                                     rootClass:[PB3UserExtRoot class]
                                          file:PB3UserExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AccountInteractInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
