// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/red_envelope.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/RedEnvelopeExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3RedEnvelopeExtRoot

@implementation PB3RedEnvelopeExtRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PB3RedEnvelopeExtRoot_FileDescriptor

static GPBFileDescriptor *PB3RedEnvelopeExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3RedEnvelopeErrCode

GPBEnumDescriptor *PB3RedEnvelopeErrCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ReecZero\000ReecNotEnoughMoney\000ReecOpenBadL"
        "ucky\000";
    static const int32_t values[] = {
        PB3RedEnvelopeErrCode_ReecZero,
        PB3RedEnvelopeErrCode_ReecNotEnoughMoney,
        PB3RedEnvelopeErrCode_ReecOpenBadLucky,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RedEnvelopeErrCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RedEnvelopeErrCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RedEnvelopeErrCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RedEnvelopeErrCode_ReecZero:
    case PB3RedEnvelopeErrCode_ReecNotEnoughMoney:
    case PB3RedEnvelopeErrCode_ReecOpenBadLucky:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RedEnvelopeCmdId

GPBEnumDescriptor *PB3RedEnvelopeCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RedEnvelopeNone1\000RedEnvelopeInfoCmdId\000Re"
        "dEnvelopeOpenCmdId\000";
    static const int32_t values[] = {
        PB3RedEnvelopeCmdId_RedEnvelopeNone1,
        PB3RedEnvelopeCmdId_RedEnvelopeInfoCmdId,
        PB3RedEnvelopeCmdId_RedEnvelopeOpenCmdId,
    };
    static const char *extraTextFormatInfo = "\003\000\020\000\001\024\000\002\024\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RedEnvelopeCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RedEnvelopeCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RedEnvelopeCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RedEnvelopeCmdId_RedEnvelopeNone1:
    case PB3RedEnvelopeCmdId_RedEnvelopeInfoCmdId:
    case PB3RedEnvelopeCmdId_RedEnvelopeOpenCmdId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BroadcastRedEnvelopeType

GPBEnumDescriptor *PB3BroadcastRedEnvelopeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BretNull\000BretSend\000BretEnter\000BretClose\000";
    static const int32_t values[] = {
        PB3BroadcastRedEnvelopeType_BretNull,
        PB3BroadcastRedEnvelopeType_BretSend,
        PB3BroadcastRedEnvelopeType_BretEnter,
        PB3BroadcastRedEnvelopeType_BretClose,
    };
    static const char *extraTextFormatInfo = "\001\000d\343\001\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BroadcastRedEnvelopeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BroadcastRedEnvelopeType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BroadcastRedEnvelopeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BroadcastRedEnvelopeType_BretNull:
    case PB3BroadcastRedEnvelopeType_BretSend:
    case PB3BroadcastRedEnvelopeType_BretEnter:
    case PB3BroadcastRedEnvelopeType_BretClose:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3LevelOption

GPBEnumDescriptor *PB3LevelOption_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LvoNull\000LvoAnd\000LvoOr\000";
    static const int32_t values[] = {
        PB3LevelOption_LvoNull,
        PB3LevelOption_LvoAnd,
        PB3LevelOption_LvoOr,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3LevelOption)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3LevelOption_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3LevelOption_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3LevelOption_LvoNull:
    case PB3LevelOption_LvoAnd:
    case PB3LevelOption_LvoOr:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RedEnvelopeLogType

GPBEnumDescriptor *PB3RedEnvelopeLogType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ReltNone\000ReltSend\000ReltReceive\000ReltMySend"
        "\000";
    static const int32_t values[] = {
        PB3RedEnvelopeLogType_ReltNone,
        PB3RedEnvelopeLogType_ReltSend,
        PB3RedEnvelopeLogType_ReltReceive,
        PB3RedEnvelopeLogType_ReltMySend,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RedEnvelopeLogType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RedEnvelopeLogType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RedEnvelopeLogType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RedEnvelopeLogType_ReltNone:
    case PB3RedEnvelopeLogType_ReltSend:
    case PB3RedEnvelopeLogType_ReltReceive:
    case PB3RedEnvelopeLogType_ReltMySend:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3BroadcastRedEnvelopeStatus

@implementation PB3BroadcastRedEnvelopeStatus

@dynamic hasRedEnvelope, redEnvelope;
@dynamic type;

typedef struct PB3BroadcastRedEnvelopeStatus__storage_ {
  uint32_t _has_storage_[1];
  PB3BroadcastRedEnvelopeType type;
  PB3RedEnvelopeInfo *redEnvelope;
} PB3BroadcastRedEnvelopeStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelope",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeInfo),
        .number = PB3BroadcastRedEnvelopeStatus_FieldNumber_RedEnvelope,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastRedEnvelopeStatus__storage_, redEnvelope),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3BroadcastRedEnvelopeType_EnumDescriptor,
        .number = PB3BroadcastRedEnvelopeStatus_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastRedEnvelopeStatus__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastRedEnvelopeStatus class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastRedEnvelopeStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastRedEnvelopeStatus_Type_RawValue(PB3BroadcastRedEnvelopeStatus *message) {
  GPBDescriptor *descriptor = [PB3BroadcastRedEnvelopeStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRedEnvelopeStatus_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastRedEnvelopeStatus_Type_RawValue(PB3BroadcastRedEnvelopeStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastRedEnvelopeStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastRedEnvelopeStatus_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3RedEnvelopeInfo

@implementation PB3RedEnvelopeInfo

@dynamic redEnvelopeId;
@dynamic redEnvelopeNum;
@dynamic openedNum;
@dynamic goldEach;
@dynamic goldTotal;
@dynamic greeting;
@dynamic validTime;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic levelOption;
@dynamic hasSender, sender;
@dynamic sendAt;
@dynamic endAt;
@dynamic goldOpened;

typedef struct PB3RedEnvelopeInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t redEnvelopeNum;
  int32_t openedNum;
  int32_t goldEach;
  int32_t validTime;
  int32_t wealthLevel;
  int32_t charmLevel;
  PB3LevelOption levelOption;
  NSString *redEnvelopeId;
  NSString *greeting;
  PB3RedPlayer *sender;
  int64_t goldTotal;
  int64_t sendAt;
  int64_t endAt;
  int64_t goldOpened;
} PB3RedEnvelopeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_RedEnvelopeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, redEnvelopeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redEnvelopeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_RedEnvelopeNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, redEnvelopeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "openedNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_OpenedNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, openedNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldEach",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_GoldEach,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, goldEach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldTotal",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_GoldTotal,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, goldTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "greeting",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_Greeting,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, greeting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_ValidTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, validTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_WealthLevel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_CharmLevel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelOption",
        .dataTypeSpecific.enumDescFunc = PB3LevelOption_EnumDescriptor,
        .number = PB3RedEnvelopeInfo_FieldNumber_LevelOption,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, levelOption),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedPlayer),
        .number = PB3RedEnvelopeInfo_FieldNumber_Sender,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_SendAt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, sendAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_EndAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, endAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "goldOpened",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeInfo_FieldNumber_GoldOpened,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeInfo__storage_, goldOpened),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeInfo class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3RedEnvelopeInfo_LevelOption_RawValue(PB3RedEnvelopeInfo *message) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeInfo_FieldNumber_LevelOption];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3RedEnvelopeInfo_LevelOption_RawValue(PB3RedEnvelopeInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeInfo_FieldNumber_LevelOption];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3RedEnvelopeOpen

@implementation PB3RedEnvelopeOpen

@dynamic openId;
@dynamic openId2;
@dynamic openName;
@dynamic sendId;
@dynamic sendId2;
@dynamic sendName;
@dynamic gold;

typedef struct PB3RedEnvelopeOpen__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  NSString *openName;
  NSString *sendName;
  int64_t openId;
  int64_t openId2;
  int64_t sendId;
  int64_t sendId2;
} PB3RedEnvelopeOpen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_OpenId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, openId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "openId2",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_OpenId2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, openId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "openName",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_OpenName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, openName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_SendId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, sendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sendId2",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_SendId2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, sendId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sendName",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_SendName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, sendName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeOpen_FieldNumber_Gold,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeOpen__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeOpen class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeOpen__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedPlayer

@implementation PB3RedPlayer

@dynamic playerId;
@dynamic id2;
@dynamic name;
@dynamic icon;
@dynamic sex;
@dynamic wealthLevel;
@dynamic charmLevel;

typedef struct PB3RedPlayer__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  int32_t wealthLevel;
  int32_t charmLevel;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t id2;
} PB3RedPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_WealthLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedPlayer_FieldNumber_CharmLevel,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3RedPlayer__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedPlayer class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SendRedEnvelopeReq

@implementation PB3SendRedEnvelopeReq

@dynamic redEnvelopeNum;
@dynamic goldEach;
@dynamic greeting;
@dynamic validTime;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic levelOption;

typedef struct PB3SendRedEnvelopeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t redEnvelopeNum;
  int32_t goldEach;
  int32_t validTime;
  int32_t wealthLevel;
  int32_t charmLevel;
  PB3LevelOption levelOption;
  NSString *greeting;
} PB3SendRedEnvelopeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_RedEnvelopeNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, redEnvelopeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldEach",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_GoldEach,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, goldEach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "greeting",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_Greeting,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, greeting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_ValidTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, validTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_WealthLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRedEnvelopeReq_FieldNumber_CharmLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelOption",
        .dataTypeSpecific.enumDescFunc = PB3LevelOption_EnumDescriptor,
        .number = PB3SendRedEnvelopeReq_FieldNumber_LevelOption,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SendRedEnvelopeReq__storage_, levelOption),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendRedEnvelopeReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SendRedEnvelopeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SendRedEnvelopeReq_LevelOption_RawValue(PB3SendRedEnvelopeReq *message) {
  GPBDescriptor *descriptor = [PB3SendRedEnvelopeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SendRedEnvelopeReq_FieldNumber_LevelOption];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SendRedEnvelopeReq_LevelOption_RawValue(PB3SendRedEnvelopeReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SendRedEnvelopeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SendRedEnvelopeReq_FieldNumber_LevelOption];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SendRedEnvelopeRes

@implementation PB3SendRedEnvelopeRes


typedef struct PB3SendRedEnvelopeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SendRedEnvelopeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendRedEnvelopeRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SendRedEnvelopeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SendRandomRedEnvelopeReq

@implementation PB3SendRandomRedEnvelopeReq

@dynamic redEnvelopeNum;
@dynamic gold;
@dynamic greeting;
@dynamic validTime;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic levelOption;

typedef struct PB3SendRandomRedEnvelopeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t redEnvelopeNum;
  int32_t gold;
  int32_t validTime;
  int32_t wealthLevel;
  int32_t charmLevel;
  PB3LevelOption levelOption;
  NSString *greeting;
} PB3SendRandomRedEnvelopeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_RedEnvelopeNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, redEnvelopeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_Gold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "greeting",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_Greeting,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, greeting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_ValidTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, validTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_WealthLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_CharmLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelOption",
        .dataTypeSpecific.enumDescFunc = PB3LevelOption_EnumDescriptor,
        .number = PB3SendRandomRedEnvelopeReq_FieldNumber_LevelOption,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SendRandomRedEnvelopeReq__storage_, levelOption),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendRandomRedEnvelopeReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SendRandomRedEnvelopeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SendRandomRedEnvelopeReq_LevelOption_RawValue(PB3SendRandomRedEnvelopeReq *message) {
  GPBDescriptor *descriptor = [PB3SendRandomRedEnvelopeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SendRandomRedEnvelopeReq_FieldNumber_LevelOption];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SendRandomRedEnvelopeReq_LevelOption_RawValue(PB3SendRandomRedEnvelopeReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SendRandomRedEnvelopeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SendRandomRedEnvelopeReq_FieldNumber_LevelOption];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SendRandomRedEnvelopeRes

@implementation PB3SendRandomRedEnvelopeRes


typedef struct PB3SendRandomRedEnvelopeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SendRandomRedEnvelopeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SendRandomRedEnvelopeRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SendRandomRedEnvelopeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3OpenRedEnvelopeReq

@implementation PB3OpenRedEnvelopeReq

@dynamic redEnvelopeId;

typedef struct PB3OpenRedEnvelopeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *redEnvelopeId;
} PB3OpenRedEnvelopeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenRedEnvelopeReq_FieldNumber_RedEnvelopeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3OpenRedEnvelopeReq__storage_, redEnvelopeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3OpenRedEnvelopeReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3OpenRedEnvelopeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeLuckyListReq

@implementation PB3RedEnvelopeLuckyListReq

@dynamic redEnvelopeId;
@dynamic index;

typedef struct PB3RedEnvelopeLuckyListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  NSString *redEnvelopeId;
} PB3RedEnvelopeLuckyListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListReq_FieldNumber_RedEnvelopeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListReq__storage_, redEnvelopeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeLuckyListReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeLuckyListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeLuckyListRes

@implementation PB3RedEnvelopeLuckyListRes

@dynamic hasRedEnvelopeInfo, redEnvelopeInfo;
@dynamic luckyBoysArray, luckyBoysArray_Count;
@dynamic index;
@dynamic gold;
@dynamic openedGold;
@dynamic overMsg;

typedef struct PB3RedEnvelopeLuckyListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t gold;
  int32_t openedGold;
  PB3RedEnvelopeInfo *redEnvelopeInfo;
  NSMutableArray *luckyBoysArray;
  NSString *overMsg;
} PB3RedEnvelopeLuckyListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeInfo),
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_RedEnvelopeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, redEnvelopeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "luckyBoysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeLog),
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_LuckyBoysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, luckyBoysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_Gold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "openedGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_OpenedGold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, openedGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "overMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLuckyListRes_FieldNumber_OverMsg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLuckyListRes__storage_, overMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeLuckyListRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeLuckyListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeLogReq

@implementation PB3RedEnvelopeLogReq

@dynamic type;

typedef struct PB3RedEnvelopeLogReq__storage_ {
  uint32_t _has_storage_[1];
  PB3RedEnvelopeLogType type;
} PB3RedEnvelopeLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RedEnvelopeLogType_EnumDescriptor,
        .number = PB3RedEnvelopeLogReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLogReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeLogReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3RedEnvelopeLogReq_Type_RawValue(PB3RedEnvelopeLogReq *message) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeLogReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeLogReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3RedEnvelopeLogReq_Type_RawValue(PB3RedEnvelopeLogReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeLogReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeLogReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3RedEnvelopeLogRes

@implementation PB3RedEnvelopeLogRes

@dynamic listArray, listArray_Count;
@dynamic type;

typedef struct PB3RedEnvelopeLogRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RedEnvelopeLogType type;
  NSMutableArray *listArray;
} PB3RedEnvelopeLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeLog),
        .number = PB3RedEnvelopeLogRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLogRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RedEnvelopeLogType_EnumDescriptor,
        .number = PB3RedEnvelopeLogRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLogRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeLogRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3RedEnvelopeLogRes_Type_RawValue(PB3RedEnvelopeLogRes *message) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeLogRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeLogRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3RedEnvelopeLogRes_Type_RawValue(PB3RedEnvelopeLogRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3RedEnvelopeLogRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RedEnvelopeLogRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3RedEnvelopeLog

@implementation PB3RedEnvelopeLog

@dynamic hasPlayer, player;
@dynamic gold;
@dynamic createAt;
@dynamic num;
@dynamic numTotal;
@dynamic goldTotal;

typedef struct PB3RedEnvelopeLog__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t num;
  int32_t numTotal;
  int32_t goldTotal;
  PB3RedPlayer *player;
  int64_t createAt;
} PB3RedEnvelopeLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedPlayer),
        .number = PB3RedEnvelopeLog_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLog_FieldNumber_Gold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLog_FieldNumber_CreateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLog_FieldNumber_Num,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numTotal",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLog_FieldNumber_NumTotal,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, numTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldTotal",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeLog_FieldNumber_GoldTotal,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeLog__storage_, goldTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeLog class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeConf

@implementation PB3RedEnvelopeConf

@dynamic validTimesArray, validTimesArray_Count;
@dynamic taxRate;

typedef struct PB3RedEnvelopeConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t taxRate;
  GPBInt32Array *validTimesArray;
} PB3RedEnvelopeConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validTimesArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeConf_FieldNumber_ValidTimesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeConf__storage_, validTimesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "taxRate",
        .dataTypeSpecific.className = NULL,
        .number = PB3RedEnvelopeConf_FieldNumber_TaxRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeConf__storage_, taxRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeConf class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeConfReq

@implementation PB3RedEnvelopeConfReq


typedef struct PB3RedEnvelopeConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3RedEnvelopeConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeConfReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3RedEnvelopeConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RedEnvelopeConfRes

@implementation PB3RedEnvelopeConfRes

@dynamic hasConfig, config;

typedef struct PB3RedEnvelopeConfRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RedEnvelopeConf *config;
} PB3RedEnvelopeConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeConf),
        .number = PB3RedEnvelopeConfRes_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RedEnvelopeConfRes__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RedEnvelopeConfRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RedEnvelopeConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CloseRedEnvelopeReq

@implementation PB3CloseRedEnvelopeReq

@dynamic redEnvelopeId;

typedef struct PB3CloseRedEnvelopeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *redEnvelopeId;
} PB3CloseRedEnvelopeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CloseRedEnvelopeReq_FieldNumber_RedEnvelopeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CloseRedEnvelopeReq__storage_, redEnvelopeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CloseRedEnvelopeReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CloseRedEnvelopeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CloseRedEnvelopeRes

@implementation PB3CloseRedEnvelopeRes


typedef struct PB3CloseRedEnvelopeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CloseRedEnvelopeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CloseRedEnvelopeRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CloseRedEnvelopeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BreakRedEnvelopeReq

@implementation PB3BreakRedEnvelopeReq

@dynamic redEnvelopeId;

typedef struct PB3BreakRedEnvelopeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *redEnvelopeId;
} PB3BreakRedEnvelopeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redEnvelopeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BreakRedEnvelopeReq_FieldNumber_RedEnvelopeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BreakRedEnvelopeReq__storage_, redEnvelopeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BreakRedEnvelopeReq class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BreakRedEnvelopeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BreakRedEnvelopeRes

@implementation PB3BreakRedEnvelopeRes

@dynamic canOpen;
@dynamic hasRedEnvelope, redEnvelope;

typedef struct PB3BreakRedEnvelopeRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RedEnvelopeInfo *redEnvelope;
} PB3BreakRedEnvelopeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "canOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3BreakRedEnvelopeRes_FieldNumber_CanOpen,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "redEnvelope",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RedEnvelopeInfo),
        .number = PB3BreakRedEnvelopeRes_FieldNumber_RedEnvelope,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BreakRedEnvelopeRes__storage_, redEnvelope),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BreakRedEnvelopeRes class]
                                     rootClass:[PB3RedEnvelopeExtRoot class]
                                          file:PB3RedEnvelopeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BreakRedEnvelopeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
