// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/assets.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/AssetsExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - PB3AssetsExtRoot

@implementation PB3AssetsExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3AssetsExtRoot_FileDescriptor

static GPBFileDescriptor *PB3AssetsExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3AssetsCmdId

GPBEnumDescriptor *PB3AssetsCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AssetsNone1\000AssetsMoneyCmdId\000AssetsBagCm"
        "dId\000AssetsEffectPlayer\000AssetsEffectRoom\000"
        "AssetsEffectTips\000AssetsInDebtCmdId\000Asset"
        "sPointCmdId\000AssetsAuthenticateConfig\000";
    static const int32_t values[] = {
        PB3AssetsCmdId_AssetsNone1,
        PB3AssetsCmdId_AssetsMoneyCmdId,
        PB3AssetsCmdId_AssetsBagCmdId,
        PB3AssetsCmdId_AssetsEffectPlayer,
        PB3AssetsCmdId_AssetsEffectRoom,
        PB3AssetsCmdId_AssetsEffectTips,
        PB3AssetsCmdId_AssetsInDebtCmdId,
        PB3AssetsCmdId_AssetsPointCmdId,
        PB3AssetsCmdId_AssetsAuthenticateConfig,
    };
    static const char *extraTextFormatInfo = "\t\000\013\000\001\020\000\002\016\000\003\022\000\004\020\000\005\020\000\006\021\000\007\020\000\010\030\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AssetsCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AssetsCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AssetsCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AssetsCmdId_AssetsNone1:
    case PB3AssetsCmdId_AssetsMoneyCmdId:
    case PB3AssetsCmdId_AssetsBagCmdId:
    case PB3AssetsCmdId_AssetsEffectPlayer:
    case PB3AssetsCmdId_AssetsEffectRoom:
    case PB3AssetsCmdId_AssetsEffectTips:
    case PB3AssetsCmdId_AssetsInDebtCmdId:
    case PB3AssetsCmdId_AssetsPointCmdId:
    case PB3AssetsCmdId_AssetsAuthenticateConfig:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PointType

GPBEnumDescriptor *PB3PointType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PointZero\000PointStore\000";
    static const int32_t values[] = {
        PB3PointType_PointZero,
        PB3PointType_PointStore,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PointType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PointType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PointType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PointType_PointZero:
    case PB3PointType_PointStore:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AssetsType

GPBEnumDescriptor *PB3AssetsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AtZero\000AtHammer\000AtPoints\000AtHammerGold\000";
    static const int32_t values[] = {
        PB3AssetsType_AtZero,
        PB3AssetsType_AtHammer,
        PB3AssetsType_AtPoints,
        PB3AssetsType_AtHammerGold,
    };
    static const char *extraTextFormatInfo = "\002\001b\206\000\003b\206\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AssetsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AssetsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AssetsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AssetsType_AtZero:
    case PB3AssetsType_AtHammer:
    case PB3AssetsType_AtPoints:
    case PB3AssetsType_AtHammerGold:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WalletTrainsType

GPBEnumDescriptor *PB3WalletTrainsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnKnow\000GeneralRecharge\000TaskReward\000RoomPl"
        "ay\000SystemRelease\000AgentRecharge\000InviteRew"
        "ard\000CatExchange\000CharmExchange\000Order\000Send"
        "GiftDetail\000ExchangeCat\000MallShopping\000Syst"
        "emDeduct\000CompleteOrder\000GiftSharing\000BuyBa"
        "ck\000GoldExchange\000ExchangeGold\000SystemRecov"
        "ery\000AppletGameCat\000SingleGold\000OnlyFans\000Pl"
        "ayAward\000Clan\000TicketExchangeGold\000ClanWelf"
        "are\000ActivityBenefit\000";
    static const int32_t values[] = {
        PB3WalletTrainsType_UnKnow,
        PB3WalletTrainsType_GeneralRecharge,
        PB3WalletTrainsType_TaskReward,
        PB3WalletTrainsType_RoomPlay,
        PB3WalletTrainsType_SystemRelease,
        PB3WalletTrainsType_AgentRecharge,
        PB3WalletTrainsType_InviteReward,
        PB3WalletTrainsType_CatExchange,
        PB3WalletTrainsType_CharmExchange,
        PB3WalletTrainsType_Order,
        PB3WalletTrainsType_SendGiftDetail,
        PB3WalletTrainsType_ExchangeCat,
        PB3WalletTrainsType_MallShopping,
        PB3WalletTrainsType_SystemDeduct,
        PB3WalletTrainsType_CompleteOrder,
        PB3WalletTrainsType_GiftSharing,
        PB3WalletTrainsType_BuyBack,
        PB3WalletTrainsType_GoldExchange,
        PB3WalletTrainsType_ExchangeGold,
        PB3WalletTrainsType_SystemRecovery,
        PB3WalletTrainsType_AppletGameCat,
        PB3WalletTrainsType_SingleGold,
        PB3WalletTrainsType_OnlyFans,
        PB3WalletTrainsType_PlayAward,
        PB3WalletTrainsType_Clan,
        PB3WalletTrainsType_TicketExchangeGold,
        PB3WalletTrainsType_ClanWelfare,
        PB3WalletTrainsType_ActivityBenefit,
    };
    static const char *extraTextFormatInfo = "\034\000\006\000\001\017\000\002\n\000\003\010\000\004\r\000\005\r\000\006\014\000\007\013\000\010\r\000\t\005\000\n\016\000\013\013\000\014\014\000\r\014\000\016\r\000\017\013\000\020\007\000\021\014\000\022\014\000\023\016\000\024\r\000\025\n\000\026\010\000\027\t\000\030\004\000\031\022\000\032\013\000\033\017\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WalletTrainsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WalletTrainsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WalletTrainsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WalletTrainsType_UnKnow:
    case PB3WalletTrainsType_GeneralRecharge:
    case PB3WalletTrainsType_TaskReward:
    case PB3WalletTrainsType_RoomPlay:
    case PB3WalletTrainsType_SystemRelease:
    case PB3WalletTrainsType_AgentRecharge:
    case PB3WalletTrainsType_InviteReward:
    case PB3WalletTrainsType_CatExchange:
    case PB3WalletTrainsType_CharmExchange:
    case PB3WalletTrainsType_Order:
    case PB3WalletTrainsType_SendGiftDetail:
    case PB3WalletTrainsType_ExchangeCat:
    case PB3WalletTrainsType_MallShopping:
    case PB3WalletTrainsType_SystemDeduct:
    case PB3WalletTrainsType_CompleteOrder:
    case PB3WalletTrainsType_GiftSharing:
    case PB3WalletTrainsType_BuyBack:
    case PB3WalletTrainsType_GoldExchange:
    case PB3WalletTrainsType_ExchangeGold:
    case PB3WalletTrainsType_SystemRecovery:
    case PB3WalletTrainsType_AppletGameCat:
    case PB3WalletTrainsType_SingleGold:
    case PB3WalletTrainsType_OnlyFans:
    case PB3WalletTrainsType_PlayAward:
    case PB3WalletTrainsType_Clan:
    case PB3WalletTrainsType_TicketExchangeGold:
    case PB3WalletTrainsType_ClanWelfare:
    case PB3WalletTrainsType_ActivityBenefit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WalletAssetsType

GPBEnumDescriptor *PB3WalletAssetsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Nil\000Gold\000Charm\000";
    static const int32_t values[] = {
        PB3WalletAssetsType_Nil,
        PB3WalletAssetsType_Gold,
        PB3WalletAssetsType_Charm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WalletAssetsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WalletAssetsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WalletAssetsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WalletAssetsType_Nil:
    case PB3WalletAssetsType_Gold:
    case PB3WalletAssetsType_Charm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WalletATransactionType

GPBEnumDescriptor *PB3WalletATransactionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Every\000Income\000Pay\000";
    static const int32_t values[] = {
        PB3WalletATransactionType_Every,
        PB3WalletATransactionType_Income,
        PB3WalletATransactionType_Pay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WalletATransactionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WalletATransactionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WalletATransactionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WalletATransactionType_Every:
    case PB3WalletATransactionType_Income:
    case PB3WalletATransactionType_Pay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RequestPayUseType

GPBEnumDescriptor *PB3RequestPayUseType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RpuTypeDefault\000RpuTypeAct\000";
    static const int32_t values[] = {
        PB3RequestPayUseType_RpuTypeDefault,
        PB3RequestPayUseType_RpuTypeAct,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RequestPayUseType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RequestPayUseType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RequestPayUseType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RequestPayUseType_RpuTypeDefault:
    case PB3RequestPayUseType_RpuTypeAct:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3InvoiceType

GPBEnumDescriptor *PB3InvoiceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "InvoicesUnknown\000InvoicesTweCopies\000Invoic"
        "esThreeCopies\000";
    static const int32_t values[] = {
        PB3InvoiceType_InvoicesUnknown,
        PB3InvoiceType_InvoicesTweCopies,
        PB3InvoiceType_InvoicesThreeCopies,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3InvoiceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3InvoiceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3InvoiceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3InvoiceType_InvoicesUnknown:
    case PB3InvoiceType_InvoicesTweCopies:
    case PB3InvoiceType_InvoicesThreeCopies:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3EzPayCarrierType

GPBEnumDescriptor *PB3EzPayCarrierType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EzpayCtNone\000EzpayCtEzpay\000EzpayCtPhone\000Ez"
        "payCtNaturalPerson\000EzpayCtEmail\000";
    static const int32_t values[] = {
        PB3EzPayCarrierType_EzpayCtNone,
        PB3EzPayCarrierType_EzpayCtEzpay,
        PB3EzPayCarrierType_EzpayCtPhone,
        PB3EzPayCarrierType_EzpayCtNaturalPerson,
        PB3EzPayCarrierType_EzpayCtEmail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3EzPayCarrierType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3EzPayCarrierType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3EzPayCarrierType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3EzPayCarrierType_EzpayCtNone:
    case PB3EzPayCarrierType_EzpayCtEzpay:
    case PB3EzPayCarrierType_EzpayCtPhone:
    case PB3EzPayCarrierType_EzpayCtNaturalPerson:
    case PB3EzPayCarrierType_EzpayCtEmail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ResponseType

GPBEnumDescriptor *PB3ResponseType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RtPostForm\000RtRedirect\000RtRedirectV2\000";
    static const int32_t values[] = {
        PB3ResponseType_RtPostForm,
        PB3ResponseType_RtRedirect,
        PB3ResponseType_RtRedirectV2,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ResponseType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ResponseType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ResponseType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ResponseType_RtPostForm:
    case PB3ResponseType_RtRedirect:
    case PB3ResponseType_RtRedirectV2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3AssetsMoneyReq

@implementation PB3AssetsMoneyReq


typedef struct PB3AssetsMoneyReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsMoneyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoneyReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsMoneyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsMoney

@implementation PB3AssetsMoney

@dynamic gold;
@dynamic silver;
@dynamic giftTicket;
@dynamic charge;
@dynamic millionAward;
@dynamic giftTicketCents;

typedef struct PB3AssetsMoney__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  uint32_t silver;
  uint32_t giftTicket;
  uint32_t charge;
  uint32_t millionAward;
  double giftTicketCents;
} PB3AssetsMoney__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "silver",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Silver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, silver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftTicket",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_GiftTicket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, giftTicket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "charge",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Charge,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, charge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "millionAward",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_MillionAward,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, millionAward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftTicketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_GiftTicketCents,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, giftTicketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoney class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsMoney__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsBag

@implementation PB3AssetsBag

@dynamic itemsArray, itemsArray_Count;

typedef struct PB3AssetsBag__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} PB3AssetsBag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BagItem),
        .number = PB3AssetsBag_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsBag__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBag class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsBag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsMoneyRes

@implementation PB3AssetsMoneyRes

@dynamic flag;
@dynamic hasMoney, money;

typedef struct PB3AssetsMoneyRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flag;
  PB3AssetsMoney *money;
} PB3AssetsMoneyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoneyRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "money",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AssetsMoney),
        .number = PB3AssetsMoneyRes_FieldNumber_Money,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, money),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoneyRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsMoneyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPointReq

@implementation PB3AssetsPointReq


typedef struct PB3AssetsPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPointReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPointRes

@implementation PB3AssetsPointRes

@dynamic point, point_Count;

typedef struct PB3AssetsPointRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *point;
} PB3AssetsPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "point",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AssetsPoint),
        .number = PB3AssetsPointRes_FieldNumber_Point,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsPointRes__storage_, point),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPointRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPoint

@implementation PB3AssetsPoint

@dynamic pointType;
@dynamic num;

typedef struct PB3AssetsPoint__storage_ {
  uint32_t _has_storage_[1];
  PB3PointType pointType;
  uint32_t num;
} PB3AssetsPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pointType",
        .dataTypeSpecific.enumDescFunc = PB3PointType_EnumDescriptor,
        .number = PB3AssetsPoint_FieldNumber_PointType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsPoint__storage_, pointType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsPoint_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsPoint__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPoint class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AssetsPoint_PointType_RawValue(PB3AssetsPoint *message) {
  GPBDescriptor *descriptor = [PB3AssetsPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AssetsPoint_FieldNumber_PointType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AssetsPoint_PointType_RawValue(PB3AssetsPoint *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AssetsPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AssetsPoint_FieldNumber_PointType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AssetsBagReq

@implementation PB3AssetsBagReq


typedef struct PB3AssetsBagReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsBagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBagReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsBagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsBagRes

@implementation PB3AssetsBagRes

@dynamic flag;
@dynamic itemsArray, itemsArray_Count;

typedef struct PB3AssetsBagRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flag;
  NSMutableArray *itemsArray;
} PB3AssetsBagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsBagRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsBagRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BagItem),
        .number = PB3AssetsBagRes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsBagRes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBagRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsBagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BcPlayerEffect

@implementation PB3BcPlayerEffect

@dynamic playerId;
@dynamic effectArray, effectArray_Count;

typedef struct PB3BcPlayerEffect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectArray;
  int64_t playerId;
} PB3BcPlayerEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BcPlayerEffect_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BcPlayerEffect__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3BcPlayerEffect_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BcPlayerEffect__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BcPlayerEffect class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BcPlayerEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BcRoomEffect

@implementation PB3BcRoomEffect

@dynamic playerId;
@dynamic effectArray, effectArray_Count;

typedef struct PB3BcRoomEffect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectArray;
  int64_t playerId;
} PB3BcRoomEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BcRoomEffect_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BcRoomEffect__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3BcRoomEffect_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BcRoomEffect__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BcRoomEffect class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BcRoomEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigReq

@implementation PB3EffectConfigReq


typedef struct PB3EffectConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3EffectConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3EffectConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigRes

@implementation PB3EffectConfigRes

@dynamic list, list_Count;

typedef struct PB3EffectConfigRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *list;
} PB3EffectConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "list",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EffectConfig),
        .number = PB3EffectConfigRes_FieldNumber_List,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EffectConfigRes__storage_, list),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigCDNReq

@implementation PB3EffectConfigCDNReq


typedef struct PB3EffectConfigCDNReq__storage_ {
  uint32_t _has_storage_[1];
} PB3EffectConfigCDNReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigCDNReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3EffectConfigCDNReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigCDNRes

@implementation PB3EffectConfigCDNRes

@dynamic confURL;

typedef struct PB3EffectConfigCDNRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *confURL;
} PB3EffectConfigCDNRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectConfigCDNRes_FieldNumber_ConfURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EffectConfigCDNRes__storage_, confURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigCDNRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectConfigCDNRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetEffectReq

@implementation PB3GetEffectReq

@dynamic playerId;

typedef struct PB3GetEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetEffectRes

@implementation PB3GetEffectRes

@dynamic flag;
@dynamic playerId;
@dynamic effectArray, effectArray_Count;
@dynamic protectEffectArray, protectEffectArray_Count;
@dynamic effectLimitArray, effectLimitArray_Count;

typedef struct PB3GetEffectRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t flag;
  NSMutableArray *effectArray;
  NSMutableArray *protectEffectArray;
  NSMutableArray *effectLimitArray;
  int64_t playerId;
} PB3GetEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectRes_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3GetEffectRes_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "protectEffectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3GetEffectRes_FieldNumber_ProtectEffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, protectEffectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effectLimitArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EffectLimit),
        .number = PB3GetEffectRes_FieldNumber_EffectLimitArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, effectLimitArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectTips

@implementation PB3EffectTips

@dynamic effectId;
@dynamic effectName;
@dynamic tipType;
@dynamic timeoutArray, timeoutArray_Count;
@dynamic timeoutSecond;
@dynamic type;
@dynamic timeType;
@dynamic msg;

typedef struct PB3EffectTips__storage_ {
  uint32_t _has_storage_[1];
  int32_t effectId;
  PB3EffectTipsType tipType;
  int32_t timeoutSecond;
  PB3EffectType type;
  PB3EffectTimeType timeType;
  NSString *effectName;
  GPBInt32Array *timeoutArray;
  NSString *msg;
} PB3EffectTips__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectId",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_EffectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, effectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectName",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_EffectName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, effectName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tipType",
        .dataTypeSpecific.enumDescFunc = PB3EffectTipsType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_TipType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, tipType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeoutArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_TimeoutArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeoutArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeoutSecond",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_TimeoutSecond,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeoutSecond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3EffectType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeType",
        .dataTypeSpecific.enumDescFunc = PB3EffectTimeType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_TimeType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectTips class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectTips__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3EffectTips_TipType_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_TipType_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3EffectTips_Type_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_Type_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3EffectTips_TimeType_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TimeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_TimeType_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TimeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AsstesDetail

@implementation PB3AsstesDetail

@dynamic id_p;

typedef struct PB3AsstesDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3AsstesDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AsstesDetail_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AsstesDetail__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AsstesDetail class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AsstesDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AsstesCollection

@implementation PB3AsstesCollection

@dynamic icon;
@dynamic listArray, listArray_Count;

typedef struct PB3AsstesCollection__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  NSMutableArray *listArray;
} PB3AsstesCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AsstesCollection_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AsstesCollection__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AsstesDetail),
        .number = PB3AsstesCollection_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AsstesCollection__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AsstesCollection class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AsstesCollection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAssetsConfReq

@implementation PB3GetAssetsConfReq


typedef struct PB3GetAssetsConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAssetsConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAssetsConfReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAssetsConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAssetsConfRes

@implementation PB3GetAssetsConfRes

@dynamic assetsConf, assetsConf_Count;

typedef struct PB3GetAssetsConfRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *assetsConf;
} PB3GetAssetsConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetsConf",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AsstesCollection),
        .number = PB3GetAssetsConfRes_FieldNumber_AssetsConf,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetAssetsConfRes__storage_, assetsConf),
        .flags = GPBFieldMapKeySInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAssetsConfRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAssetsConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UseEffectReq

@implementation PB3UseEffectReq

@dynamic id_p;
@dynamic useType;

typedef struct PB3UseEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3EffectUseType useType;
} PB3UseEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UseEffectReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UseEffectReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useType",
        .dataTypeSpecific.enumDescFunc = PB3EffectUseType_EnumDescriptor,
        .number = PB3UseEffectReq_FieldNumber_UseType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UseEffectReq__storage_, useType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UseEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UseEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UseEffectReq_UseType_RawValue(PB3UseEffectReq *message) {
  GPBDescriptor *descriptor = [PB3UseEffectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectReq_FieldNumber_UseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UseEffectReq_UseType_RawValue(PB3UseEffectReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UseEffectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectReq_FieldNumber_UseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UseEffectRes

@implementation PB3UseEffectRes

@dynamic type;

typedef struct PB3UseEffectRes__storage_ {
  uint32_t _has_storage_[1];
  PB3EffectType type;
} PB3UseEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3EffectType_EnumDescriptor,
        .number = PB3UseEffectRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UseEffectRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UseEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UseEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UseEffectRes_Type_RawValue(PB3UseEffectRes *message) {
  GPBDescriptor *descriptor = [PB3UseEffectRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UseEffectRes_Type_RawValue(PB3UseEffectRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UseEffectRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InDebtInfoReq

@implementation PB3InDebtInfoReq


typedef struct PB3InDebtInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InDebtInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InDebtInfoReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InDebtInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InDebtInfoRes

@implementation PB3InDebtInfoRes

@dynamic inDebtTick;

typedef struct PB3InDebtInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t inDebtTick;
} PB3InDebtInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inDebtTick",
        .dataTypeSpecific.className = NULL,
        .number = PB3InDebtInfoRes_FieldNumber_InDebtTick,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InDebtInfoRes__storage_, inDebtTick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InDebtInfoRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InDebtInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsInDebt

@implementation PB3AssetsInDebt

@dynamic inDebtTick;

typedef struct PB3AssetsInDebt__storage_ {
  uint32_t _has_storage_[1];
  int64_t inDebtTick;
} PB3AssetsInDebt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inDebtTick",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsInDebt_FieldNumber_InDebtTick,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsInDebt__storage_, inDebtTick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsInDebt class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsInDebt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MedalEffectReq

@implementation PB3MedalEffectReq

@dynamic playerId;

typedef struct PB3MedalEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3MedalEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MedalEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MedalEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MedalEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MedalEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MedalEffectRes

@implementation PB3MedalEffectRes

@dynamic medalListArray, medalListArray_Count;

typedef struct PB3MedalEffectRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *medalListArray;
} PB3MedalEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "medalListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Medal),
        .number = PB3MedalEffectRes_FieldNumber_MedalListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MedalEffectRes__storage_, medalListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MedalEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MedalEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3Medal

@implementation PB3Medal

@dynamic id_p;
@dynamic name;
@dynamic URL;
@dynamic pcURL2;
@dynamic effectDesc;
@dynamic extraURL;

typedef struct PB3Medal__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
  NSString *URL;
  NSString *pcURL2;
  NSString *effectDesc;
  NSString *extraURL;
} PB3Medal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcURL2",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_PcURL2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, pcURL2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectDesc",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_EffectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, effectDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extraURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_ExtraURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, extraURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Medal class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Medal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003!!!\000\004\002\241!\"\000\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProtectEffectReq

@implementation PB3ProtectEffectReq

@dynamic playerId;

typedef struct PB3ProtectEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3ProtectEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtectEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProtectEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProtectEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProtectEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProtectEffectRes

@implementation PB3ProtectEffectRes

@dynamic playerId;
@dynamic protectEffectArray, protectEffectArray_Count;

typedef struct PB3ProtectEffectRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *protectEffectArray;
  int64_t playerId;
} PB3ProtectEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtectEffectRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProtectEffectRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "protectEffectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3ProtectEffectRes_FieldNumber_ProtectEffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ProtectEffectRes__storage_, protectEffectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProtectEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProtectEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PayBannerReq

@implementation PB3PayBannerReq

@dynamic type;
@dynamic channel;
@dynamic area;

typedef struct PB3PayBannerReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType type;
  NSString *channel;
  NSString *area;
} PB3PayBannerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3PayBannerReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PayBannerReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = PB3PayBannerReq_FieldNumber_Channel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PayBannerReq__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "area",
        .dataTypeSpecific.className = NULL,
        .number = PB3PayBannerReq_FieldNumber_Area,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PayBannerReq__storage_, area),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PayBannerReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PayBannerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PayBannerReq_Type_RawValue(PB3PayBannerReq *message) {
  GPBDescriptor *descriptor = [PB3PayBannerReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PayBannerReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PayBannerReq_Type_RawValue(PB3PayBannerReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PayBannerReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PayBannerReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PayBannerItem

@implementation PB3PayBannerItem

@dynamic image;
@dynamic URL;

typedef struct PB3PayBannerItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *image;
  NSString *URL;
} PB3PayBannerItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = PB3PayBannerItem_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PayBannerItem__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PayBannerItem_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PayBannerItem__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PayBannerItem class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PayBannerItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PayBannerRes

@implementation PB3PayBannerRes

@dynamic listArray, listArray_Count;

typedef struct PB3PayBannerRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3PayBannerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PayBannerItem),
        .number = PB3PayBannerRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PayBannerRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PayBannerRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PayBannerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserReq

@implementation PB3GetUserReq

@dynamic id_p;

typedef struct PB3GetUserReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3GetUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetUserReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetUserRes

@implementation PB3GetUserRes

@dynamic id_p;
@dynamic id2;
@dynamic nickname;
@dynamic icon;
@dynamic wealthLevel;
@dynamic hasRecharge;
@dynamic isLimit;

typedef struct PB3GetUserRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t wealthLevel;
  NSString *nickname;
  NSString *icon;
  int64_t id_p;
  int64_t id2;
} PB3GetUserRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetUserRes__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetUserRes__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetUserRes__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetUserRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_WealthLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetUserRes__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hasRecharge",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_HasRecharge,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetUserRes_FieldNumber_IsLimit,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetUserRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetUserRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuthenticateData

@implementation PB3AuthenticateData

@dynamic id_p;
@dynamic icon;
@dynamic dialogIcon;
@dynamic name;

typedef struct PB3AuthenticateData__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *icon;
  NSString *dialogIcon;
  NSString *name;
} PB3AuthenticateData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthenticateData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuthenticateData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthenticateData_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuthenticateData__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialogIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthenticateData_FieldNumber_DialogIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuthenticateData__storage_, dialogIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuthenticateData_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AuthenticateData__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuthenticateData class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuthenticateData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NotifyAuthenticateDataChangeRes

@implementation PB3NotifyAuthenticateDataChangeRes

@dynamic listArray, listArray_Count;

typedef struct PB3NotifyAuthenticateDataChangeRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3NotifyAuthenticateDataChangeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuthenticateData),
        .number = PB3NotifyAuthenticateDataChangeRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3NotifyAuthenticateDataChangeRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NotifyAuthenticateDataChangeRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NotifyAuthenticateDataChangeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PersonalBillReq

@implementation PB3PersonalBillReq

@dynamic playerId;
@dynamic type;
@dynamic page;

typedef struct PB3PersonalBillReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t page;
  int64_t playerId;
} PB3PersonalBillReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PersonalBillReq__storage_, playerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PersonalBillReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillReq_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PersonalBillReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PersonalBillReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PersonalBillReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PersonalBillRes

@implementation PB3PersonalBillRes

@dynamic type;
@dynamic page;
@dynamic dataArray, dataArray_Count;
@dynamic totalGiveGold;
@dynamic totalReceiveGold;

typedef struct PB3PersonalBillRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t page;
  NSMutableArray *dataArray;
  int64_t totalGiveGold;
  int64_t totalReceiveGold;
} PB3PersonalBillRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PersonalBillRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillRes_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PersonalBillRes__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PersonalBillInfo),
        .number = PB3PersonalBillRes_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PersonalBillRes__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalGiveGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillRes_FieldNumber_TotalGiveGold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PersonalBillRes__storage_, totalGiveGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalReceiveGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillRes_FieldNumber_TotalReceiveGold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PersonalBillRes__storage_, totalReceiveGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PersonalBillRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PersonalBillRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PersonalBillInfo

@implementation PB3PersonalBillInfo

@dynamic type;
@dynamic fansId;
@dynamic fansName;
@dynamic giftId;
@dynamic giftNum;
@dynamic gold;
@dynamic createAt;
@dynamic remark;
@dynamic fansIcon;
@dynamic value;
@dynamic isAnonymous;
@dynamic isTimeLimitGift;

typedef struct PB3PersonalBillInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t giftId;
  uint32_t giftNum;
  int32_t gold;
  uint32_t createAt;
  NSString *fansName;
  NSString *remark;
  NSString *fansIcon;
  NSString *value;
  int64_t fansId;
} PB3PersonalBillInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fansId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_FansId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, fansId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "fansName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_FansName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, fansName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_GiftId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_GiftNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_Gold,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_CreateAt,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_Remark,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fansIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_FansIcon,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, fansIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_Value,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PersonalBillInfo__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAnonymous",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_IsAnonymous,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isTimeLimitGift",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBillInfo_FieldNumber_IsTimeLimitGift,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PersonalBillInfo class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PersonalBillInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WalletBillReq

@implementation PB3WalletBillReq

@dynamic lastId;
@dynamic pageSize;
@dynamic billType;
@dynamic transactionType;
@dynamic date;

typedef struct PB3WalletBillReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  PB3WalletAssetsType billType;
  PB3WalletATransactionType transactionType;
  NSString *date;
  int64_t lastId;
} PB3WalletBillReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillReq_FieldNumber_LastId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WalletBillReq__storage_, lastId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WalletBillReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "billType",
        .dataTypeSpecific.enumDescFunc = PB3WalletAssetsType_EnumDescriptor,
        .number = PB3WalletBillReq_FieldNumber_BillType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WalletBillReq__storage_, billType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transactionType",
        .dataTypeSpecific.enumDescFunc = PB3WalletATransactionType_EnumDescriptor,
        .number = PB3WalletBillReq_FieldNumber_TransactionType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WalletBillReq__storage_, transactionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "date",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillReq_FieldNumber_Date,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WalletBillReq__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletBillReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletBillReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WalletBillReq_BillType_RawValue(PB3WalletBillReq *message) {
  GPBDescriptor *descriptor = [PB3WalletBillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillReq_FieldNumber_BillType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WalletBillReq_BillType_RawValue(PB3WalletBillReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WalletBillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillReq_FieldNumber_BillType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3WalletBillReq_TransactionType_RawValue(PB3WalletBillReq *message) {
  GPBDescriptor *descriptor = [PB3WalletBillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillReq_FieldNumber_TransactionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WalletBillReq_TransactionType_RawValue(PB3WalletBillReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WalletBillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillReq_FieldNumber_TransactionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WalletBillItem

@implementation PB3WalletBillItem

@dynamic id_p;
@dynamic sceneType;
@dynamic transactionType;
@dynamic createAt;
@dynamic remark;
@dynamic hasDetail, detail;

typedef struct PB3WalletBillItem__storage_ {
  uint32_t _has_storage_[1];
  PB3WalletTrainsType sceneType;
  PB3WalletATransactionType transactionType;
  NSString *remark;
  PB3WalletTrainsDetail *detail;
  int64_t id_p;
  int64_t createAt;
} PB3WalletBillItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sceneType",
        .dataTypeSpecific.enumDescFunc = PB3WalletTrainsType_EnumDescriptor,
        .number = PB3WalletBillItem_FieldNumber_SceneType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, sceneType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transactionType",
        .dataTypeSpecific.enumDescFunc = PB3WalletATransactionType_EnumDescriptor,
        .number = PB3WalletBillItem_FieldNumber_TransactionType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, transactionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillItem_FieldNumber_CreateAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillItem_FieldNumber_Remark,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletTrainsDetail),
        .number = PB3WalletBillItem_FieldNumber_Detail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WalletBillItem__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletBillItem class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletBillItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WalletBillItem_SceneType_RawValue(PB3WalletBillItem *message) {
  GPBDescriptor *descriptor = [PB3WalletBillItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillItem_FieldNumber_SceneType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WalletBillItem_SceneType_RawValue(PB3WalletBillItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WalletBillItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillItem_FieldNumber_SceneType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3WalletBillItem_TransactionType_RawValue(PB3WalletBillItem *message) {
  GPBDescriptor *descriptor = [PB3WalletBillItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillItem_FieldNumber_TransactionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WalletBillItem_TransactionType_RawValue(PB3WalletBillItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WalletBillItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WalletBillItem_FieldNumber_TransactionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WalletBillGroupTotal

@implementation PB3WalletBillGroupTotal

@dynamic incomeTotal;
@dynamic payTotal;

typedef struct PB3WalletBillGroupTotal__storage_ {
  uint32_t _has_storage_[1];
  int64_t incomeTotal;
  int64_t payTotal;
} PB3WalletBillGroupTotal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incomeTotal",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillGroupTotal_FieldNumber_IncomeTotal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WalletBillGroupTotal__storage_, incomeTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "payTotal",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletBillGroupTotal_FieldNumber_PayTotal,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WalletBillGroupTotal__storage_, payTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletBillGroupTotal class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletBillGroupTotal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WalletBillRes

@implementation PB3WalletBillRes

@dynamic listArray, listArray_Count;

typedef struct PB3WalletBillRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3WalletBillRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletBillItem),
        .number = PB3WalletBillRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WalletBillRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletBillRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletBillRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WalletTrainsDetail

@implementation PB3WalletTrainsDetail

@dynamic unionOneOfCase;
@dynamic generalRecharge;
@dynamic systemRelease;
@dynamic sendGiftDetail;
@dynamic giftSharing;
@dynamic agentRecharge;
@dynamic mallShopping;
@dynamic clan;
@dynamic systemDeduct;
@dynamic ticketExchangeGold;
@dynamic singleGold;
@dynamic clanWelfare;
@dynamic activity;

typedef struct PB3WalletTrainsDetail__storage_ {
  uint32_t _has_storage_[2];
  PB3WTD_GeneralRecharge *generalRecharge;
  PB3WTD_SystemRelease *systemRelease;
  PB3WTD_SendGiftDetail *sendGiftDetail;
  PB3WTD_GiftSharing *giftSharing;
  PB3WTD_AgentRecharge *agentRecharge;
  PB3WTD_MallShopping *mallShopping;
  PB3WTD_Clan *clan;
  PB3WTD_SystemDeduct *systemDeduct;
  PB3WTD_TicketExchangeGold *ticketExchangeGold;
  PB3WTD_SingleGold *singleGold;
  PB3WTD_ClanWelfare *clanWelfare;
  PB3WTD_Activity *activity;
} PB3WalletTrainsDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "generalRecharge",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_GeneralRecharge),
        .number = PB3WalletTrainsDetail_FieldNumber_GeneralRecharge,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, generalRecharge),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "systemRelease",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_SystemRelease),
        .number = PB3WalletTrainsDetail_FieldNumber_SystemRelease,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, systemRelease),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendGiftDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_SendGiftDetail),
        .number = PB3WalletTrainsDetail_FieldNumber_SendGiftDetail,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, sendGiftDetail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftSharing",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_GiftSharing),
        .number = PB3WalletTrainsDetail_FieldNumber_GiftSharing,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, giftSharing),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "agentRecharge",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_AgentRecharge),
        .number = PB3WalletTrainsDetail_FieldNumber_AgentRecharge,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, agentRecharge),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mallShopping",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_MallShopping),
        .number = PB3WalletTrainsDetail_FieldNumber_MallShopping,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, mallShopping),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_Clan),
        .number = PB3WalletTrainsDetail_FieldNumber_Clan,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, clan),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "systemDeduct",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_SystemDeduct),
        .number = PB3WalletTrainsDetail_FieldNumber_SystemDeduct,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, systemDeduct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticketExchangeGold",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_TicketExchangeGold),
        .number = PB3WalletTrainsDetail_FieldNumber_TicketExchangeGold,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, ticketExchangeGold),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singleGold",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_SingleGold),
        .number = PB3WalletTrainsDetail_FieldNumber_SingleGold,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, singleGold),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clanWelfare",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_ClanWelfare),
        .number = PB3WalletTrainsDetail_FieldNumber_ClanWelfare,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, clanWelfare),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activity",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WTD_Activity),
        .number = PB3WalletTrainsDetail_FieldNumber_Activity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3WalletTrainsDetail__storage_, activity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletTrainsDetail class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletTrainsDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "union",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\001O\000\002M\000\003N\000\004K\000\005M\000\007L\000\010D\000\tL\000\nR\000\013J\000\014K\000\016H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void PB3WalletTrainsDetail_ClearUnionOneOfCase(PB3WalletTrainsDetail *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3WTD_GeneralRecharge

@implementation PB3WTD_GeneralRecharge

@dynamic gold;

typedef struct PB3WTD_GeneralRecharge__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
} PB3WTD_GeneralRecharge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_GeneralRecharge_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_GeneralRecharge__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_GeneralRecharge class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_GeneralRecharge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_SystemRelease

@implementation PB3WTD_SystemRelease

@dynamic gold;
@dynamic ticketCents;

typedef struct PB3WTD_SystemRelease__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
  double ticketCents;
} PB3WTD_SystemRelease__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SystemRelease_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_SystemRelease__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SystemRelease_FieldNumber_TicketCents,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_SystemRelease__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_SystemRelease class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_SystemRelease__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_SendGiftDetail

@implementation PB3WTD_SendGiftDetail

@dynamic gold;
@dynamic hasToInfo, toInfo;
@dynamic hasGiftItem, giftItem;

typedef struct PB3WTD_SendGiftDetail__storage_ {
  uint32_t _has_storage_[1];
  PB3Player *toInfo;
  PB3WalletGiftItem *giftItem;
  int64_t gold;
} PB3WTD_SendGiftDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SendGiftDetail_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_SendGiftDetail__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Player),
        .number = PB3WTD_SendGiftDetail_FieldNumber_ToInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_SendGiftDetail__storage_, toInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftItem",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletGiftItem),
        .number = PB3WTD_SendGiftDetail_FieldNumber_GiftItem,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WTD_SendGiftDetail__storage_, giftItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_SendGiftDetail class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_SendGiftDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_GiftSharing

@implementation PB3WTD_GiftSharing

@dynamic ticket;
@dynamic hasFromInfo, fromInfo;
@dynamic hasGiftItem, giftItem;
@dynamic ticketCents;

typedef struct PB3WTD_GiftSharing__storage_ {
  uint32_t _has_storage_[1];
  PB3Player *fromInfo;
  PB3WalletGiftItem *giftItem;
  int64_t ticket;
  double ticketCents;
} PB3WTD_GiftSharing__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_GiftSharing_FieldNumber_Ticket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_GiftSharing__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fromInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Player),
        .number = PB3WTD_GiftSharing_FieldNumber_FromInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_GiftSharing__storage_, fromInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftItem",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletGiftItem),
        .number = PB3WTD_GiftSharing_FieldNumber_GiftItem,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WTD_GiftSharing__storage_, giftItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_GiftSharing_FieldNumber_TicketCents,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WTD_GiftSharing__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_GiftSharing class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_GiftSharing__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_Clan

@implementation PB3WTD_Clan

@dynamic ticket;
@dynamic hasFromInfo, fromInfo;
@dynamic hasGiftItem, giftItem;
@dynamic ticketCents;

typedef struct PB3WTD_Clan__storage_ {
  uint32_t _has_storage_[1];
  PB3Player *fromInfo;
  PB3WalletGiftItem *giftItem;
  int64_t ticket;
  double ticketCents;
} PB3WTD_Clan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_Clan_FieldNumber_Ticket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_Clan__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fromInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Player),
        .number = PB3WTD_Clan_FieldNumber_FromInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_Clan__storage_, fromInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftItem",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletGiftItem),
        .number = PB3WTD_Clan_FieldNumber_GiftItem,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WTD_Clan__storage_, giftItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_Clan_FieldNumber_TicketCents,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WTD_Clan__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_Clan class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_Clan__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_AgentRecharge

@implementation PB3WTD_AgentRecharge

@dynamic gold;

typedef struct PB3WTD_AgentRecharge__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
} PB3WTD_AgentRecharge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_AgentRecharge_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_AgentRecharge__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_AgentRecharge class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_AgentRecharge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_MallShopping

@implementation PB3WTD_MallShopping

@dynamic gold;
@dynamic hasGiftItem, giftItem;

typedef struct PB3WTD_MallShopping__storage_ {
  uint32_t _has_storage_[1];
  PB3WalletGiftItem *giftItem;
  int64_t gold;
} PB3WTD_MallShopping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_MallShopping_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_MallShopping__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftItem",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WalletGiftItem),
        .number = PB3WTD_MallShopping_FieldNumber_GiftItem,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_MallShopping__storage_, giftItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_MallShopping class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_MallShopping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_SystemDeduct

@implementation PB3WTD_SystemDeduct

@dynamic gold;
@dynamic ticketCents;

typedef struct PB3WTD_SystemDeduct__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
  double ticketCents;
} PB3WTD_SystemDeduct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SystemDeduct_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_SystemDeduct__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SystemDeduct_FieldNumber_TicketCents,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_SystemDeduct__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_SystemDeduct class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_SystemDeduct__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_TicketExchangeGold

@implementation PB3WTD_TicketExchangeGold

@dynamic gold;
@dynamic ticketCents;

typedef struct PB3WTD_TicketExchangeGold__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
  double ticketCents;
} PB3WTD_TicketExchangeGold__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_TicketExchangeGold_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_TicketExchangeGold__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_TicketExchangeGold_FieldNumber_TicketCents,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_TicketExchangeGold__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_TicketExchangeGold class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_TicketExchangeGold__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_SingleGold

@implementation PB3WTD_SingleGold

@dynamic gold;

typedef struct PB3WTD_SingleGold__storage_ {
  uint32_t _has_storage_[1];
  int64_t gold;
} PB3WTD_SingleGold__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_SingleGold_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_SingleGold__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_SingleGold class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_SingleGold__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_ClanWelfare

@implementation PB3WTD_ClanWelfare

@dynamic ticketCents;

typedef struct PB3WTD_ClanWelfare__storage_ {
  uint32_t _has_storage_[1];
  double ticketCents;
} PB3WTD_ClanWelfare__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticketCents",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_ClanWelfare_FieldNumber_TicketCents,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_ClanWelfare__storage_, ticketCents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_ClanWelfare class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_ClanWelfare__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WTD_Activity

@implementation PB3WTD_Activity

@dynamic gold;
@dynamic actName;

typedef struct PB3WTD_Activity__storage_ {
  uint32_t _has_storage_[1];
  NSString *actName;
  int64_t gold;
} PB3WTD_Activity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_Activity_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WTD_Activity__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "actName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WTD_Activity_FieldNumber_ActName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WTD_Activity__storage_, actName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WTD_Activity class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WTD_Activity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WalletGiftItem

@implementation PB3WalletGiftItem

@dynamic giftId;
@dynamic giftName;
@dynamic imageURL;

typedef struct PB3WalletGiftItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t giftId;
  NSString *giftName;
  NSString *imageURL;
} PB3WalletGiftItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletGiftItem_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WalletGiftItem__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletGiftItem_FieldNumber_GiftName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WalletGiftItem__storage_, giftName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3WalletGiftItem_FieldNumber_ImageURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WalletGiftItem__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WalletGiftItem class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WalletGiftItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InvoiceInfo

@implementation PB3InvoiceInfo

@dynamic email;
@dynamic phone;
@dynamic invoiceType;
@dynamic isDonate;
@dynamic name;
@dynamic donateCode;
@dynamic carrierType;
@dynamic carrierNum;

typedef struct PB3InvoiceInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3InvoiceType invoiceType;
  PB3EzPayCarrierType carrierType;
  NSString *email;
  NSString *phone;
  NSString *name;
  NSString *donateCode;
  NSString *carrierNum;
} PB3InvoiceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "invoiceType",
        .dataTypeSpecific.enumDescFunc = PB3InvoiceType_EnumDescriptor,
        .number = PB3InvoiceInfo_FieldNumber_InvoiceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, invoiceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isDonate",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_IsDonate,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "donateCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_DonateCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, donateCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "carrierType",
        .dataTypeSpecific.enumDescFunc = PB3EzPayCarrierType_EnumDescriptor,
        .number = PB3InvoiceInfo_FieldNumber_CarrierType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, carrierType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "carrierNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3InvoiceInfo_FieldNumber_CarrierNum,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3InvoiceInfo__storage_, carrierNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InvoiceInfo class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InvoiceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InvoiceInfo_InvoiceType_RawValue(PB3InvoiceInfo *message) {
  GPBDescriptor *descriptor = [PB3InvoiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InvoiceInfo_FieldNumber_InvoiceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InvoiceInfo_InvoiceType_RawValue(PB3InvoiceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InvoiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InvoiceInfo_FieldNumber_InvoiceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3InvoiceInfo_CarrierType_RawValue(PB3InvoiceInfo *message) {
  GPBDescriptor *descriptor = [PB3InvoiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InvoiceInfo_FieldNumber_CarrierType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InvoiceInfo_CarrierType_RawValue(PB3InvoiceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InvoiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InvoiceInfo_FieldNumber_CarrierType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3RequestPayRes

@implementation PB3RequestPayRes

@dynamic type;
@dynamic actionURL;
@dynamic data_p, data_p_Count;
@dynamic orderId;
@dynamic orderId3Rd;

typedef struct PB3RequestPayRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ResponseType type;
  NSString *actionURL;
  NSMutableDictionary *data_p;
  NSString *orderId;
  NSString *orderId3Rd;
} PB3RequestPayRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3ResponseType_EnumDescriptor,
        .number = PB3RequestPayRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RequestPayRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "actionURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3RequestPayRes_FieldNumber_ActionURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RequestPayRes__storage_, actionURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3RequestPayRes_FieldNumber_Data_p,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RequestPayRes__storage_, data_p),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RequestPayRes_FieldNumber_OrderId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RequestPayRes__storage_, orderId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderId3Rd",
        .dataTypeSpecific.className = NULL,
        .number = PB3RequestPayRes_FieldNumber_OrderId3Rd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3RequestPayRes__storage_, orderId3Rd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RequestPayRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RequestPayRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\006\241!!\000\005\005\242\201\"\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3RequestPayRes_Type_RawValue(PB3RequestPayRes *message) {
  GPBDescriptor *descriptor = [PB3RequestPayRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RequestPayRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3RequestPayRes_Type_RawValue(PB3RequestPayRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3RequestPayRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3RequestPayRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
