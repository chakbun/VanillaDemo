// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/assets.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/AssetsExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3AssetsExtRoot

@implementation PB3AssetsExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3AssetsExtRoot_FileDescriptor

static GPBFileDescriptor *PB3AssetsExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3AssetsCmdId

GPBEnumDescriptor *PB3AssetsCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AssetsNone1\000AssetsMoneyCmdId\000AssetsBagCm"
        "dId\000AssetsEffectPlayer\000AssetsEffectRoom\000"
        "AssetsEffectTips\000AssetsInDebtCmdId\000Asset"
        "sPointCmdId\000AssetsIsPayTodayCmdId\000";
    static const int32_t values[] = {
        PB3AssetsCmdId_AssetsNone1,
        PB3AssetsCmdId_AssetsMoneyCmdId,
        PB3AssetsCmdId_AssetsBagCmdId,
        PB3AssetsCmdId_AssetsEffectPlayer,
        PB3AssetsCmdId_AssetsEffectRoom,
        PB3AssetsCmdId_AssetsEffectTips,
        PB3AssetsCmdId_AssetsInDebtCmdId,
        PB3AssetsCmdId_AssetsPointCmdId,
        PB3AssetsCmdId_AssetsIsPayTodayCmdId,
    };
    static const char *extraTextFormatInfo = "\t\000\013\000\001\020\000\002\016\000\003\022\000\004\020\000\005\020\000\006\021\000\007\020\000\010\025\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AssetsCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AssetsCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AssetsCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AssetsCmdId_AssetsNone1:
    case PB3AssetsCmdId_AssetsMoneyCmdId:
    case PB3AssetsCmdId_AssetsBagCmdId:
    case PB3AssetsCmdId_AssetsEffectPlayer:
    case PB3AssetsCmdId_AssetsEffectRoom:
    case PB3AssetsCmdId_AssetsEffectTips:
    case PB3AssetsCmdId_AssetsInDebtCmdId:
    case PB3AssetsCmdId_AssetsPointCmdId:
    case PB3AssetsCmdId_AssetsIsPayTodayCmdId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PointType

GPBEnumDescriptor *PB3PointType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PointZero\000PointStore\000PointPlayer\000";
    static const int32_t values[] = {
        PB3PointType_PointZero,
        PB3PointType_PointStore,
        PB3PointType_PointPlayer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PointType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PointType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PointType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PointType_PointZero:
    case PB3PointType_PointStore:
    case PB3PointType_PointPlayer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PlayerAssetsType

GPBEnumDescriptor *PB3PlayerAssetsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PatNone\000PatGold\000PatGiftTicket\000PatGift\000Pa"
        "tCharge\000PatPoint\000PatCoupon\000PatRiskTicket"
        "\000PatRiskPenaltyTicket\000PatDeposit\000PatFree"
        "zeDeposit\000PatNobleGold\000PatChargeGold\000Pat"
        "GoldTicket\000PatGiftSkin\000PatEffect\000";
    static const int32_t values[] = {
        PB3PlayerAssetsType_PatNone,
        PB3PlayerAssetsType_PatGold,
        PB3PlayerAssetsType_PatGiftTicket,
        PB3PlayerAssetsType_PatGift,
        PB3PlayerAssetsType_PatCharge,
        PB3PlayerAssetsType_PatPoint,
        PB3PlayerAssetsType_PatCoupon,
        PB3PlayerAssetsType_PatRiskTicket,
        PB3PlayerAssetsType_PatRiskPenaltyTicket,
        PB3PlayerAssetsType_PatDeposit,
        PB3PlayerAssetsType_PatFreezeDeposit,
        PB3PlayerAssetsType_PatNobleGold,
        PB3PlayerAssetsType_PatChargeGold,
        PB3PlayerAssetsType_PatGoldTicket,
        PB3PlayerAssetsType_PatGiftSkin,
        PB3PlayerAssetsType_PatEffect,
    };
    static const char *extraTextFormatInfo = "\020\000c\204\000\001c\204\000\002c\212\000\003c\204\000\004c\206\000\005c\205\000\006c\206\000\007c\212\000\010c\221\000\tc\207\000\nc\215\000\013c\211\000\014c\212\000\rc\212\000\016c\210\000\017c\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PlayerAssetsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PlayerAssetsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PlayerAssetsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PlayerAssetsType_PatNone:
    case PB3PlayerAssetsType_PatGold:
    case PB3PlayerAssetsType_PatGiftTicket:
    case PB3PlayerAssetsType_PatGift:
    case PB3PlayerAssetsType_PatCharge:
    case PB3PlayerAssetsType_PatPoint:
    case PB3PlayerAssetsType_PatCoupon:
    case PB3PlayerAssetsType_PatRiskTicket:
    case PB3PlayerAssetsType_PatRiskPenaltyTicket:
    case PB3PlayerAssetsType_PatDeposit:
    case PB3PlayerAssetsType_PatFreezeDeposit:
    case PB3PlayerAssetsType_PatNobleGold:
    case PB3PlayerAssetsType_PatChargeGold:
    case PB3PlayerAssetsType_PatGoldTicket:
    case PB3PlayerAssetsType_PatGiftSkin:
    case PB3PlayerAssetsType_PatEffect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AssetsType

GPBEnumDescriptor *PB3AssetsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AtZero\000AtHammer\000AtPoints\000AtHammerGold\000At"
        "HammerDo\000AtHammerBlackGold\000";
    static const int32_t values[] = {
        PB3AssetsType_AtZero,
        PB3AssetsType_AtHammer,
        PB3AssetsType_AtPoints,
        PB3AssetsType_AtHammerGold,
        PB3AssetsType_AtHammerDo,
        PB3AssetsType_AtHammerBlackGold,
    };
    static const char *extraTextFormatInfo = "\004\001b\206\000\003b\206\204\000\004b\206\342\000\005b\206\205\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AssetsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AssetsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AssetsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AssetsType_AtZero:
    case PB3AssetsType_AtHammer:
    case PB3AssetsType_AtPoints:
    case PB3AssetsType_AtHammerGold:
    case PB3AssetsType_AtHammerDo:
    case PB3AssetsType_AtHammerBlackGold:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BizSettlementStatusType

GPBEnumDescriptor *PB3BizSettlementStatusType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BsstAll\000BsstNormal\000BsstChecking\000BsstSett"
        "lement\000BsstUnfreeze\000";
    static const int32_t values[] = {
        PB3BizSettlementStatusType_BsstAll,
        PB3BizSettlementStatusType_BsstNormal,
        PB3BizSettlementStatusType_BsstChecking,
        PB3BizSettlementStatusType_BsstSettlement,
        PB3BizSettlementStatusType_BsstUnfreeze,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BizSettlementStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BizSettlementStatusType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BizSettlementStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BizSettlementStatusType_BsstAll:
    case PB3BizSettlementStatusType_BsstNormal:
    case PB3BizSettlementStatusType_BsstChecking:
    case PB3BizSettlementStatusType_BsstSettlement:
    case PB3BizSettlementStatusType_BsstUnfreeze:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3AssetsMoneyReq

@implementation PB3AssetsMoneyReq


typedef struct PB3AssetsMoneyReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsMoneyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoneyReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsMoneyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsMoney

@implementation PB3AssetsMoney

@dynamic gold;
@dynamic silver;
@dynamic giftTicket;
@dynamic charge;
@dynamic freezeTicket;
@dynamic assetsMap, assetsMap_Count;
@dynamic vipWeixinCustomService;
@dynamic vipWeixinCustomServiceURL;
@dynamic vipWeixinCustomServiceId;

typedef struct PB3AssetsMoney__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  uint32_t silver;
  uint32_t giftTicket;
  uint32_t charge;
  uint32_t freezeTicket;
  int32_t vipWeixinCustomService;
  GPBInt64ObjectDictionary *assetsMap;
  NSString *vipWeixinCustomServiceURL;
  NSString *vipWeixinCustomServiceId;
} PB3AssetsMoney__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "silver",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Silver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, silver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftTicket",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_GiftTicket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, giftTicket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "charge",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_Charge,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, charge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "freezeTicket",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_FreezeTicket,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, freezeTicket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "assetsMap",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerAssets),
        .number = PB3AssetsMoney_FieldNumber_AssetsMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, assetsMap),
        .flags = GPBFieldMapKeyInt64,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vipWeixinCustomService",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_VipWeixinCustomService,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, vipWeixinCustomService),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vipWeixinCustomServiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_VipWeixinCustomServiceURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, vipWeixinCustomServiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vipWeixinCustomServiceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoney_FieldNumber_VipWeixinCustomServiceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AssetsMoney__storage_, vipWeixinCustomServiceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoney class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsMoney__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\003\246\246\247\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsBag

@implementation PB3AssetsBag

@dynamic itemsArray, itemsArray_Count;

typedef struct PB3AssetsBag__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} PB3AssetsBag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BagItem),
        .number = PB3AssetsBag_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsBag__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBag class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsBag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsMoneyRes

@implementation PB3AssetsMoneyRes

@dynamic flag;
@dynamic hasMoney, money;
@dynamic isBanWithdrawal;
@dynamic banWithdrawalTime;
@dynamic hasPrivilege, privilege;

typedef struct PB3AssetsMoneyRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flag;
  PB3AssetsMoney *money;
  NSString *banWithdrawalTime;
  PB3CreditScorePrivilege *privilege;
} PB3AssetsMoneyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoneyRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "money",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AssetsMoney),
        .number = PB3AssetsMoneyRes_FieldNumber_Money,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, money),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isBanWithdrawal",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoneyRes_FieldNumber_IsBanWithdrawal,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "banWithdrawalTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsMoneyRes_FieldNumber_BanWithdrawalTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, banWithdrawalTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "privilege",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CreditScorePrivilege),
        .number = PB3AssetsMoneyRes_FieldNumber_Privilege,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AssetsMoneyRes__storage_, privilege),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsMoneyRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsMoneyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPointReq

@implementation PB3AssetsPointReq


typedef struct PB3AssetsPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPointReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPointRes

@implementation PB3AssetsPointRes

@dynamic point, point_Count;

typedef struct PB3AssetsPointRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *point;
} PB3AssetsPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "point",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AssetsPoint),
        .number = PB3AssetsPointRes_FieldNumber_Point,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsPointRes__storage_, point),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPointRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsPoint

@implementation PB3AssetsPoint

@dynamic pointType;
@dynamic num;

typedef struct PB3AssetsPoint__storage_ {
  uint32_t _has_storage_[1];
  PB3PointType pointType;
  uint32_t num;
} PB3AssetsPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pointType",
        .dataTypeSpecific.enumDescFunc = PB3PointType_EnumDescriptor,
        .number = PB3AssetsPoint_FieldNumber_PointType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsPoint__storage_, pointType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsPoint_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AssetsPoint__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsPoint class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AssetsPoint_PointType_RawValue(PB3AssetsPoint *message) {
  GPBDescriptor *descriptor = [PB3AssetsPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AssetsPoint_FieldNumber_PointType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AssetsPoint_PointType_RawValue(PB3AssetsPoint *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AssetsPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AssetsPoint_FieldNumber_PointType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PlayerAssets

@implementation PB3PlayerAssets

@dynamic assetsType;
@dynamic assetsNum;

typedef struct PB3PlayerAssets__storage_ {
  uint32_t _has_storage_[1];
  PB3PlayerAssetsType assetsType;
  int64_t assetsNum;
} PB3PlayerAssets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetsType",
        .dataTypeSpecific.enumDescFunc = PB3PlayerAssetsType_EnumDescriptor,
        .number = PB3PlayerAssets_FieldNumber_AssetsType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerAssets__storage_, assetsType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "assetsNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAssets_FieldNumber_AssetsNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerAssets__storage_, assetsNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAssets class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAssets__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PlayerAssets_AssetsType_RawValue(PB3PlayerAssets *message) {
  GPBDescriptor *descriptor = [PB3PlayerAssets descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerAssets_FieldNumber_AssetsType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PlayerAssets_AssetsType_RawValue(PB3PlayerAssets *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PlayerAssets descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerAssets_FieldNumber_AssetsType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AssetsBagReq

@implementation PB3AssetsBagReq


typedef struct PB3AssetsBagReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AssetsBagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBagReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AssetsBagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsBagRes

@implementation PB3AssetsBagRes

@dynamic flag;
@dynamic itemsArray, itemsArray_Count;

typedef struct PB3AssetsBagRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flag;
  NSMutableArray *itemsArray;
} PB3AssetsBagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsBagRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsBagRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BagItem),
        .number = PB3AssetsBagRes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AssetsBagRes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsBagRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsBagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BcPlayerEffect

@implementation PB3BcPlayerEffect

@dynamic playerId;
@dynamic effectArray, effectArray_Count;

typedef struct PB3BcPlayerEffect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectArray;
  int64_t playerId;
} PB3BcPlayerEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BcPlayerEffect_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BcPlayerEffect__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3BcPlayerEffect_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BcPlayerEffect__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BcPlayerEffect class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BcPlayerEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BcRoomEffect

@implementation PB3BcRoomEffect

@dynamic playerId;
@dynamic effectArray, effectArray_Count;

typedef struct PB3BcRoomEffect__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectArray;
  int64_t playerId;
} PB3BcRoomEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BcRoomEffect_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BcRoomEffect__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3BcRoomEffect_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BcRoomEffect__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BcRoomEffect class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BcRoomEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigReq

@implementation PB3EffectConfigReq

@dynamic effectIdsArray, effectIdsArray_Count;

typedef struct PB3EffectConfigReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *effectIdsArray;
} PB3EffectConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectConfigReq_FieldNumber_EffectIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EffectConfigReq__storage_, effectIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigRes

@implementation PB3EffectConfigRes

@dynamic list, list_Count;

typedef struct PB3EffectConfigRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *list;
} PB3EffectConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "list",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EffectConfig),
        .number = PB3EffectConfigRes_FieldNumber_List,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EffectConfigRes__storage_, list),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigCDNReq

@implementation PB3EffectConfigCDNReq


typedef struct PB3EffectConfigCDNReq__storage_ {
  uint32_t _has_storage_[1];
} PB3EffectConfigCDNReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigCDNReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3EffectConfigCDNReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectConfigCDNRes

@implementation PB3EffectConfigCDNRes

@dynamic confURL;

typedef struct PB3EffectConfigCDNRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *confURL;
} PB3EffectConfigCDNRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectConfigCDNRes_FieldNumber_ConfURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EffectConfigCDNRes__storage_, confURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectConfigCDNRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectConfigCDNRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetEffectReq

@implementation PB3GetEffectReq

@dynamic playerId;

typedef struct PB3GetEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetEffectRes

@implementation PB3GetEffectRes

@dynamic flag;
@dynamic playerId;
@dynamic effectArray, effectArray_Count;
@dynamic protectEffectArray, protectEffectArray_Count;
@dynamic effectLimitArray, effectLimitArray_Count;

typedef struct PB3GetEffectRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t flag;
  NSMutableArray *effectArray;
  NSMutableArray *protectEffectArray;
  NSMutableArray *effectLimitArray;
  int64_t playerId;
} PB3GetEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetEffectRes_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3GetEffectRes_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "protectEffectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3GetEffectRes_FieldNumber_ProtectEffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, protectEffectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effectLimitArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EffectLimit),
        .number = PB3GetEffectRes_FieldNumber_EffectLimitArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetEffectRes__storage_, effectLimitArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EffectTips

@implementation PB3EffectTips

@dynamic effectId;
@dynamic effectName;
@dynamic tipType;
@dynamic timeoutArray, timeoutArray_Count;
@dynamic timeoutSecond;
@dynamic type;
@dynamic timeType;
@dynamic msg;

typedef struct PB3EffectTips__storage_ {
  uint32_t _has_storage_[1];
  int32_t effectId;
  PB3EffectTipsType tipType;
  int32_t timeoutSecond;
  PB3EffectType type;
  PB3EffectTimeType timeType;
  NSString *effectName;
  GPBInt32Array *timeoutArray;
  NSString *msg;
} PB3EffectTips__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectId",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_EffectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, effectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectName",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_EffectName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, effectName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tipType",
        .dataTypeSpecific.enumDescFunc = PB3EffectTipsType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_TipType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, tipType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeoutArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_TimeoutArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeoutArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeoutSecond",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_TimeoutSecond,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeoutSecond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3EffectType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timeType",
        .dataTypeSpecific.enumDescFunc = PB3EffectTimeType_EnumDescriptor,
        .number = PB3EffectTips_FieldNumber_TimeType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, timeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3EffectTips_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3EffectTips__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EffectTips class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EffectTips__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3EffectTips_TipType_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_TipType_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3EffectTips_Type_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_Type_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3EffectTips_TimeType_RawValue(PB3EffectTips *message) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TimeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EffectTips_TimeType_RawValue(PB3EffectTips *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EffectTips descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EffectTips_FieldNumber_TimeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AsstesDetail

@implementation PB3AsstesDetail

@dynamic id_p;

typedef struct PB3AsstesDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3AsstesDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AsstesDetail_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AsstesDetail__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AsstesDetail class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AsstesDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AsstesCollection

@implementation PB3AsstesCollection

@dynamic icon;
@dynamic listArray, listArray_Count;

typedef struct PB3AsstesCollection__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  NSMutableArray *listArray;
} PB3AsstesCollection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AsstesCollection_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AsstesCollection__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AsstesDetail),
        .number = PB3AsstesCollection_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AsstesCollection__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AsstesCollection class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AsstesCollection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAssetsConfReq

@implementation PB3GetAssetsConfReq


typedef struct PB3GetAssetsConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAssetsConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAssetsConfReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAssetsConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAssetsConfRes

@implementation PB3GetAssetsConfRes

@dynamic assetsConf, assetsConf_Count;

typedef struct PB3GetAssetsConfRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *assetsConf;
} PB3GetAssetsConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetsConf",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AsstesCollection),
        .number = PB3GetAssetsConfRes_FieldNumber_AssetsConf,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetAssetsConfRes__storage_, assetsConf),
        .flags = GPBFieldMapKeySInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAssetsConfRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAssetsConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UseEffectReq

@implementation PB3UseEffectReq

@dynamic id_p;
@dynamic useType;

typedef struct PB3UseEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3EffectUseType useType;
} PB3UseEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UseEffectReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UseEffectReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useType",
        .dataTypeSpecific.enumDescFunc = PB3EffectUseType_EnumDescriptor,
        .number = PB3UseEffectReq_FieldNumber_UseType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UseEffectReq__storage_, useType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UseEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UseEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UseEffectReq_UseType_RawValue(PB3UseEffectReq *message) {
  GPBDescriptor *descriptor = [PB3UseEffectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectReq_FieldNumber_UseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UseEffectReq_UseType_RawValue(PB3UseEffectReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UseEffectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectReq_FieldNumber_UseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UseEffectRes

@implementation PB3UseEffectRes

@dynamic type;

typedef struct PB3UseEffectRes__storage_ {
  uint32_t _has_storage_[1];
  PB3EffectType type;
} PB3UseEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3EffectType_EnumDescriptor,
        .number = PB3UseEffectRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UseEffectRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UseEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UseEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UseEffectRes_Type_RawValue(PB3UseEffectRes *message) {
  GPBDescriptor *descriptor = [PB3UseEffectRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UseEffectRes_Type_RawValue(PB3UseEffectRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UseEffectRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UseEffectRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3NobilityEffectConfReq

@implementation PB3NobilityEffectConfReq


typedef struct PB3NobilityEffectConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3NobilityEffectConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NobilityEffectConfReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3NobilityEffectConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NobilityEffectConfRes

@implementation PB3NobilityEffectConfRes

@dynamic itemArray, itemArray_Count;

typedef struct PB3NobilityEffectConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB3NobilityEffectConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3NobilityEffectItem),
        .number = PB3NobilityEffectConfRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3NobilityEffectConfRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NobilityEffectConfRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NobilityEffectConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3NobilityEffectItem

@implementation PB3NobilityEffectItem

@dynamic nobilityId;
@dynamic effectId;
@dynamic privilegeId;

typedef struct PB3NobilityEffectItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t nobilityId;
  int32_t effectId;
  int32_t privilegeId;
} PB3NobilityEffectItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nobilityId",
        .dataTypeSpecific.className = NULL,
        .number = PB3NobilityEffectItem_FieldNumber_NobilityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3NobilityEffectItem__storage_, nobilityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectId",
        .dataTypeSpecific.className = NULL,
        .number = PB3NobilityEffectItem_FieldNumber_EffectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3NobilityEffectItem__storage_, effectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "privilegeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3NobilityEffectItem_FieldNumber_PrivilegeId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3NobilityEffectItem__storage_, privilegeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3NobilityEffectItem class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3NobilityEffectItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InDebtInfoReq

@implementation PB3InDebtInfoReq


typedef struct PB3InDebtInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InDebtInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InDebtInfoReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InDebtInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InDebtInfoRes

@implementation PB3InDebtInfoRes

@dynamic inDebtTick;

typedef struct PB3InDebtInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t inDebtTick;
} PB3InDebtInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inDebtTick",
        .dataTypeSpecific.className = NULL,
        .number = PB3InDebtInfoRes_FieldNumber_InDebtTick,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InDebtInfoRes__storage_, inDebtTick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InDebtInfoRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InDebtInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AssetsInDebt

@implementation PB3AssetsInDebt

@dynamic inDebtTick;

typedef struct PB3AssetsInDebt__storage_ {
  uint32_t _has_storage_[1];
  int64_t inDebtTick;
} PB3AssetsInDebt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inDebtTick",
        .dataTypeSpecific.className = NULL,
        .number = PB3AssetsInDebt_FieldNumber_InDebtTick,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AssetsInDebt__storage_, inDebtTick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AssetsInDebt class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AssetsInDebt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MedalEffectReq

@implementation PB3MedalEffectReq

@dynamic playerId;

typedef struct PB3MedalEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3MedalEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MedalEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MedalEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MedalEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MedalEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MedalEffectRes

@implementation PB3MedalEffectRes

@dynamic medalListArray, medalListArray_Count;

typedef struct PB3MedalEffectRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *medalListArray;
} PB3MedalEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "medalListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Medal),
        .number = PB3MedalEffectRes_FieldNumber_MedalListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MedalEffectRes__storage_, medalListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MedalEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MedalEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3Medal

@implementation PB3Medal

@dynamic id_p;
@dynamic name;
@dynamic URL;
@dynamic pcURL2;
@dynamic effectDesc;
@dynamic extraURL;

typedef struct PB3Medal__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
  NSString *URL;
  NSString *pcURL2;
  NSString *effectDesc;
  NSString *extraURL;
} PB3Medal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcURL2",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_PcURL2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, pcURL2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectDesc",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_EffectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, effectDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extraURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3Medal_FieldNumber_ExtraURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Medal__storage_, extraURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Medal class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Medal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003!!!\000\004\002\241!\"\000\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProtectEffectReq

@implementation PB3ProtectEffectReq

@dynamic playerId;

typedef struct PB3ProtectEffectReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3ProtectEffectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtectEffectReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProtectEffectReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProtectEffectReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProtectEffectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProtectEffectRes

@implementation PB3ProtectEffectRes

@dynamic playerId;
@dynamic protectEffectArray, protectEffectArray_Count;

typedef struct PB3ProtectEffectRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *protectEffectArray;
  int64_t playerId;
} PB3ProtectEffectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtectEffectRes_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProtectEffectRes__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "protectEffectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Effect),
        .number = PB3ProtectEffectRes_FieldNumber_ProtectEffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ProtectEffectRes__storage_, protectEffectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProtectEffectRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProtectEffectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PushFirstPayGift

@implementation PB3PushFirstPayGift

@dynamic isPayToday;

typedef struct PB3PushFirstPayGift__storage_ {
  uint32_t _has_storage_[1];
} PB3PushFirstPayGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPayToday",
        .dataTypeSpecific.className = NULL,
        .number = PB3PushFirstPayGift_FieldNumber_IsPayToday,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PushFirstPayGift class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PushFirstPayGift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BizSettlementRecord

@implementation PB3BizSettlementRecord

@dynamic dateAt;
@dynamic clanId;
@dynamic clanName;
@dynamic diamond;
@dynamic checkingSettleMoney;
@dynamic finalSettleMoney;
@dynamic statusType;
@dynamic unfreezeSettleMoney;

typedef struct PB3BizSettlementRecord__storage_ {
  uint32_t _has_storage_[1];
  PB3BizSettlementStatusType statusType;
  NSString *dateAt;
  NSString *clanName;
  NSString *checkingSettleMoney;
  NSString *finalSettleMoney;
  NSString *unfreezeSettleMoney;
  int64_t clanId;
  int64_t diamond;
} PB3BizSettlementRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_DateAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, dateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clanId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_ClanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, clanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clanName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_ClanName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, clanName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "diamond",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_Diamond,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, diamond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "checkingSettleMoney",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_CheckingSettleMoney,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, checkingSettleMoney),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "finalSettleMoney",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_FinalSettleMoney,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, finalSettleMoney),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "statusType",
        .dataTypeSpecific.enumDescFunc = PB3BizSettlementStatusType_EnumDescriptor,
        .number = PB3BizSettlementRecord_FieldNumber_StatusType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, statusType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unfreezeSettleMoney",
        .dataTypeSpecific.className = NULL,
        .number = PB3BizSettlementRecord_FieldNumber_UnfreezeSettleMoney,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BizSettlementRecord__storage_, unfreezeSettleMoney),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BizSettlementRecord class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BizSettlementRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BizSettlementRecord_StatusType_RawValue(PB3BizSettlementRecord *message) {
  GPBDescriptor *descriptor = [PB3BizSettlementRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BizSettlementRecord_FieldNumber_StatusType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BizSettlementRecord_StatusType_RawValue(PB3BizSettlementRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BizSettlementRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BizSettlementRecord_FieldNumber_StatusType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PersonalBizSettlementListReq

@implementation PB3PersonalBizSettlementListReq

@dynamic statusType;
@dynamic startTime;
@dynamic endTime;
@dynamic page;
@dynamic pageSize;
@dynamic isAll;

typedef struct PB3PersonalBizSettlementListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3BizSettlementStatusType statusType;
  int32_t page;
  int32_t pageSize;
  int64_t startTime;
  int64_t endTime;
} PB3PersonalBizSettlementListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusType",
        .dataTypeSpecific.enumDescFunc = PB3BizSettlementStatusType_EnumDescriptor,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_StatusType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListReq__storage_, statusType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListReq__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_Page,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAll",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListReq_FieldNumber_IsAll,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PersonalBizSettlementListReq class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PersonalBizSettlementListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PersonalBizSettlementListReq_StatusType_RawValue(PB3PersonalBizSettlementListReq *message) {
  GPBDescriptor *descriptor = [PB3PersonalBizSettlementListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PersonalBizSettlementListReq_FieldNumber_StatusType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PersonalBizSettlementListReq_StatusType_RawValue(PB3PersonalBizSettlementListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PersonalBizSettlementListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PersonalBizSettlementListReq_FieldNumber_StatusType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PersonalBizSettlementListRes

@implementation PB3PersonalBizSettlementListRes

@dynamic listArray, listArray_Count;
@dynamic total;
@dynamic dateUpdateAt;

typedef struct PB3PersonalBizSettlementListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  int64_t total;
  int64_t dateUpdateAt;
} PB3PersonalBizSettlementListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BizSettlementRecord),
        .number = PB3PersonalBizSettlementListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "dateUpdateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PersonalBizSettlementListRes_FieldNumber_DateUpdateAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PersonalBizSettlementListRes__storage_, dateUpdateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PersonalBizSettlementListRes class]
                                     rootClass:[PB3AssetsExtRoot class]
                                          file:PB3AssetsExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PersonalBizSettlementListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
