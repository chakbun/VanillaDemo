// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/store.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/StoreExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - PB3StoreExtRoot

@implementation PB3StoreExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3StoreExtRoot_FileDescriptor

static GPBFileDescriptor *PB3StoreExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3StoreCmdId

GPBEnumDescriptor *PB3StoreCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StoreZero\000StoreBuyGift\000StoreBuyGiftRewar"
        "d\000StorePointBuyLimit\000";
    static const int32_t values[] = {
        PB3StoreCmdId_StoreZero,
        PB3StoreCmdId_StoreBuyGift,
        PB3StoreCmdId_StoreBuyGiftReward,
        PB3StoreCmdId_StorePointBuyLimit,
    };
    static const char *extraTextFormatInfo = "\003\000\005\204\000\001\005\203\204\000\002\005\203\204\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreCmdId_StoreZero:
    case PB3StoreCmdId_StoreBuyGift:
    case PB3StoreCmdId_StoreBuyGiftReward:
    case PB3StoreCmdId_StorePointBuyLimit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3StoreCode

GPBEnumDescriptor *PB3StoreCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ErrStoreZero\000ErrStoreBuyEntryOff\000";
    static const int32_t values[] = {
        PB3StoreCode_ErrStoreZero,
        PB3StoreCode_ErrStoreBuyEntryOff,
    };
    static const char *extraTextFormatInfo = "\002\000\014\000\001\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreCode_ErrStoreZero:
    case PB3StoreCode_ErrStoreBuyEntryOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3EffectStatus

GPBEnumDescriptor *PB3EffectStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EsZero\000EsOwned\000EsUsing\000";
    static const int32_t values[] = {
        PB3EffectStatus_EsZero,
        PB3EffectStatus_EsOwned,
        PB3EffectStatus_EsUsing,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3EffectStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3EffectStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3EffectStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3EffectStatus_EsZero:
    case PB3EffectStatus_EsOwned:
    case PB3EffectStatus_EsUsing:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3StoreStyle

GPBEnumDescriptor *PB3StoreStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StoreStyleZero\000StoreStyleGem\000StoreStyleE"
        "ffectsAutoPlay\000StoreStyleEffectsButton\000S"
        "toreStyleNobility\000StoreStylePoint\000";
    static const int32_t values[] = {
        PB3StoreStyle_StoreStyleZero,
        PB3StoreStyle_StoreStyleGem,
        PB3StoreStyle_StoreStyleEffectsAutoPlay,
        PB3StoreStyle_StoreStyleEffectsButton,
        PB3StoreStyle_StoreStyleNobility,
        PB3StoreStyle_StoreStylePoint,
    };
    static const char *extraTextFormatInfo = "\006\000\n\204\000\001\n\203\000\002\n\207\204\204\000\003\n\207\206\000\004\n\210\000\005\n\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreStyle_StoreStyleZero:
    case PB3StoreStyle_StoreStyleGem:
    case PB3StoreStyle_StoreStyleEffectsAutoPlay:
    case PB3StoreStyle_StoreStyleEffectsButton:
    case PB3StoreStyle_StoreStyleNobility:
    case PB3StoreStyle_StoreStylePoint:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ClassifyTabType

GPBEnumDescriptor *PB3ClassifyTabType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Null\000TabStore\000TabBackPack\000";
    static const int32_t values[] = {
        PB3ClassifyTabType_Null,
        PB3ClassifyTabType_TabStore,
        PB3ClassifyTabType_TabBackPack,
    };
    static const char *extraTextFormatInfo = "\003\000\004\000\001\010\000\002\013\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClassifyTabType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClassifyTabType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClassifyTabType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClassifyTabType_Null:
    case PB3ClassifyTabType_TabStore:
    case PB3ClassifyTabType_TabBackPack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PointsMallGoodsType

GPBEnumDescriptor *PB3PointsMallGoodsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PmgtZero\000PmgtGift\000PmgtEffect\000";
    static const int32_t values[] = {
        PB3PointsMallGoodsType_PmgtZero,
        PB3PointsMallGoodsType_PmgtGift,
        PB3PointsMallGoodsType_PmgtEffect,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PointsMallGoodsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PointsMallGoodsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PointsMallGoodsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PointsMallGoodsType_PmgtZero:
    case PB3PointsMallGoodsType_PmgtGift:
    case PB3PointsMallGoodsType_PmgtEffect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3Store

@implementation PB3Store

@dynamic id_p;
@dynamic assetId;
@dynamic assetType;
@dynamic priceType;
@dynamic price;
@dynamic active;
@dynamic assetName;
@dynamic assetImage;
@dynamic backgroundImage;
@dynamic assetExplain;
@dynamic sort;
@dynamic remark;
@dynamic numColor;
@dynamic status;
@dynamic num;
@dynamic unit;
@dynamic buyNum;
@dynamic giftCategory;
@dynamic classifyId;
@dynamic dynamicImage;
@dynamic description_p;
@dynamic starNum;
@dynamic router;
@dynamic explain;
@dynamic nobilityLevel;
@dynamic effectStatus;
@dynamic getPoint;
@dynamic hasLimit, limit;
@dynamic extraGiftStr;
@dynamic detailLink;
@dynamic applicationArray, applicationArray_Count;
@dynamic unlockDays;

typedef struct PB3Store__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t assetId;
  int32_t assetType;
  int32_t priceType;
  int32_t active;
  int32_t sort;
  int32_t status;
  int32_t buyNum;
  int32_t giftCategory;
  int32_t classifyId;
  int32_t starNum;
  int32_t nobilityLevel;
  PB3EffectStatus effectStatus;
  int32_t getPoint;
  int32_t unlockDays;
  NSString *assetName;
  NSString *assetImage;
  NSString *backgroundImage;
  NSString *assetExplain;
  NSString *remark;
  NSString *numColor;
  NSString *unit;
  NSString *dynamicImage;
  NSString *description_p;
  NSString *router;
  NSString *explain;
  PB3LimitData *limit;
  NSString *extraGiftStr;
  NSString *detailLink;
  NSMutableArray *applicationArray;
  int64_t price;
  int64_t num;
} PB3Store__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Store__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetType",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "priceType",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_PriceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Store__storage_, priceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Price,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Store__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "active",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Active,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Store__storage_, active),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetName",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_BackgroundImage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Store__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetExplain",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetExplain,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetExplain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Sort,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Store__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Remark,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Store__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numColor",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_NumColor,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3Store__storage_, numColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Status,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3Store__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Num,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3Store__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Unit,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3Store__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_BuyNum,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3Store__storage_, buyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftCategory",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_GiftCategory,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3Store__storage_, giftCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "classifyId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_ClassifyId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3Store__storage_, classifyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dynamicImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_DynamicImage,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3Store__storage_, dynamicImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Description_p,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB3Store__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "starNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_StarNum,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB3Store__storage_, starNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Router,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB3Store__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "explain",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Explain,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB3Store__storage_, explain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nobilityLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_NobilityLevel,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB3Store__storage_, nobilityLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectStatus",
        .dataTypeSpecific.enumDescFunc = PB3EffectStatus_EnumDescriptor,
        .number = PB3Store_FieldNumber_EffectStatus,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB3Store__storage_, effectStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "getPoint",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_GetPoint,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB3Store__storage_, getPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LimitData),
        .number = PB3Store_FieldNumber_Limit,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB3Store__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extraGiftStr",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_ExtraGiftStr,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PB3Store__storage_, extraGiftStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detailLink",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_DetailLink,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB3Store__storage_, detailLink),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applicationArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_ApplicationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Store__storage_, applicationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unlockDays",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_UnlockDays,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(PB3Store__storage_, unlockDays),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Store class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Store__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3Store_EffectStatus_RawValue(PB3Store *message) {
  GPBDescriptor *descriptor = [PB3Store descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Store_FieldNumber_EffectStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3Store_EffectStatus_RawValue(PB3Store *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3Store descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Store_FieldNumber_EffectStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ExchangeGoods

@implementation PB3ExchangeGoods

@dynamic giftId;
@dynamic num;
@dynamic unit;
@dynamic name;
@dynamic imageURL;
@dynamic originalPrice;
@dynamic giftType;
@dynamic price;
@dynamic giftValue;

typedef struct PB3ExchangeGoods__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t giftType;
  int32_t price;
  int32_t giftValue;
  NSString *unit;
  NSString *name;
  NSString *imageURL;
  int64_t num;
  int64_t originalPrice;
} PB3ExchangeGoods__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Unit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_ImageURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_OriginalPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, originalPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_GiftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, giftType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Price,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_GiftValue,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, giftValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeGoods class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeGoods__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeExtend

@implementation PB3ExchangeExtend

@dynamic exchangeType;
@dynamic priceLimitType;
@dynamic minPrice;
@dynamic maxPrice;
@dynamic minNum;
@dynamic maxNum;

typedef struct PB3ExchangeExtend__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeType;
  int32_t priceLimitType;
  int32_t minPrice;
  int32_t maxPrice;
  int32_t minNum;
  int32_t maxNum;
} PB3ExchangeExtend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_ExchangeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, exchangeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "priceLimitType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_PriceLimitType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, priceLimitType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MinPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, minPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MaxPrice,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, maxPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MinNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, minNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MaxNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, maxNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeExtend class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeExtend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3Exchange

@implementation PB3Exchange

@dynamic id_p;
@dynamic goodsArray, goodsArray_Count;
@dynamic priceArray, priceArray_Count;
@dynamic limit;
@dynamic created;
@dynamic flag;
@dynamic exchangeNum;
@dynamic limitRange;
@dynamic limitCycle;
@dynamic gold;
@dynamic giftCategory;
@dynamic startTime;
@dynamic endTime;
@dynamic limitsArray, limitsArray_Count;
@dynamic remark;
@dynamic hasExtend, extend;
@dynamic relActId;
@dynamic showStartTime;
@dynamic showEndTime;
@dynamic canBuyStatus;

typedef struct PB3Exchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t limit;
  int32_t exchangeNum;
  int32_t limitRange;
  int32_t limitCycle;
  int32_t giftCategory;
  int32_t relActId;
  int32_t canBuyStatus;
  NSMutableArray *goodsArray;
  NSMutableArray *priceArray;
  NSString *flag;
  NSMutableArray *limitsArray;
  NSString *remark;
  PB3ExchangeExtend *extend;
  int64_t created;
  int64_t gold;
  int64_t startTime;
  int64_t endTime;
  int64_t showStartTime;
  int64_t showEndTime;
} PB3Exchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goodsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3Exchange_FieldNumber_GoodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, goodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3Exchange_FieldNumber_PriceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, priceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Created,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Flag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_ExchangeNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitRange",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_LimitRange,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitCycle",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_LimitCycle,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Gold,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftCategory",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_GiftCategory,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, giftCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_StartTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_EndTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LimitData),
        .number = PB3Exchange_FieldNumber_LimitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Remark,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeExtend),
        .number = PB3Exchange_FieldNumber_Extend,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, extend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "relActId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_RelActId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, relActId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showStartTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_ShowStartTime,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, showStartTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "showEndTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_ShowEndTime,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, showEndTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "canBuyStatus",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_CanBuyStatus,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, canBuyStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Exchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Exchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LimitData

@implementation PB3LimitData

@dynamic limitNum;
@dynamic limitRange;
@dynamic useNum;
@dynamic limitCycle;

typedef struct PB3LimitData__storage_ {
  uint32_t _has_storage_[1];
  int32_t limitNum;
  int32_t limitRange;
  int32_t useNum;
  int32_t limitCycle;
} PB3LimitData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "limitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitRange",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_UseNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, useNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitCycle",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitCycle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LimitData class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LimitData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogExchange

@implementation PB3LogExchange

@dynamic id_p;
@dynamic exchangeId;
@dynamic playerId;
@dynamic playerId2;
@dynamic playerName;
@dynamic goodsArray, goodsArray_Count;
@dynamic priceArray, priceArray_Count;
@dynamic created;

typedef struct PB3LogExchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t exchangeId;
  NSMutableArray *goodsArray;
  NSMutableArray *priceArray;
  NSString *playerName;
  int64_t playerId;
  int64_t created;
  int64_t playerId2;
} PB3LogExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_ExchangeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "goodsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3LogExchange_FieldNumber_GoodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, goodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3LogExchange_FieldNumber_PriceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, priceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_Created,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId2",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerId2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogExchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyRecord

@implementation PB3BuyRecord

@dynamic id_p;
@dynamic num;

typedef struct PB3BuyRecord__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int64_t num;
} PB3BuyRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRecord_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyRecord__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyRecord class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyGiftNotice

@implementation PB3BuyGiftNotice

@dynamic id_p;
@dynamic msg;
@dynamic rewardFlag;
@dynamic created;

typedef struct PB3BuyGiftNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *msg;
  NSString *rewardFlag;
  int64_t created;
} PB3BuyGiftNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardFlag",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_RewardFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, rewardFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Created,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyGiftNotice class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyGiftNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyGiftRewardNotice

@implementation PB3BuyGiftRewardNotice

@dynamic msg;

typedef struct PB3BuyGiftRewardNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} PB3BuyGiftRewardNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftRewardNotice_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyGiftRewardNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyGiftRewardNotice class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyGiftRewardNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyReq

@implementation PB3BuyReq

@dynamic id_p;
@dynamic num;
@dynamic type;
@dynamic remark;
@dynamic useAddr;

typedef struct PB3BuyReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t num;
  int32_t type;
  int32_t remark;
} PB3BuyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Remark,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useAddr",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_UseAddr,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyRes

@implementation PB3BuyRes

@dynamic gold;
@dynamic num;

typedef struct PB3BuyRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  int64_t gold;
} PB3BuyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRes_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyRes__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRes_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStoreConfReq

@implementation PB3GetStoreConfReq

@dynamic isHtml;
@dynamic playerId;

typedef struct PB3GetStoreConfReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetStoreConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHtml",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetStoreConfReq_FieldNumber_IsHtml,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetStoreConfReq_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetStoreConfReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStoreConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetStoreConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStoreConfRes

@implementation PB3GetStoreConfRes

@dynamic storeArray, storeArray_Count;

typedef struct PB3GetStoreConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *storeArray;
} PB3GetStoreConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Store),
        .number = PB3GetStoreConfRes_FieldNumber_StoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetStoreConfRes__storage_, storeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStoreConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetStoreConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreConfByIdReq

@implementation PB3StoreConfByIdReq

@dynamic id_p;

typedef struct PB3StoreConfByIdReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3StoreConfByIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreConfByIdReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreConfByIdReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreConfByIdReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreConfByIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreConfByIdRes

@implementation PB3StoreConfByIdRes

@dynamic hasStore, store;

typedef struct PB3StoreConfByIdRes__storage_ {
  uint32_t _has_storage_[1];
  PB3Store *store;
} PB3StoreConfByIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "store",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Store),
        .number = PB3StoreConfByIdRes_FieldNumber_Store,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreConfByIdRes__storage_, store),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreConfByIdRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreConfByIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetExchangeConfReq

@implementation PB3GetExchangeConfReq

@dynamic playerId;
@dynamic relActIdsArray, relActIdsArray_Count;

typedef struct PB3GetExchangeConfReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *relActIdsArray;
  int64_t playerId;
} PB3GetExchangeConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetExchangeConfReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "relActIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetExchangeConfReq_FieldNumber_RelActIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfReq__storage_, relActIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetExchangeConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetExchangeConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetExchangeConfRes

@implementation PB3GetExchangeConfRes

@dynamic storeArray, storeArray_Count;

typedef struct PB3GetExchangeConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *storeArray;
} PB3GetExchangeConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Exchange),
        .number = PB3GetExchangeConfRes_FieldNumber_StoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfRes__storage_, storeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetExchangeConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetExchangeConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListBuyRecordReq

@implementation PB3ListBuyRecordReq

@dynamic idArray, idArray_Count;
@dynamic buyType;

typedef struct PB3ListBuyRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t buyType;
  GPBInt32Array *idArray;
} PB3ListBuyRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListBuyRecordReq_FieldNumber_IdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordReq__storage_, idArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "buyType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListBuyRecordReq_FieldNumber_BuyType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordReq__storage_, buyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListBuyRecordReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListBuyRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListBuyRecordRes

@implementation PB3ListBuyRecordRes

@dynamic listArray, listArray_Count;

typedef struct PB3ListBuyRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListBuyRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BuyRecord),
        .number = PB3ListBuyRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListBuyRecordRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListBuyRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeRecordReq

@implementation PB3ExchangeRecordReq

@dynamic startTime;
@dynamic endTime;
@dynamic flag;
@dynamic page;
@dynamic pageSize;
@dynamic playerId;
@dynamic all;
@dynamic relActId;

typedef struct PB3ExchangeRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t relActId;
  NSString *flag;
  int64_t startTime;
  int64_t endTime;
  int64_t pageSize;
  int64_t playerId;
} PB3ExchangeRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_Flag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_Page,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_PlayerId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "all",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_All,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "relActId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_RelActId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, relActId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeRecordReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeRecordRes

@implementation PB3ExchangeRecordRes

@dynamic listArray, listArray_Count;

typedef struct PB3ExchangeRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ExchangeRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LogExchange),
        .number = PB3ExchangeRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeRecordRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RewardBuyReq

@implementation PB3RewardBuyReq

@dynamic rewardFlag;

typedef struct PB3RewardBuyReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *rewardFlag;
} PB3RewardBuyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardFlag",
        .dataTypeSpecific.className = NULL,
        .number = PB3RewardBuyReq_FieldNumber_RewardFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RewardBuyReq__storage_, rewardFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RewardBuyReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RewardBuyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RewardBuyRes

@implementation PB3RewardBuyRes

@dynamic reward;

typedef struct PB3RewardBuyRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *reward;
} PB3RewardBuyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reward",
        .dataTypeSpecific.className = NULL,
        .number = PB3RewardBuyRes_FieldNumber_Reward,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RewardBuyRes__storage_, reward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RewardBuyRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RewardBuyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddrReq

@implementation PB3PlayerAddrReq

@dynamic playerId;
@dynamic hasPlayerAddr, playerAddr;

typedef struct PB3PlayerAddrReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t playerId;
  PB3PlayerAddr *playerAddr;
} PB3PlayerAddrReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddrReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerAddrReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerAddr",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerAddr),
        .number = PB3PlayerAddrReq_FieldNumber_PlayerAddr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerAddrReq__storage_, playerAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddrReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAddrReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddrRes

@implementation PB3PlayerAddrRes


typedef struct PB3PlayerAddrRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PlayerAddrRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddrRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PlayerAddrRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FindPlayerAddrReq

@implementation PB3FindPlayerAddrReq

@dynamic playerId;

typedef struct PB3FindPlayerAddrReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t playerId;
} PB3FindPlayerAddrReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FindPlayerAddrReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FindPlayerAddrReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FindPlayerAddrReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FindPlayerAddrReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FindPlayerAddrRes

@implementation PB3FindPlayerAddrRes

@dynamic addressListArray, addressListArray_Count;

typedef struct PB3FindPlayerAddrRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressListArray;
} PB3FindPlayerAddrRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerAddr),
        .number = PB3FindPlayerAddrRes_FieldNumber_AddressListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FindPlayerAddrRes__storage_, addressListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FindPlayerAddrRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FindPlayerAddrRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000addressList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftReq

@implementation PB3SaleGiftReq

@dynamic exchangeId;
@dynamic giftInfoListArray, giftInfoListArray_Count;
@dynamic num;
@dynamic remark;

typedef struct PB3SaleGiftReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeId;
  int32_t num;
  int32_t remark;
  NSMutableArray *giftInfoListArray;
} PB3SaleGiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SaleGiftInfo),
        .number = PB3SaleGiftReq_FieldNumber_GiftInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, giftInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_Remark,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftInfo

@implementation PB3SaleGiftInfo

@dynamic giftId;
@dynamic giftNum;
@dynamic price;

typedef struct PB3SaleGiftInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  uint32_t price;
  int64_t giftNum;
} PB3SaleGiftInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_GiftNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftInfo class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftRes

@implementation PB3SaleGiftRes

@dynamic gainGiftListArray, gainGiftListArray_Count;

typedef struct PB3SaleGiftRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *gainGiftListArray;
} PB3SaleGiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gainGiftListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SaleGiftInfo),
        .number = PB3SaleGiftRes_FieldNumber_GainGiftListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaleGiftRes__storage_, gainGiftListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddr

@implementation PB3PlayerAddr

@dynamic id_p;
@dynamic addr;
@dynamic name;
@dynamic email;

typedef struct PB3PlayerAddr__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *addr;
  NSString *name;
  NSString *email;
} PB3PlayerAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Addr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddr class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAddr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreClassifyConf

@implementation PB3StoreClassifyConf

@dynamic hasSuperClassify, superClassify;
@dynamic subClassifyArray, subClassifyArray_Count;

typedef struct PB3StoreClassifyConf__storage_ {
  uint32_t _has_storage_[1];
  PB3StoreClassify *superClassify;
  NSMutableArray *subClassifyArray;
} PB3StoreClassifyConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "superClassify",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassify),
        .number = PB3StoreClassifyConf_FieldNumber_SuperClassify,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConf__storage_, superClassify),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subClassifyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassify),
        .number = PB3StoreClassifyConf_FieldNumber_SubClassifyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConf__storage_, subClassifyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConf class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreClassify

@implementation PB3StoreClassify

@dynamic id_p;
@dynamic superId;
@dynamic name;
@dynamic sort;
@dynamic isShow;
@dynamic isDefault;
@dynamic haveRed;
@dynamic style;
@dynamic effectType;

typedef struct PB3StoreClassify__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t superId;
  int32_t sort;
  PB3StoreStyle style;
  int32_t effectType;
  NSString *name;
} PB3StoreClassify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "superId",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_SuperId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, superId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Sort,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_IsShow,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_IsDefault,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "haveRed",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_HaveRed,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB3StoreStyle_EnumDescriptor,
        .number = PB3StoreClassify_FieldNumber_Style,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "effectType",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_EffectType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, effectType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassify class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassify_Style_RawValue(PB3StoreClassify *message) {
  GPBDescriptor *descriptor = [PB3StoreClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassify_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassify_Style_RawValue(PB3StoreClassify *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassify_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StoreClassifyConfReq

@implementation PB3StoreClassifyConfReq

@dynamic tabType;

typedef struct PB3StoreClassifyConfReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
} PB3StoreClassifyConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3StoreClassifyConfReq_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfReq__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassifyConfReq_TabType_RawValue(PB3StoreClassifyConfReq *message) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfReq_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassifyConfReq_TabType_RawValue(PB3StoreClassifyConfReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfReq_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StoreClassifyConfRes

@implementation PB3StoreClassifyConfRes

@dynamic classifyArray, classifyArray_Count;
@dynamic tabType;

typedef struct PB3StoreClassifyConfRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
  NSMutableArray *classifyArray;
} PB3StoreClassifyConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "classifyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassifyConf),
        .number = PB3StoreClassifyConfRes_FieldNumber_ClassifyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfRes__storage_, classifyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3StoreClassifyConfRes_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfRes__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassifyConfRes_TabType_RawValue(PB3StoreClassifyConfRes *message) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfRes_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassifyConfRes_TabType_RawValue(PB3StoreClassifyConfRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfRes_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClassifyTabInfo

@implementation PB3ClassifyTabInfo

@dynamic tabType;
@dynamic tabName;

typedef struct PB3ClassifyTabInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
  NSString *tabName;
} PB3ClassifyTabInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3ClassifyTabInfo_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClassifyTabInfo__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tabName",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClassifyTabInfo_FieldNumber_TabName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ClassifyTabInfo__storage_, tabName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClassifyTabInfo class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClassifyTabInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClassifyTabInfo_TabType_RawValue(PB3ClassifyTabInfo *message) {
  GPBDescriptor *descriptor = [PB3ClassifyTabInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClassifyTabInfo_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClassifyTabInfo_TabType_RawValue(PB3ClassifyTabInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClassifyTabInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClassifyTabInfo_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ListClassifyTabConfReq

@implementation PB3ListClassifyTabConfReq


typedef struct PB3ListClassifyTabConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ListClassifyTabConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListClassifyTabConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ListClassifyTabConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListClassifyTabConfRes

@implementation PB3ListClassifyTabConfRes

@dynamic tabInfoArray, tabInfoArray_Count;

typedef struct PB3ListClassifyTabConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabInfoArray;
} PB3ListClassifyTabConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ClassifyTabInfo),
        .number = PB3ListClassifyTabConfRes_FieldNumber_TabInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListClassifyTabConfRes__storage_, tabInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListClassifyTabConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListClassifyTabConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000tabInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchangeReq

@implementation PB3LogPointExchangeReq


typedef struct PB3LogPointExchangeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LogPointExchangeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchangeReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LogPointExchangeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchangeRes

@implementation PB3LogPointExchangeRes

@dynamic logPointArray, logPointArray_Count;

typedef struct PB3LogPointExchangeRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *logPointArray;
} PB3LogPointExchangeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logPointArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LogPointExchange),
        .number = PB3LogPointExchangeRes_FieldNumber_LogPointArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogPointExchangeRes__storage_, logPointArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchangeRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogPointExchangeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchange

@implementation PB3LogPointExchange

@dynamic exchangeId;
@dynamic exchangeName;
@dynamic exchangeNum;
@dynamic costPoint;
@dynamic createAt;

typedef struct PB3LogPointExchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeId;
  int32_t exchangeNum;
  NSString *exchangeName;
  int64_t costPoint;
  int64_t createAt;
} PB3LogPointExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeName",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "costPoint",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_CostPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, costPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogPointExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointStoreLimit

@implementation PB3PointStoreLimit

@dynamic id_p;
@dynamic useNum;

typedef struct PB3PointStoreLimit__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t useNum;
} PB3PointStoreLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointStoreLimit_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PointStoreLimit__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointStoreLimit_FieldNumber_UseNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PointStoreLimit__storage_, useNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointStoreLimit class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PointStoreLimit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreCfgReq

@implementation PB3StoreCfgReq

@dynamic isHtml;
@dynamic playerId;

typedef struct PB3StoreCfgReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3StoreCfgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHtml",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreCfgReq_FieldNumber_IsHtml,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreCfgReq_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3StoreCfgReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreCfgReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreCfgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreCfgRes

@implementation PB3StoreCfgRes

@dynamic storeArray, storeArray_Count;

typedef struct PB3StoreCfgRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *storeArray;
} PB3StoreCfgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Store),
        .number = PB3StoreCfgRes_FieldNumber_StoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StoreCfgRes__storage_, storeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreCfgRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreCfgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleStoreReq

@implementation PB3BlackWhaleStoreReq


typedef struct PB3BlackWhaleStoreReq__storage_ {
  uint32_t _has_storage_[1];
} PB3BlackWhaleStoreReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleStoreReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3BlackWhaleStoreReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleStoreRes

@implementation PB3BlackWhaleStoreRes

@dynamic isVip;
@dynamic score;
@dynamic moduleArray, moduleArray_Count;

typedef struct PB3BlackWhaleStoreRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *moduleArray;
  int64_t score;
} PB3BlackWhaleStoreRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isVip",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreRes_FieldNumber_IsVip,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreRes_FieldNumber_Score,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreRes__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "moduleArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleModule),
        .number = PB3BlackWhaleStoreRes_FieldNumber_ModuleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreRes__storage_, moduleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleStoreRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleStoreRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleModule

@implementation PB3BlackWhaleModule

@dynamic name;
@dynamic style;
@dynamic itemsArray, itemsArray_Count;

typedef struct PB3BlackWhaleModule__storage_ {
  uint32_t _has_storage_[1];
  PB3BlackWhaleModuleStyle style;
  NSString *name;
  NSMutableArray *itemsArray;
} PB3BlackWhaleModule__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleModule_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleModule__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB3BlackWhaleModuleStyle_EnumDescriptor,
        .number = PB3BlackWhaleModule_FieldNumber_Style,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleModule__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleStoreItem),
        .number = PB3BlackWhaleModule_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleModule__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleModule class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleModule__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BlackWhaleModule_Style_RawValue(PB3BlackWhaleModule *message) {
  GPBDescriptor *descriptor = [PB3BlackWhaleModule descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleModule_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BlackWhaleModule_Style_RawValue(PB3BlackWhaleModule *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BlackWhaleModule descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleModule_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BlackWhaleStoreItem

@implementation PB3BlackWhaleStoreItem

@dynamic dataOneOfCase;
@dynamic id_p;
@dynamic itemType;
@dynamic itemId;
@dynamic desc;
@dynamic content;
@dynamic limitType;
@dynamic limitNum;
@dynamic num;
@dynamic exchangeScore;
@dynamic exchangeNum;
@dynamic expCard;
@dynamic gift;
@dynamic effect;

typedef struct PB3BlackWhaleStoreItem__storage_ {
  uint32_t _has_storage_[2];
  PB3BlackWhaleItemType itemType;
  PB3BlackWhaleLimitType limitType;
  int32_t limitNum;
  int32_t num;
  int32_t exchangeScore;
  int32_t exchangeNum;
  NSString *desc;
  NSString *content;
  PB3BlackWhaleExpCard *expCard;
  PB3BlackWhaleGift *gift;
  PB3BlackWhaleEffect *effect;
  int64_t id_p;
  int64_t itemId;
} PB3BlackWhaleStoreItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "itemType",
        .dataTypeSpecific.enumDescFunc = PB3BlackWhaleItemType_EnumDescriptor,
        .number = PB3BlackWhaleStoreItem_FieldNumber_ItemType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, itemType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_ItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limitType",
        .dataTypeSpecific.enumDescFunc = PB3BlackWhaleLimitType_EnumDescriptor,
        .number = PB3BlackWhaleStoreItem_FieldNumber_LimitType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, limitType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_LimitNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, limitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_Num,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_ExchangeScore,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, exchangeScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleStoreItem_FieldNumber_ExchangeNum,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "expCard",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleExpCard),
        .number = PB3BlackWhaleStoreItem_FieldNumber_ExpCard,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, expCard),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gift",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleGift),
        .number = PB3BlackWhaleStoreItem_FieldNumber_Gift,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, gift),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effect",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleEffect),
        .number = PB3BlackWhaleStoreItem_FieldNumber_Effect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleStoreItem__storage_, effect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleStoreItem class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleStoreItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BlackWhaleStoreItem_ItemType_RawValue(PB3BlackWhaleStoreItem *message) {
  GPBDescriptor *descriptor = [PB3BlackWhaleStoreItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleStoreItem_FieldNumber_ItemType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BlackWhaleStoreItem_ItemType_RawValue(PB3BlackWhaleStoreItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BlackWhaleStoreItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleStoreItem_FieldNumber_ItemType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3BlackWhaleStoreItem_LimitType_RawValue(PB3BlackWhaleStoreItem *message) {
  GPBDescriptor *descriptor = [PB3BlackWhaleStoreItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleStoreItem_FieldNumber_LimitType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BlackWhaleStoreItem_LimitType_RawValue(PB3BlackWhaleStoreItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BlackWhaleStoreItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleStoreItem_FieldNumber_LimitType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3BlackWhaleStoreItem_ClearDataOneOfCase(PB3BlackWhaleStoreItem *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3BlackWhaleExpCard

@implementation PB3BlackWhaleExpCard

@dynamic smallIcon;
@dynamic bigIcon;
@dynamic name;
@dynamic minLevel;
@dynamic maxLevel;

typedef struct PB3BlackWhaleExpCard__storage_ {
  uint32_t _has_storage_[1];
  int32_t minLevel;
  int32_t maxLevel;
  NSString *smallIcon;
  NSString *bigIcon;
  NSString *name;
} PB3BlackWhaleExpCard__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "smallIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExpCard_FieldNumber_SmallIcon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExpCard__storage_, smallIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExpCard_FieldNumber_BigIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExpCard__storage_, bigIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExpCard_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExpCard__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExpCard_FieldNumber_MinLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExpCard__storage_, minLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExpCard_FieldNumber_MaxLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExpCard__storage_, maxLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExpCard class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExpCard__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleGift

@implementation PB3BlackWhaleGift


typedef struct PB3BlackWhaleGift__storage_ {
  uint32_t _has_storage_[1];
} PB3BlackWhaleGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleGift class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3BlackWhaleGift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleEffect

@implementation PB3BlackWhaleEffect

@dynamic validityTime;
@dynamic addType;

typedef struct PB3BlackWhaleEffect__storage_ {
  uint32_t _has_storage_[1];
  int64_t validityTime;
  int64_t addType;
} PB3BlackWhaleEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validityTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleEffect_FieldNumber_ValidityTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleEffect__storage_, validityTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "addType",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleEffect_FieldNumber_AddType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleEffect__storage_, addType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleEffect class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleScoreReq

@implementation PB3BlackWhaleScoreReq

@dynamic startTime;
@dynamic endTime;
@dynamic page;
@dynamic pageSize;

typedef struct PB3BlackWhaleScoreReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  int64_t startTime;
  int64_t endTime;
} PB3BlackWhaleScoreReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreReq__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreReq_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreReq_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreReq_FieldNumber_PageSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleScoreReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleScoreReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleScoreRes

@implementation PB3BlackWhaleScoreRes

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PB3BlackWhaleScoreRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PB3BlackWhaleScoreRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleScoreLog),
        .number = PB3BlackWhaleScoreRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleScoreRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleScoreRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleScoreLog

@implementation PB3BlackWhaleScoreLog

@dynamic remark;
@dynamic changeScore;
@dynamic score;
@dynamic createAt;

typedef struct PB3BlackWhaleScoreLog__storage_ {
  uint32_t _has_storage_[1];
  NSString *remark;
  int64_t changeScore;
  int64_t score;
  int64_t createAt;
} PB3BlackWhaleScoreLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLog_FieldNumber_Remark,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLog__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "changeScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLog_FieldNumber_ChangeScore,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLog__storage_, changeScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLog_FieldNumber_Score,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLog__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLog_FieldNumber_CreateAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLog__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleScoreLog class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleScoreLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleScoreLogDetail

@implementation PB3BlackWhaleScoreLogDetail

@dynamic playerId;
@dynamic hasLog, log;
@dynamic name;

typedef struct PB3BlackWhaleScoreLogDetail__storage_ {
  uint32_t _has_storage_[1];
  PB3BlackWhaleScoreLog *log;
  NSString *name;
  int64_t playerId;
} PB3BlackWhaleScoreLogDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLogDetail_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLogDetail__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "log",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleScoreLog),
        .number = PB3BlackWhaleScoreLogDetail_FieldNumber_Log,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLogDetail__storage_, log),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLogDetail_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLogDetail__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleScoreLogDetail class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleScoreLogDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangeRecordReq

@implementation PB3BlackWhaleExchangeRecordReq

@dynamic startTime;
@dynamic endTime;
@dynamic page;
@dynamic pageSize;

typedef struct PB3BlackWhaleExchangeRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  int64_t startTime;
  int64_t endTime;
} PB3BlackWhaleExchangeRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeRecordReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordReq__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeRecordReq_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeRecordReq_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeRecordReq_FieldNumber_PageSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeRecordReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangeRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangeRecordRes

@implementation PB3BlackWhaleExchangeRecordRes

@dynamic listArray, listArray_Count;
@dynamic total;

typedef struct PB3BlackWhaleExchangeRecordRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *listArray;
} PB3BlackWhaleExchangeRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleExchangeLog),
        .number = PB3BlackWhaleExchangeRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeRecordRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeRecordRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeRecordRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangeRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangeLog

@implementation PB3BlackWhaleExchangeLog

@dynamic itemName;
@dynamic exchangeScore;
@dynamic exchangeNum;
@dynamic icon;
@dynamic createAt;
@dynamic targetId;
@dynamic itemType;

typedef struct PB3BlackWhaleExchangeLog__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeNum;
  PB3BlackWhaleItemType itemType;
  NSString *itemName;
  NSString *icon;
  int64_t exchangeScore;
  int64_t createAt;
  int64_t targetId;
} PB3BlackWhaleExchangeLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_ItemName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exchangeScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_ExchangeScore,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, exchangeScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_ExchangeNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_TargetId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "itemType",
        .dataTypeSpecific.enumDescFunc = PB3BlackWhaleItemType_EnumDescriptor,
        .number = PB3BlackWhaleExchangeLog_FieldNumber_ItemType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLog__storage_, itemType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeLog class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangeLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BlackWhaleExchangeLog_ItemType_RawValue(PB3BlackWhaleExchangeLog *message) {
  GPBDescriptor *descriptor = [PB3BlackWhaleExchangeLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleExchangeLog_FieldNumber_ItemType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BlackWhaleExchangeLog_ItemType_RawValue(PB3BlackWhaleExchangeLog *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BlackWhaleExchangeLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BlackWhaleExchangeLog_FieldNumber_ItemType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BlackWhaleExchangeLogDetail

@implementation PB3BlackWhaleExchangeLogDetail

@dynamic playerId;
@dynamic itemId;
@dynamic hasLog, log;
@dynamic name;

typedef struct PB3BlackWhaleExchangeLogDetail__storage_ {
  uint32_t _has_storage_[1];
  PB3BlackWhaleExchangeLog *log;
  NSString *name;
  int64_t playerId;
  int64_t itemId;
} PB3BlackWhaleExchangeLogDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLogDetail_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLogDetail__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLogDetail_FieldNumber_ItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLogDetail__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "log",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleExchangeLog),
        .number = PB3BlackWhaleExchangeLogDetail_FieldNumber_Log,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLogDetail__storage_, log),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeLogDetail_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeLogDetail__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeLogDetail class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangeLogDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangerLogAdminReq

@implementation PB3BlackWhaleExchangerLogAdminReq

@dynamic playerId;
@dynamic hasFilter, filter;

typedef struct PB3BlackWhaleExchangerLogAdminReq__storage_ {
  uint32_t _has_storage_[1];
  PB3BlackWhaleExchangeRecordReq *filter;
  int64_t playerId;
} PB3BlackWhaleExchangerLogAdminReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangerLogAdminReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangerLogAdminReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "filter",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleExchangeRecordReq),
        .number = PB3BlackWhaleExchangerLogAdminReq_FieldNumber_Filter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangerLogAdminReq__storage_, filter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangerLogAdminReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangerLogAdminReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangerLogAdmin

@implementation PB3BlackWhaleExchangerLogAdmin

@dynamic logArray, logArray_Count;
@dynamic total;

typedef struct PB3BlackWhaleExchangerLogAdmin__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *logArray;
} PB3BlackWhaleExchangerLogAdmin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleExchangeLogDetail),
        .number = PB3BlackWhaleExchangerLogAdmin_FieldNumber_LogArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangerLogAdmin__storage_, logArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangerLogAdmin_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangerLogAdmin__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangerLogAdmin class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangerLogAdmin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleScoreLogAdmin

@implementation PB3BlackWhaleScoreLogAdmin

@dynamic logArray, logArray_Count;
@dynamic total;

typedef struct PB3BlackWhaleScoreLogAdmin__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  NSMutableArray *logArray;
} PB3BlackWhaleScoreLogAdmin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BlackWhaleScoreLogDetail),
        .number = PB3BlackWhaleScoreLogAdmin_FieldNumber_LogArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLogAdmin__storage_, logArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleScoreLogAdmin_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleScoreLogAdmin__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleScoreLogAdmin class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleScoreLogAdmin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangeReq

@implementation PB3BlackWhaleExchangeReq

@dynamic id_p;
@dynamic playerId;

typedef struct PB3BlackWhaleExchangeReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
  int64_t playerId;
} PB3BlackWhaleExchangeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleExchangeReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleExchangeReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleExchangeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleExchangeRes

@implementation PB3BlackWhaleExchangeRes


typedef struct PB3BlackWhaleExchangeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3BlackWhaleExchangeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleExchangeRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3BlackWhaleExchangeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointsMallReq

@implementation PB3PointsMallReq


typedef struct PB3PointsMallReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PointsMallReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointsMallReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PointsMallReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointsMallRes

@implementation PB3PointsMallRes

@dynamic goodsArray, goodsArray_Count;

typedef struct PB3PointsMallRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *goodsArray;
} PB3PointsMallRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "goodsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PointsMallGoods),
        .number = PB3PointsMallRes_FieldNumber_GoodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PointsMallRes__storage_, goodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointsMallRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PointsMallRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointsMallGoods

@implementation PB3PointsMallGoods

@dynamic id_p;
@dynamic type;
@dynamic name;
@dynamic img;
@dynamic pointNum;
@dynamic validDay;
@dynamic remainedNum;
@dynamic exchangedNum;
@dynamic exchangeLimit;
@dynamic giftGold;

typedef struct PB3PointsMallGoods__storage_ {
  uint32_t _has_storage_[1];
  PB3PointsMallGoodsType type;
  NSString *name;
  NSString *img;
  int64_t id_p;
  int64_t pointNum;
  int64_t validDay;
  int64_t remainedNum;
  int64_t exchangedNum;
  int64_t exchangeLimit;
  int64_t giftGold;
} PB3PointsMallGoods__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3PointsMallGoodsType_EnumDescriptor,
        .number = PB3PointsMallGoods_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_Img,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pointNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_PointNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, pointNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "validDay",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_ValidDay,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, validDay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remainedNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_RemainedNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, remainedNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangedNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_ExchangedNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, exchangedNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_ExchangeLimit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, exchangeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallGoods_FieldNumber_GiftGold,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PointsMallGoods__storage_, giftGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointsMallGoods class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PointsMallGoods__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PointsMallGoods_Type_RawValue(PB3PointsMallGoods *message) {
  GPBDescriptor *descriptor = [PB3PointsMallGoods descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PointsMallGoods_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PointsMallGoods_Type_RawValue(PB3PointsMallGoods *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PointsMallGoods descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PointsMallGoods_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PointsMallExchangeReq

@implementation PB3PointsMallExchangeReq

@dynamic goodsId;
@dynamic num;

typedef struct PB3PointsMallExchangeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  int64_t goodsId;
} PB3PointsMallExchangeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "goodsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallExchangeReq_FieldNumber_GoodsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PointsMallExchangeReq__storage_, goodsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointsMallExchangeReq_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PointsMallExchangeReq__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointsMallExchangeReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PointsMallExchangeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointsMallExchangeRes

@implementation PB3PointsMallExchangeRes


typedef struct PB3PointsMallExchangeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PointsMallExchangeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointsMallExchangeRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PointsMallExchangeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
