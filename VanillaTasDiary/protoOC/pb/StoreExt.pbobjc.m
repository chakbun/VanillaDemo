// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/store.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/StoreExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3StoreExtRoot

@implementation PB3StoreExtRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PB3StoreExtRoot_FileDescriptor

static GPBFileDescriptor *PB3StoreExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3StoreCmdId

GPBEnumDescriptor *PB3StoreCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StoreZero\000StoreBuyGift\000StoreBuyGiftRewar"
        "d\000StorePointBuyLimit\000";
    static const int32_t values[] = {
        PB3StoreCmdId_StoreZero,
        PB3StoreCmdId_StoreBuyGift,
        PB3StoreCmdId_StoreBuyGiftReward,
        PB3StoreCmdId_StorePointBuyLimit,
    };
    static const char *extraTextFormatInfo = "\003\000\005\204\000\001\005\203\204\000\002\005\203\204\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreCmdId_StoreZero:
    case PB3StoreCmdId_StoreBuyGift:
    case PB3StoreCmdId_StoreBuyGiftReward:
    case PB3StoreCmdId_StorePointBuyLimit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3StoreCode

GPBEnumDescriptor *PB3StoreCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ErrStoreZero\000ErrStoreBuyEntryOff\000";
    static const int32_t values[] = {
        PB3StoreCode_ErrStoreZero,
        PB3StoreCode_ErrStoreBuyEntryOff,
    };
    static const char *extraTextFormatInfo = "\002\000\014\000\001\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreCode_ErrStoreZero:
    case PB3StoreCode_ErrStoreBuyEntryOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3EffectStatus

GPBEnumDescriptor *PB3EffectStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EsZero\000EsOwned\000EsUsing\000";
    static const int32_t values[] = {
        PB3EffectStatus_EsZero,
        PB3EffectStatus_EsOwned,
        PB3EffectStatus_EsUsing,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3EffectStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3EffectStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3EffectStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3EffectStatus_EsZero:
    case PB3EffectStatus_EsOwned:
    case PB3EffectStatus_EsUsing:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3StoreStyle

GPBEnumDescriptor *PB3StoreStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StoreStyleZero\000StoreStyleGem\000StoreStyleE"
        "ffectsAutoPlay\000StoreStyleEffectsButton\000S"
        "toreStyleNobility\000StoreStylePoint\000";
    static const int32_t values[] = {
        PB3StoreStyle_StoreStyleZero,
        PB3StoreStyle_StoreStyleGem,
        PB3StoreStyle_StoreStyleEffectsAutoPlay,
        PB3StoreStyle_StoreStyleEffectsButton,
        PB3StoreStyle_StoreStyleNobility,
        PB3StoreStyle_StoreStylePoint,
    };
    static const char *extraTextFormatInfo = "\006\000\n\204\000\001\n\203\000\002\n\207\204\204\000\003\n\207\206\000\004\n\210\000\005\n\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3StoreStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3StoreStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3StoreStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3StoreStyle_StoreStyleZero:
    case PB3StoreStyle_StoreStyleGem:
    case PB3StoreStyle_StoreStyleEffectsAutoPlay:
    case PB3StoreStyle_StoreStyleEffectsButton:
    case PB3StoreStyle_StoreStyleNobility:
    case PB3StoreStyle_StoreStylePoint:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ClassifyTabType

GPBEnumDescriptor *PB3ClassifyTabType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Null\000TabStore\000TabBackPack\000";
    static const int32_t values[] = {
        PB3ClassifyTabType_Null,
        PB3ClassifyTabType_TabStore,
        PB3ClassifyTabType_TabBackPack,
    };
    static const char *extraTextFormatInfo = "\003\000\004\000\001\010\000\002\013\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClassifyTabType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClassifyTabType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClassifyTabType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClassifyTabType_Null:
    case PB3ClassifyTabType_TabStore:
    case PB3ClassifyTabType_TabBackPack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3Store

@implementation PB3Store

@dynamic id_p;
@dynamic assetId;
@dynamic assetType;
@dynamic priceType;
@dynamic price;
@dynamic active;
@dynamic assetName;
@dynamic assetImage;
@dynamic backgroundImage;
@dynamic assetExplain;
@dynamic sort;
@dynamic remark;
@dynamic numColor;
@dynamic status;
@dynamic num;
@dynamic unit;
@dynamic buyNum;
@dynamic giftCategory;
@dynamic classifyId;
@dynamic dynamicImage;
@dynamic description_p;
@dynamic starNum;
@dynamic router;
@dynamic explain;
@dynamic nobilityLevel;
@dynamic effectStatus;
@dynamic getPoint;
@dynamic hasLimit, limit;
@dynamic extraGiftStr;
@dynamic detailLink;

typedef struct PB3Store__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t assetId;
  int32_t assetType;
  int32_t priceType;
  int32_t active;
  int32_t sort;
  int32_t status;
  int32_t buyNum;
  int32_t giftCategory;
  int32_t classifyId;
  int32_t starNum;
  int32_t nobilityLevel;
  PB3EffectStatus effectStatus;
  int32_t getPoint;
  NSString *assetName;
  NSString *assetImage;
  NSString *backgroundImage;
  NSString *assetExplain;
  NSString *remark;
  NSString *numColor;
  NSString *unit;
  NSString *dynamicImage;
  NSString *description_p;
  NSString *router;
  NSString *explain;
  PB3LimitData *limit;
  NSString *extraGiftStr;
  NSString *detailLink;
  int64_t price;
  int64_t num;
} PB3Store__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Store__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetType",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "priceType",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_PriceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Store__storage_, priceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Price,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Store__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "active",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Active,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Store__storage_, active),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "assetName",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_BackgroundImage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Store__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetExplain",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_AssetExplain,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Store__storage_, assetExplain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Sort,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Store__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Remark,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Store__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numColor",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_NumColor,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3Store__storage_, numColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Status,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3Store__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Num,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3Store__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Unit,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3Store__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_BuyNum,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3Store__storage_, buyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftCategory",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_GiftCategory,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3Store__storage_, giftCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "classifyId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_ClassifyId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3Store__storage_, classifyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dynamicImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_DynamicImage,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3Store__storage_, dynamicImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Description_p,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB3Store__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "starNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_StarNum,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB3Store__storage_, starNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Router,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB3Store__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "explain",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_Explain,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB3Store__storage_, explain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nobilityLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_NobilityLevel,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB3Store__storage_, nobilityLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectStatus",
        .dataTypeSpecific.enumDescFunc = PB3EffectStatus_EnumDescriptor,
        .number = PB3Store_FieldNumber_EffectStatus,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB3Store__storage_, effectStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "getPoint",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_GetPoint,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB3Store__storage_, getPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LimitData),
        .number = PB3Store_FieldNumber_Limit,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB3Store__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extraGiftStr",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_ExtraGiftStr,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PB3Store__storage_, extraGiftStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detailLink",
        .dataTypeSpecific.className = NULL,
        .number = PB3Store_FieldNumber_DetailLink,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB3Store__storage_, detailLink),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Store class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Store__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3Store_EffectStatus_RawValue(PB3Store *message) {
  GPBDescriptor *descriptor = [PB3Store descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Store_FieldNumber_EffectStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3Store_EffectStatus_RawValue(PB3Store *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3Store descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Store_FieldNumber_EffectStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ExchangeGoods

@implementation PB3ExchangeGoods

@dynamic giftId;
@dynamic num;
@dynamic unit;
@dynamic name;
@dynamic imageURL;
@dynamic originalPrice;
@dynamic giftType;
@dynamic price;

typedef struct PB3ExchangeGoods__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t giftType;
  int32_t price;
  NSString *unit;
  NSString *name;
  NSString *imageURL;
  int64_t num;
  int64_t originalPrice;
} PB3ExchangeGoods__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Unit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_ImageURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_OriginalPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, originalPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_GiftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, giftType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeGoods_FieldNumber_Price,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3ExchangeGoods__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeGoods class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeGoods__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeExtend

@implementation PB3ExchangeExtend

@dynamic exchangeType;
@dynamic priceLimitType;
@dynamic minPrice;
@dynamic maxPrice;

typedef struct PB3ExchangeExtend__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeType;
  int32_t priceLimitType;
  int32_t minPrice;
  int32_t maxPrice;
} PB3ExchangeExtend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_ExchangeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, exchangeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "priceLimitType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_PriceLimitType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, priceLimitType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MinPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, minPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeExtend_FieldNumber_MaxPrice,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeExtend__storage_, maxPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeExtend class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeExtend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3Exchange

@implementation PB3Exchange

@dynamic id_p;
@dynamic goodsArray, goodsArray_Count;
@dynamic priceArray, priceArray_Count;
@dynamic limit;
@dynamic created;
@dynamic flag;
@dynamic exchangeNum;
@dynamic limitRange;
@dynamic limitCycle;
@dynamic gold;
@dynamic giftCategory;
@dynamic startTime;
@dynamic endTime;
@dynamic limitsArray, limitsArray_Count;
@dynamic remark;
@dynamic hasExtend, extend;
@dynamic relActId;

typedef struct PB3Exchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t limit;
  int32_t exchangeNum;
  int32_t limitRange;
  int32_t limitCycle;
  int32_t giftCategory;
  int32_t relActId;
  NSMutableArray *goodsArray;
  NSMutableArray *priceArray;
  NSString *flag;
  NSMutableArray *limitsArray;
  NSString *remark;
  PB3ExchangeExtend *extend;
  int64_t created;
  int64_t gold;
  int64_t startTime;
  int64_t endTime;
} PB3Exchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goodsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3Exchange_FieldNumber_GoodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, goodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3Exchange_FieldNumber_PriceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, priceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Created,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Flag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_ExchangeNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitRange",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_LimitRange,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitCycle",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_LimitCycle,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Gold,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "giftCategory",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_GiftCategory,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, giftCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_StartTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_EndTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LimitData),
        .number = PB3Exchange_FieldNumber_LimitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, limitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_Remark,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeExtend),
        .number = PB3Exchange_FieldNumber_Extend,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, extend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "relActId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Exchange_FieldNumber_RelActId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3Exchange__storage_, relActId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Exchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Exchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LimitData

@implementation PB3LimitData

@dynamic limitNum;
@dynamic limitRange;
@dynamic useNum;
@dynamic limitCycle;

typedef struct PB3LimitData__storage_ {
  uint32_t _has_storage_[1];
  int32_t limitNum;
  int32_t limitRange;
  int32_t useNum;
  int32_t limitCycle;
} PB3LimitData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "limitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitRange",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitRange,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_UseNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, useNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limitCycle",
        .dataTypeSpecific.className = NULL,
        .number = PB3LimitData_FieldNumber_LimitCycle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LimitData__storage_, limitCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LimitData class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LimitData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogExchange

@implementation PB3LogExchange

@dynamic id_p;
@dynamic exchangeId;
@dynamic playerId;
@dynamic playerId2;
@dynamic playerName;
@dynamic goodsArray, goodsArray_Count;
@dynamic priceArray, priceArray_Count;
@dynamic created;

typedef struct PB3LogExchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t exchangeId;
  NSMutableArray *goodsArray;
  NSMutableArray *priceArray;
  NSString *playerName;
  int64_t playerId;
  int64_t created;
  int64_t playerId2;
} PB3LogExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_ExchangeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "goodsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3LogExchange_FieldNumber_GoodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, goodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeGoods),
        .number = PB3LogExchange_FieldNumber_PriceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, priceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_Created,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId2",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerId2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogExchange_FieldNumber_PlayerName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LogExchange__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogExchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyRecord

@implementation PB3BuyRecord

@dynamic id_p;
@dynamic num;

typedef struct PB3BuyRecord__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int64_t num;
} PB3BuyRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRecord_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyRecord__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyRecord class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyGiftNotice

@implementation PB3BuyGiftNotice

@dynamic id_p;
@dynamic msg;
@dynamic rewardFlag;
@dynamic created;

typedef struct PB3BuyGiftNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *msg;
  NSString *rewardFlag;
  int64_t created;
} PB3BuyGiftNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardFlag",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_RewardFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, rewardFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftNotice_FieldNumber_Created,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BuyGiftNotice__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyGiftNotice class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyGiftNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyGiftRewardNotice

@implementation PB3BuyGiftRewardNotice

@dynamic msg;

typedef struct PB3BuyGiftRewardNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} PB3BuyGiftRewardNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyGiftRewardNotice_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyGiftRewardNotice__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyGiftRewardNotice class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyGiftRewardNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyReq

@implementation PB3BuyReq

@dynamic id_p;
@dynamic num;
@dynamic type;
@dynamic remark;
@dynamic useAddr;

typedef struct PB3BuyReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t num;
  int32_t type;
  int32_t remark;
} PB3BuyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_Remark,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BuyReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useAddr",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyReq_FieldNumber_UseAddr,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BuyRes

@implementation PB3BuyRes

@dynamic gold;
@dynamic num;

typedef struct PB3BuyRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  int64_t gold;
} PB3BuyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRes_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BuyRes__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3BuyRes_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BuyRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BuyRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BuyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStoreConfReq

@implementation PB3GetStoreConfReq

@dynamic isHtml;
@dynamic playerId;

typedef struct PB3GetStoreConfReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetStoreConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHtml",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetStoreConfReq_FieldNumber_IsHtml,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetStoreConfReq_FieldNumber_PlayerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetStoreConfReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStoreConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetStoreConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetStoreConfRes

@implementation PB3GetStoreConfRes

@dynamic storeArray, storeArray_Count;

typedef struct PB3GetStoreConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *storeArray;
} PB3GetStoreConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Store),
        .number = PB3GetStoreConfRes_FieldNumber_StoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetStoreConfRes__storage_, storeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetStoreConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetStoreConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreConfByIdReq

@implementation PB3StoreConfByIdReq

@dynamic id_p;

typedef struct PB3StoreConfByIdReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3StoreConfByIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreConfByIdReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreConfByIdReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreConfByIdReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreConfByIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreConfByIdRes

@implementation PB3StoreConfByIdRes

@dynamic hasStore, store;

typedef struct PB3StoreConfByIdRes__storage_ {
  uint32_t _has_storage_[1];
  PB3Store *store;
} PB3StoreConfByIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "store",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Store),
        .number = PB3StoreConfByIdRes_FieldNumber_Store,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreConfByIdRes__storage_, store),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreConfByIdRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreConfByIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetExchangeConfReq

@implementation PB3GetExchangeConfReq

@dynamic playerId;
@dynamic relActIdsArray, relActIdsArray_Count;

typedef struct PB3GetExchangeConfReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *relActIdsArray;
  int64_t playerId;
} PB3GetExchangeConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetExchangeConfReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "relActIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetExchangeConfReq_FieldNumber_RelActIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfReq__storage_, relActIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetExchangeConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetExchangeConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetExchangeConfRes

@implementation PB3GetExchangeConfRes

@dynamic storeArray, storeArray_Count;

typedef struct PB3GetExchangeConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *storeArray;
} PB3GetExchangeConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Exchange),
        .number = PB3GetExchangeConfRes_FieldNumber_StoreArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetExchangeConfRes__storage_, storeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetExchangeConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetExchangeConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListBuyRecordReq

@implementation PB3ListBuyRecordReq

@dynamic idArray, idArray_Count;
@dynamic buyType;

typedef struct PB3ListBuyRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t buyType;
  GPBInt32Array *idArray;
} PB3ListBuyRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListBuyRecordReq_FieldNumber_IdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordReq__storage_, idArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "buyType",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListBuyRecordReq_FieldNumber_BuyType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordReq__storage_, buyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListBuyRecordReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListBuyRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListBuyRecordRes

@implementation PB3ListBuyRecordRes

@dynamic listArray, listArray_Count;

typedef struct PB3ListBuyRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListBuyRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BuyRecord),
        .number = PB3ListBuyRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListBuyRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListBuyRecordRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListBuyRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeRecordReq

@implementation PB3ExchangeRecordReq

@dynamic startTime;
@dynamic endTime;
@dynamic flag;
@dynamic page;
@dynamic pageSize;
@dynamic playerId;
@dynamic all;

typedef struct PB3ExchangeRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *flag;
  int64_t startTime;
  int64_t endTime;
  int64_t pageSize;
  int64_t playerId;
} PB3ExchangeRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_Flag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_Page,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_PlayerId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "all",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeRecordReq_FieldNumber_All,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeRecordReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeRecordRes

@implementation PB3ExchangeRecordRes

@dynamic listArray, listArray_Count;

typedef struct PB3ExchangeRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ExchangeRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LogExchange),
        .number = PB3ExchangeRecordRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ExchangeRecordRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeRecordRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RewardBuyReq

@implementation PB3RewardBuyReq

@dynamic rewardFlag;

typedef struct PB3RewardBuyReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *rewardFlag;
} PB3RewardBuyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardFlag",
        .dataTypeSpecific.className = NULL,
        .number = PB3RewardBuyReq_FieldNumber_RewardFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RewardBuyReq__storage_, rewardFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RewardBuyReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RewardBuyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RewardBuyRes

@implementation PB3RewardBuyRes

@dynamic reward;

typedef struct PB3RewardBuyRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *reward;
} PB3RewardBuyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reward",
        .dataTypeSpecific.className = NULL,
        .number = PB3RewardBuyRes_FieldNumber_Reward,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RewardBuyRes__storage_, reward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RewardBuyRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RewardBuyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddrReq

@implementation PB3PlayerAddrReq

@dynamic playerId;
@dynamic hasPlayerAddr, playerAddr;

typedef struct PB3PlayerAddrReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t playerId;
  PB3PlayerAddr *playerAddr;
} PB3PlayerAddrReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddrReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerAddrReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerAddr",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerAddr),
        .number = PB3PlayerAddrReq_FieldNumber_PlayerAddr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerAddrReq__storage_, playerAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddrReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAddrReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddrRes

@implementation PB3PlayerAddrRes


typedef struct PB3PlayerAddrRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PlayerAddrRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddrRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PlayerAddrRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FindPlayerAddrReq

@implementation PB3FindPlayerAddrReq

@dynamic playerId;

typedef struct PB3FindPlayerAddrReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t playerId;
} PB3FindPlayerAddrReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FindPlayerAddrReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FindPlayerAddrReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FindPlayerAddrReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FindPlayerAddrReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FindPlayerAddrRes

@implementation PB3FindPlayerAddrRes

@dynamic addressListArray, addressListArray_Count;

typedef struct PB3FindPlayerAddrRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressListArray;
} PB3FindPlayerAddrRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerAddr),
        .number = PB3FindPlayerAddrRes_FieldNumber_AddressListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FindPlayerAddrRes__storage_, addressListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FindPlayerAddrRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FindPlayerAddrRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000addressList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftReq

@implementation PB3SaleGiftReq

@dynamic exchangeId;
@dynamic giftInfoListArray, giftInfoListArray_Count;
@dynamic num;
@dynamic remark;

typedef struct PB3SaleGiftReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeId;
  int32_t num;
  int32_t remark;
  NSMutableArray *giftInfoListArray;
} PB3SaleGiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SaleGiftInfo),
        .number = PB3SaleGiftReq_FieldNumber_GiftInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, giftInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftReq_FieldNumber_Remark,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SaleGiftReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftInfo

@implementation PB3SaleGiftInfo

@dynamic giftId;
@dynamic giftNum;
@dynamic price;

typedef struct PB3SaleGiftInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  uint32_t price;
  int64_t giftNum;
} PB3SaleGiftInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_GiftNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3SaleGiftInfo_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SaleGiftInfo__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftInfo class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SaleGiftRes

@implementation PB3SaleGiftRes

@dynamic gainGiftListArray, gainGiftListArray_Count;

typedef struct PB3SaleGiftRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *gainGiftListArray;
} PB3SaleGiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gainGiftListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SaleGiftInfo),
        .number = PB3SaleGiftRes_FieldNumber_GainGiftListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SaleGiftRes__storage_, gainGiftListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SaleGiftRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SaleGiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerAddr

@implementation PB3PlayerAddr

@dynamic id_p;
@dynamic addr;
@dynamic name;
@dynamic email;

typedef struct PB3PlayerAddr__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *addr;
  NSString *name;
  NSString *email;
} PB3PlayerAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Addr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerAddr_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PlayerAddr__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerAddr class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerAddr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreClassifyConf

@implementation PB3StoreClassifyConf

@dynamic hasSuperClassify, superClassify;
@dynamic subClassifyArray, subClassifyArray_Count;

typedef struct PB3StoreClassifyConf__storage_ {
  uint32_t _has_storage_[1];
  PB3StoreClassify *superClassify;
  NSMutableArray *subClassifyArray;
} PB3StoreClassifyConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "superClassify",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassify),
        .number = PB3StoreClassifyConf_FieldNumber_SuperClassify,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConf__storage_, superClassify),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subClassifyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassify),
        .number = PB3StoreClassifyConf_FieldNumber_SubClassifyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConf__storage_, subClassifyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConf class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3StoreClassify

@implementation PB3StoreClassify

@dynamic id_p;
@dynamic superId;
@dynamic name;
@dynamic sort;
@dynamic isShow;
@dynamic isDefault;
@dynamic haveRed;
@dynamic style;
@dynamic effectType;

typedef struct PB3StoreClassify__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t superId;
  int32_t sort;
  PB3StoreStyle style;
  int32_t effectType;
  NSString *name;
} PB3StoreClassify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "superId",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_SuperId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, superId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_Sort,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_IsShow,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_IsDefault,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "haveRed",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_HaveRed,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB3StoreStyle_EnumDescriptor,
        .number = PB3StoreClassify_FieldNumber_Style,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "effectType",
        .dataTypeSpecific.className = NULL,
        .number = PB3StoreClassify_FieldNumber_EffectType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3StoreClassify__storage_, effectType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassify class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassify_Style_RawValue(PB3StoreClassify *message) {
  GPBDescriptor *descriptor = [PB3StoreClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassify_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassify_Style_RawValue(PB3StoreClassify *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassify_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StoreClassifyConfReq

@implementation PB3StoreClassifyConfReq

@dynamic tabType;

typedef struct PB3StoreClassifyConfReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
} PB3StoreClassifyConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3StoreClassifyConfReq_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfReq__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassifyConfReq_TabType_RawValue(PB3StoreClassifyConfReq *message) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfReq_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassifyConfReq_TabType_RawValue(PB3StoreClassifyConfReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfReq_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StoreClassifyConfRes

@implementation PB3StoreClassifyConfRes

@dynamic classifyArray, classifyArray_Count;
@dynamic tabType;

typedef struct PB3StoreClassifyConfRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
  NSMutableArray *classifyArray;
} PB3StoreClassifyConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "classifyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StoreClassifyConf),
        .number = PB3StoreClassifyConfRes_FieldNumber_ClassifyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfRes__storage_, classifyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3StoreClassifyConfRes_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StoreClassifyConfRes__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StoreClassifyConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StoreClassifyConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StoreClassifyConfRes_TabType_RawValue(PB3StoreClassifyConfRes *message) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfRes_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StoreClassifyConfRes_TabType_RawValue(PB3StoreClassifyConfRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StoreClassifyConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StoreClassifyConfRes_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClassifyTabInfo

@implementation PB3ClassifyTabInfo

@dynamic tabType;
@dynamic tabName;

typedef struct PB3ClassifyTabInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3ClassifyTabType tabType;
  NSString *tabName;
} PB3ClassifyTabInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB3ClassifyTabType_EnumDescriptor,
        .number = PB3ClassifyTabInfo_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClassifyTabInfo__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tabName",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClassifyTabInfo_FieldNumber_TabName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ClassifyTabInfo__storage_, tabName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClassifyTabInfo class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClassifyTabInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClassifyTabInfo_TabType_RawValue(PB3ClassifyTabInfo *message) {
  GPBDescriptor *descriptor = [PB3ClassifyTabInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClassifyTabInfo_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClassifyTabInfo_TabType_RawValue(PB3ClassifyTabInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClassifyTabInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClassifyTabInfo_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ListClassifyTabConfReq

@implementation PB3ListClassifyTabConfReq


typedef struct PB3ListClassifyTabConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ListClassifyTabConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListClassifyTabConfReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ListClassifyTabConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListClassifyTabConfRes

@implementation PB3ListClassifyTabConfRes

@dynamic tabInfoArray, tabInfoArray_Count;

typedef struct PB3ListClassifyTabConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabInfoArray;
} PB3ListClassifyTabConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ClassifyTabInfo),
        .number = PB3ListClassifyTabConfRes_FieldNumber_TabInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListClassifyTabConfRes__storage_, tabInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListClassifyTabConfRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListClassifyTabConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000tabInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchangeReq

@implementation PB3LogPointExchangeReq


typedef struct PB3LogPointExchangeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LogPointExchangeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchangeReq class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LogPointExchangeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchangeRes

@implementation PB3LogPointExchangeRes

@dynamic logPointArray, logPointArray_Count;

typedef struct PB3LogPointExchangeRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *logPointArray;
} PB3LogPointExchangeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logPointArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3LogPointExchange),
        .number = PB3LogPointExchangeRes_FieldNumber_LogPointArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3LogPointExchangeRes__storage_, logPointArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchangeRes class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogPointExchangeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LogPointExchange

@implementation PB3LogPointExchange

@dynamic exchangeId;
@dynamic exchangeName;
@dynamic exchangeNum;
@dynamic costPoint;
@dynamic createAt;

typedef struct PB3LogPointExchange__storage_ {
  uint32_t _has_storage_[1];
  int32_t exchangeId;
  int32_t exchangeNum;
  NSString *exchangeName;
  int64_t costPoint;
  int64_t createAt;
} PB3LogPointExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exchangeName",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exchangeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_ExchangeNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, exchangeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "costPoint",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_CostPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, costPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3LogPointExchange_FieldNumber_CreateAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3LogPointExchange__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LogPointExchange class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LogPointExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PointStoreLimit

@implementation PB3PointStoreLimit

@dynamic id_p;
@dynamic useNum;

typedef struct PB3PointStoreLimit__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t useNum;
} PB3PointStoreLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointStoreLimit_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PointStoreLimit__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "useNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3PointStoreLimit_FieldNumber_UseNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PointStoreLimit__storage_, useNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PointStoreLimit class]
                                     rootClass:[PB3StoreExtRoot class]
                                          file:PB3StoreExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PointStoreLimit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
