// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/play.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/PlayExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3PlayExtRoot

@implementation PB3PlayExtRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PB3PlayExtRoot_FileDescriptor

static GPBFileDescriptor *PB3PlayExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3SongType

GPBEnumDescriptor *PB3SongType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StNormal\000StOxygen\000";
    static const int32_t values[] = {
        PB3SongType_StNormal,
        PB3SongType_StOxygen,
    };
    static const char *extraTextFormatInfo = "\002\000b\206\000\001b\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SongType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SongType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SongType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SongType_StNormal:
    case PB3SongType_StOxygen:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3LikeSongOperation

GPBEnumDescriptor *PB3LikeSongOperation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LsoNone\000LsoLike\000LsoUnlike\000LsoPlay\000LsoSha"
        "re\000";
    static const int32_t values[] = {
        PB3LikeSongOperation_LsoNone,
        PB3LikeSongOperation_LsoLike,
        PB3LikeSongOperation_LsoUnlike,
        PB3LikeSongOperation_LsoPlay,
        PB3LikeSongOperation_LsoShare,
    };
    static const char *extraTextFormatInfo = "\005\000c\204\000\001c\204\000\002c\206\000\003c\204\000\004c\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3LikeSongOperation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3LikeSongOperation_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3LikeSongOperation_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3LikeSongOperation_LsoNone:
    case PB3LikeSongOperation_LsoLike:
    case PB3LikeSongOperation_LsoUnlike:
    case PB3LikeSongOperation_LsoPlay:
    case PB3LikeSongOperation_LsoShare:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3Song

@implementation PB3Song

@dynamic id_p;
@dynamic name;
@dynamic singer;
@dynamic uploadsName;
@dynamic uploadsId;
@dynamic uploadSize;
@dynamic download;
@dynamic time;
@dynamic tagArray, tagArray_Count;
@dynamic singerId;
@dynamic songType;
@dynamic lyrics;
@dynamic roomId;
@dynamic redHeart;
@dynamic songTime;
@dynamic singerIcon;
@dynamic fansNum;
@dynamic imagesArray, imagesArray_Count;

typedef struct PB3Song__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t uploadsId;
  float uploadSize;
  PB3SongType songType;
  int32_t fansNum;
  NSString *name;
  NSString *singer;
  NSString *uploadsName;
  NSString *download;
  NSMutableArray *tagArray;
  NSString *lyrics;
  NSString *singerIcon;
  NSMutableArray *imagesArray;
  int64_t time;
  int64_t singerId;
  int64_t roomId;
  int64_t songTime;
} PB3Song__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Song__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Song__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "singer",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Singer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Song__storage_, singer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uploadsName",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_UploadsName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Song__storage_, uploadsName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uploadsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_UploadsId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Song__storage_, uploadsId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uploadSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_UploadSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Song__storage_, uploadSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "download",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Download,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3Song__storage_, download),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Time,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3Song__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tagArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SongTag),
        .number = PB3Song_FieldNumber_TagArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Song__storage_, tagArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_SingerId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Song__storage_, singerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "songType",
        .dataTypeSpecific.enumDescFunc = PB3SongType_EnumDescriptor,
        .number = PB3Song_FieldNumber_SongType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Song__storage_, songType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lyrics",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_Lyrics,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Song__storage_, lyrics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_RoomId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Song__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "redHeart",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_RedHeart,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "songTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_SongTime,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3Song__storage_, songTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "singerIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_SingerIcon,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3Song__storage_, singerIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fansNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_FansNum,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3Song__storage_, fansNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3Song_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Song__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Song class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Song__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\013\000\005\t\000\006\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3Song_SongType_RawValue(PB3Song *message) {
  GPBDescriptor *descriptor = [PB3Song descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Song_FieldNumber_SongType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3Song_SongType_RawValue(PB3Song *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3Song descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Song_FieldNumber_SongType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SongTag

@implementation PB3SongTag

@dynamic tagName;

typedef struct PB3SongTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *tagName;
} PB3SongTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SongTag_FieldNumber_TagName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SongTag__storage_, tagName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SongTag class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SongTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SongHotReq

@implementation PB3SongHotReq

@dynamic name;
@dynamic page;
@dynamic pageSize;
@dynamic songType;
@dynamic sex;

typedef struct PB3SongHotReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  PB3SongType songType;
  int32_t sex;
  NSString *name;
} PB3SongHotReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SongHotReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SongHotReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SongHotReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SongHotReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3SongHotReq_FieldNumber_PageSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SongHotReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "songType",
        .dataTypeSpecific.enumDescFunc = PB3SongType_EnumDescriptor,
        .number = PB3SongHotReq_FieldNumber_SongType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SongHotReq__storage_, songType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3SongHotReq_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SongHotReq__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SongHotReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SongHotReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SongHotReq_SongType_RawValue(PB3SongHotReq *message) {
  GPBDescriptor *descriptor = [PB3SongHotReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SongHotReq_FieldNumber_SongType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SongHotReq_SongType_RawValue(PB3SongHotReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SongHotReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SongHotReq_FieldNumber_SongType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SongHotRes

@implementation PB3SongHotRes

@dynamic songArray, songArray_Count;

typedef struct PB3SongHotRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songArray;
} PB3SongHotRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Song),
        .number = PB3SongHotRes_FieldNumber_SongArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SongHotRes__storage_, songArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SongHotRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SongHotRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerSongReq

@implementation PB3GetPlayerSongReq

@dynamic page;
@dynamic pageSize;

typedef struct PB3GetPlayerSongReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
} PB3GetPlayerSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerSongReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPlayerSongReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPlayerSongReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPlayerSongReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerSongReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPlayerSongRes

@implementation PB3GetPlayerSongRes

@dynamic songArray, songArray_Count;

typedef struct PB3GetPlayerSongRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songArray;
} PB3GetPlayerSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Song),
        .number = PB3GetPlayerSongRes_FieldNumber_SongArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetPlayerSongRes__storage_, songArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPlayerSongRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPlayerSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Song\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AddPlayerSongReq

@implementation PB3AddPlayerSongReq

@dynamic id_p;

typedef struct PB3AddPlayerSongReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3AddPlayerSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AddPlayerSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AddPlayerSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AddPlayerSongReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AddPlayerSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AddPlayerSongRes

@implementation PB3AddPlayerSongRes

@dynamic type;

typedef struct PB3AddPlayerSongRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
} PB3AddPlayerSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3AddPlayerSongRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AddPlayerSongRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AddPlayerSongRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AddPlayerSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DelPlayerSongReq

@implementation PB3DelPlayerSongReq

@dynamic id_p;

typedef struct PB3DelPlayerSongReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3DelPlayerSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3DelPlayerSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DelPlayerSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DelPlayerSongReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DelPlayerSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3DelPlayerSongRes

@implementation PB3DelPlayerSongRes

@dynamic type;

typedef struct PB3DelPlayerSongRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
} PB3DelPlayerSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3DelPlayerSongRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3DelPlayerSongRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3DelPlayerSongRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3DelPlayerSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportSongReq

@implementation PB3ReportSongReq

@dynamic id_p;

typedef struct PB3ReportSongReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB3ReportSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportSongReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportSongRes

@implementation PB3ReportSongRes

@dynamic type;

typedef struct PB3ReportSongRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
} PB3ReportSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportSongRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportSongRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportSongRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LikeSongReq

@implementation PB3LikeSongReq

@dynamic id_p;
@dynamic operationType;
@dynamic type;

typedef struct PB3LikeSongReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3LikeSongOperation operationType;
  PB3SongType type;
} PB3LikeSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3LikeSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LikeSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "operationType",
        .dataTypeSpecific.enumDescFunc = PB3LikeSongOperation_EnumDescriptor,
        .number = PB3LikeSongReq_FieldNumber_OperationType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LikeSongReq__storage_, operationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3SongType_EnumDescriptor,
        .number = PB3LikeSongReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LikeSongReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LikeSongReq class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LikeSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LikeSongReq_OperationType_RawValue(PB3LikeSongReq *message) {
  GPBDescriptor *descriptor = [PB3LikeSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LikeSongReq_FieldNumber_OperationType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LikeSongReq_OperationType_RawValue(PB3LikeSongReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LikeSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LikeSongReq_FieldNumber_OperationType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3LikeSongReq_Type_RawValue(PB3LikeSongReq *message) {
  GPBDescriptor *descriptor = [PB3LikeSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LikeSongReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LikeSongReq_Type_RawValue(PB3LikeSongReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LikeSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LikeSongReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LikeSongRes

@implementation PB3LikeSongRes


typedef struct PB3LikeSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LikeSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LikeSongRes class]
                                     rootClass:[PB3PlayExtRoot class]
                                          file:PB3PlayExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LikeSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
