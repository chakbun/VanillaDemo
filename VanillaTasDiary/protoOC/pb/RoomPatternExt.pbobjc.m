// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/room_pattern.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/RoomPatternExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
#import "pb/RoomSingleLiveExt.pbobjc.h"
#import "pb/RoomExt.pbobjc.h"
#import "pb/CloudDiscoExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - PB3RoomPatternExtRoot

@implementation PB3RoomPatternExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3RoomPatternExtRoot_FileDescriptor

static GPBFileDescriptor *PB3RoomPatternExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3RoomPatternErr

GPBEnumDescriptor *PB3RoomPatternErr_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RpeSuccess\000RpeErrCodeAuctionSet\000RpeErrCo"
        "deAuctionBlacklist\000RpeErrCodeAuctionPric"
        "eMin\000RpeErrCodeAuctionPriceMax\000RpeErrCod"
        "eAuctionPriceErr\000RpeErrCodeAuctionGiftMi"
        "nPrice\000RpeErrCodeAuctionChairOpen\000RpeErr"
        "CodeAuctionLeaveChair\000RpeErrCodeAuctionS"
        "tart\000RpeErrCodeAuctionState\000RpeErrCodeAu"
        "ctionBidding\000RpeErrCodeAuctionPatternUpd"
        "ate\000RpeErrCodeAuctionBiddingPrice\000RpeErr"
        "CodeAuctionBiddingMinPrice\000RpeErrCodePkT"
        "auntGold\000";
    static const int32_t values[] = {
        PB3RoomPatternErr_RpeSuccess,
        PB3RoomPatternErr_RpeErrCodeAuctionSet,
        PB3RoomPatternErr_RpeErrCodeAuctionBlacklist,
        PB3RoomPatternErr_RpeErrCodeAuctionPriceMin,
        PB3RoomPatternErr_RpeErrCodeAuctionPriceMax,
        PB3RoomPatternErr_RpeErrCodeAuctionPriceErr,
        PB3RoomPatternErr_RpeErrCodeAuctionGiftMinPrice,
        PB3RoomPatternErr_RpeErrCodeAuctionChairOpen,
        PB3RoomPatternErr_RpeErrCodeAuctionLeaveChair,
        PB3RoomPatternErr_RpeErrCodeAuctionStart,
        PB3RoomPatternErr_RpeErrCodeAuctionState,
        PB3RoomPatternErr_RpeErrCodeAuctionBidding,
        PB3RoomPatternErr_RpeErrCodeAuctionPatternUpdate,
        PB3RoomPatternErr_RpeErrCodeAuctionBiddingPrice,
        PB3RoomPatternErr_RpeErrCodeAuctionBiddingMinPrice,
        PB3RoomPatternErr_RpeErrCodePkTauntGold,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RoomPatternErr)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RoomPatternErr_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RoomPatternErr_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RoomPatternErr_RpeSuccess:
    case PB3RoomPatternErr_RpeErrCodeAuctionSet:
    case PB3RoomPatternErr_RpeErrCodeAuctionBlacklist:
    case PB3RoomPatternErr_RpeErrCodeAuctionPriceMin:
    case PB3RoomPatternErr_RpeErrCodeAuctionPriceMax:
    case PB3RoomPatternErr_RpeErrCodeAuctionPriceErr:
    case PB3RoomPatternErr_RpeErrCodeAuctionGiftMinPrice:
    case PB3RoomPatternErr_RpeErrCodeAuctionChairOpen:
    case PB3RoomPatternErr_RpeErrCodeAuctionLeaveChair:
    case PB3RoomPatternErr_RpeErrCodeAuctionStart:
    case PB3RoomPatternErr_RpeErrCodeAuctionState:
    case PB3RoomPatternErr_RpeErrCodeAuctionBidding:
    case PB3RoomPatternErr_RpeErrCodeAuctionPatternUpdate:
    case PB3RoomPatternErr_RpeErrCodeAuctionBiddingPrice:
    case PB3RoomPatternErr_RpeErrCodeAuctionBiddingMinPrice:
    case PB3RoomPatternErr_RpeErrCodePkTauntGold:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3RoomPatternCmdId

GPBEnumDescriptor *PB3RoomPatternCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RpcZero\000RpcAuctionState\000RpcAuctionRank\000R"
        "pcAuctionEnd\000RpcAuctionGiftConf\000RpcAucti"
        "onBiddingPrice\000RpcAuctionGift\000RpcAuction"
        "BiddingSyatem\000RpcAuctionBiddingArtificia"
        "l\000RpcSingleLiveStats\000RpcSingleLiveInfo\000R"
        "pcMobaTeamBaseInfo\000RpcMobaTeamMemberInfo"
        "\000RpcMobaTeamDepartureBroadcast\000RpcMobaTe"
        "amChangeStatus\000RpcMobaTeamPatternBroadca"
        "st\000RpcMobaTeamPatternGuide\000RpcMobaTeamSh"
        "owGameInfoBroadcast\000RpcMobaTeamGameInfoC"
        "hange\000RpcProgramUpdate\000RpcProgramShowNot"
        "iceUpdate\000RpcProgramShowUpdate\000RpcProgra"
        "mShowDelete\000RpcProgramOnlineInfo\000PrcPkTe"
        "amInfo\000RpcPkTeamPush\000RpcPkUseSkill\000RpcPk"
        "TreasureBox\000RpcPkInvite\000RpcPkMatch\000RpcPk"
        "ProtectPush\000RpcPkMvpGlobalPush\000PrcPkRewa"
        "rdTicketPush\000RpcPkTauntRoomNotice\000PrcSin"
        "gleLivePerm\000RpcPkHostInfo\000RpcPkPushMuteT"
        "ype\000PrcSingleLivePkTeamInfo\000RpcSingleLiv"
        "ePkTeamPush\000RpcSingleLivePkUseSkill\000RpcS"
        "ingleLivePkTreasureBox\000RpcSingleLivePkIn"
        "vite\000RpcSingleLivePkMatch\000RpcSingleLiveP"
        "kProtectPush\000RpcSingleLivePkMvpGlobalPus"
        "h\000PrcSingleLivePkRewardTicketPush\000RpcSin"
        "gleLivePkTauntRoomNotice\000RpcSingleLivePk"
        "PushMuteType\000RpcSingleLivePkSubRank\000RpcS"
        "ingleLivePkChairChange\000RpcCloudDiscoBoot"
        "hSeat\000RpcCloudDiscoInfo\000RpcCloudDiscoSce"
        "ne\000RpcCloudDiscoEnterRoom\000RpcCloudDiscoD"
        "ancerCfg\000RpcCloudDiscoRockBroadcast\000";
    static const int32_t values[] = {
        PB3RoomPatternCmdId_RpcZero,
        PB3RoomPatternCmdId_RpcAuctionState,
        PB3RoomPatternCmdId_RpcAuctionRank,
        PB3RoomPatternCmdId_RpcAuctionEnd,
        PB3RoomPatternCmdId_RpcAuctionGiftConf,
        PB3RoomPatternCmdId_RpcAuctionBiddingPrice,
        PB3RoomPatternCmdId_RpcAuctionGift,
        PB3RoomPatternCmdId_RpcAuctionBiddingSyatem,
        PB3RoomPatternCmdId_RpcAuctionBiddingArtificial,
        PB3RoomPatternCmdId_RpcSingleLiveStats,
        PB3RoomPatternCmdId_RpcSingleLiveInfo,
        PB3RoomPatternCmdId_RpcMobaTeamBaseInfo,
        PB3RoomPatternCmdId_RpcMobaTeamMemberInfo,
        PB3RoomPatternCmdId_RpcMobaTeamDepartureBroadcast,
        PB3RoomPatternCmdId_RpcMobaTeamChangeStatus,
        PB3RoomPatternCmdId_RpcMobaTeamPatternBroadcast,
        PB3RoomPatternCmdId_RpcMobaTeamPatternGuide,
        PB3RoomPatternCmdId_RpcMobaTeamShowGameInfoBroadcast,
        PB3RoomPatternCmdId_RpcMobaTeamGameInfoChange,
        PB3RoomPatternCmdId_RpcProgramUpdate,
        PB3RoomPatternCmdId_RpcProgramShowNoticeUpdate,
        PB3RoomPatternCmdId_RpcProgramShowUpdate,
        PB3RoomPatternCmdId_RpcProgramShowDelete,
        PB3RoomPatternCmdId_RpcProgramOnlineInfo,
        PB3RoomPatternCmdId_PrcPkTeamInfo,
        PB3RoomPatternCmdId_RpcPkTeamPush,
        PB3RoomPatternCmdId_RpcPkUseSkill,
        PB3RoomPatternCmdId_RpcPkTreasureBox,
        PB3RoomPatternCmdId_RpcPkInvite,
        PB3RoomPatternCmdId_RpcPkMatch,
        PB3RoomPatternCmdId_RpcPkProtectPush,
        PB3RoomPatternCmdId_RpcPkMvpGlobalPush,
        PB3RoomPatternCmdId_PrcPkRewardTicketPush,
        PB3RoomPatternCmdId_RpcPkTauntRoomNotice,
        PB3RoomPatternCmdId_PrcSingleLivePerm,
        PB3RoomPatternCmdId_RpcPkHostInfo,
        PB3RoomPatternCmdId_RpcPkPushMuteType,
        PB3RoomPatternCmdId_PrcSingleLivePkTeamInfo,
        PB3RoomPatternCmdId_RpcSingleLivePkTeamPush,
        PB3RoomPatternCmdId_RpcSingleLivePkUseSkill,
        PB3RoomPatternCmdId_RpcSingleLivePkTreasureBox,
        PB3RoomPatternCmdId_RpcSingleLivePkInvite,
        PB3RoomPatternCmdId_RpcSingleLivePkMatch,
        PB3RoomPatternCmdId_RpcSingleLivePkProtectPush,
        PB3RoomPatternCmdId_RpcSingleLivePkMvpGlobalPush,
        PB3RoomPatternCmdId_PrcSingleLivePkRewardTicketPush,
        PB3RoomPatternCmdId_RpcSingleLivePkTauntRoomNotice,
        PB3RoomPatternCmdId_RpcSingleLivePkPushMuteType,
        PB3RoomPatternCmdId_RpcSingleLivePkSubRank,
        PB3RoomPatternCmdId_RpcSingleLivePkChairChange,
        PB3RoomPatternCmdId_RpcCloudDiscoBoothSeat,
        PB3RoomPatternCmdId_RpcCloudDiscoInfo,
        PB3RoomPatternCmdId_RpcCloudDiscoScene,
        PB3RoomPatternCmdId_RpcCloudDiscoEnterRoom,
        PB3RoomPatternCmdId_RpcCloudDiscoDancerCfg,
        PB3RoomPatternCmdId_RpcCloudDiscoRockBroadcast,
    };
    static const char *extraTextFormatInfo = "\002\tc\217\000\nc\216\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3RoomPatternCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3RoomPatternCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3RoomPatternCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3RoomPatternCmdId_RpcZero:
    case PB3RoomPatternCmdId_RpcAuctionState:
    case PB3RoomPatternCmdId_RpcAuctionRank:
    case PB3RoomPatternCmdId_RpcAuctionEnd:
    case PB3RoomPatternCmdId_RpcAuctionGiftConf:
    case PB3RoomPatternCmdId_RpcAuctionBiddingPrice:
    case PB3RoomPatternCmdId_RpcAuctionGift:
    case PB3RoomPatternCmdId_RpcAuctionBiddingSyatem:
    case PB3RoomPatternCmdId_RpcAuctionBiddingArtificial:
    case PB3RoomPatternCmdId_RpcSingleLiveStats:
    case PB3RoomPatternCmdId_RpcSingleLiveInfo:
    case PB3RoomPatternCmdId_RpcMobaTeamBaseInfo:
    case PB3RoomPatternCmdId_RpcMobaTeamMemberInfo:
    case PB3RoomPatternCmdId_RpcMobaTeamDepartureBroadcast:
    case PB3RoomPatternCmdId_RpcMobaTeamChangeStatus:
    case PB3RoomPatternCmdId_RpcMobaTeamPatternBroadcast:
    case PB3RoomPatternCmdId_RpcMobaTeamPatternGuide:
    case PB3RoomPatternCmdId_RpcMobaTeamShowGameInfoBroadcast:
    case PB3RoomPatternCmdId_RpcMobaTeamGameInfoChange:
    case PB3RoomPatternCmdId_RpcProgramUpdate:
    case PB3RoomPatternCmdId_RpcProgramShowNoticeUpdate:
    case PB3RoomPatternCmdId_RpcProgramShowUpdate:
    case PB3RoomPatternCmdId_RpcProgramShowDelete:
    case PB3RoomPatternCmdId_RpcProgramOnlineInfo:
    case PB3RoomPatternCmdId_PrcPkTeamInfo:
    case PB3RoomPatternCmdId_RpcPkTeamPush:
    case PB3RoomPatternCmdId_RpcPkUseSkill:
    case PB3RoomPatternCmdId_RpcPkTreasureBox:
    case PB3RoomPatternCmdId_RpcPkInvite:
    case PB3RoomPatternCmdId_RpcPkMatch:
    case PB3RoomPatternCmdId_RpcPkProtectPush:
    case PB3RoomPatternCmdId_RpcPkMvpGlobalPush:
    case PB3RoomPatternCmdId_PrcPkRewardTicketPush:
    case PB3RoomPatternCmdId_RpcPkTauntRoomNotice:
    case PB3RoomPatternCmdId_PrcSingleLivePerm:
    case PB3RoomPatternCmdId_RpcPkHostInfo:
    case PB3RoomPatternCmdId_RpcPkPushMuteType:
    case PB3RoomPatternCmdId_PrcSingleLivePkTeamInfo:
    case PB3RoomPatternCmdId_RpcSingleLivePkTeamPush:
    case PB3RoomPatternCmdId_RpcSingleLivePkUseSkill:
    case PB3RoomPatternCmdId_RpcSingleLivePkTreasureBox:
    case PB3RoomPatternCmdId_RpcSingleLivePkInvite:
    case PB3RoomPatternCmdId_RpcSingleLivePkMatch:
    case PB3RoomPatternCmdId_RpcSingleLivePkProtectPush:
    case PB3RoomPatternCmdId_RpcSingleLivePkMvpGlobalPush:
    case PB3RoomPatternCmdId_PrcSingleLivePkRewardTicketPush:
    case PB3RoomPatternCmdId_RpcSingleLivePkTauntRoomNotice:
    case PB3RoomPatternCmdId_RpcSingleLivePkPushMuteType:
    case PB3RoomPatternCmdId_RpcSingleLivePkSubRank:
    case PB3RoomPatternCmdId_RpcSingleLivePkChairChange:
    case PB3RoomPatternCmdId_RpcCloudDiscoBoothSeat:
    case PB3RoomPatternCmdId_RpcCloudDiscoInfo:
    case PB3RoomPatternCmdId_RpcCloudDiscoScene:
    case PB3RoomPatternCmdId_RpcCloudDiscoEnterRoom:
    case PB3RoomPatternCmdId_RpcCloudDiscoDancerCfg:
    case PB3RoomPatternCmdId_RpcCloudDiscoRockBroadcast:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BiddingType

GPBEnumDescriptor *PB3BiddingType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BtDefault\000BtArtificial\000BtSystem\000";
    static const int32_t values[] = {
        PB3BiddingType_BtDefault,
        PB3BiddingType_BtArtificial,
        PB3BiddingType_BtSystem,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BiddingType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BiddingType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BiddingType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BiddingType_BtDefault:
    case PB3BiddingType_BtArtificial:
    case PB3BiddingType_BtSystem:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SurpassType

GPBEnumDescriptor *PB3SurpassType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SurpassZero\000SurpassKillNil\000SurpassKillAl"
        "l\000SurpassKillFast\000";
    static const int32_t values[] = {
        PB3SurpassType_SurpassZero,
        PB3SurpassType_SurpassKillNil,
        PB3SurpassType_SurpassKillAll,
        PB3SurpassType_SurpassKillFast,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SurpassType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SurpassType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SurpassType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SurpassType_SurpassZero:
    case PB3SurpassType_SurpassKillNil:
    case PB3SurpassType_SurpassKillAll:
    case PB3SurpassType_SurpassKillFast:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TranscendType

GPBEnumDescriptor *PB3TranscendType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TranscendZero\000TranscendFirst\000TranscendSe"
        "cond\000TranscendThird\000";
    static const int32_t values[] = {
        PB3TranscendType_TranscendZero,
        PB3TranscendType_TranscendFirst,
        PB3TranscendType_TranscendSecond,
        PB3TranscendType_TranscendThird,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TranscendType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TranscendType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TranscendType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TranscendType_TranscendZero:
    case PB3TranscendType_TranscendFirst:
    case PB3TranscendType_TranscendSecond:
    case PB3TranscendType_TranscendThird:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AuctionState

GPBEnumDescriptor *PB3AuctionState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AsZero\000AsNotStart\000AsSetting\000AsOnStart\000";
    static const int32_t values[] = {
        PB3AuctionState_AsZero,
        PB3AuctionState_AsNotStart,
        PB3AuctionState_AsSetting,
        PB3AuctionState_AsOnStart,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AuctionState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AuctionState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AuctionState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AuctionState_AsZero:
    case PB3AuctionState_AsNotStart:
    case PB3AuctionState_AsSetting:
    case PB3AuctionState_AsOnStart:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TermStatus

GPBEnumDescriptor *PB3TermStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ReamsZero\000ReamsOrganize\000ReamsPublish\000";
    static const int32_t values[] = {
        PB3TermStatus_ReamsZero,
        PB3TermStatus_ReamsOrganize,
        PB3TermStatus_ReamsPublish,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TermStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TermStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TermStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TermStatus_ReamsZero:
    case PB3TermStatus_ReamsOrganize:
    case PB3TermStatus_ReamsPublish:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TeamOptType

GPBEnumDescriptor *PB3TeamOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TeamotZero\000TeamotDelete\000TeamotPublish\000Te"
        "amotBroadcast\000TeamotMobaRoom\000";
    static const int32_t values[] = {
        PB3TeamOptType_TeamotZero,
        PB3TeamOptType_TeamotDelete,
        PB3TeamOptType_TeamotPublish,
        PB3TeamOptType_TeamotBroadcast,
        PB3TeamOptType_TeamotMobaRoom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TeamOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TeamOptType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TeamOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TeamOptType_TeamotZero:
    case PB3TeamOptType_TeamotDelete:
    case PB3TeamOptType_TeamotPublish:
    case PB3TeamOptType_TeamotBroadcast:
    case PB3TeamOptType_TeamotMobaRoom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3MemberOptType

GPBEnumDescriptor *PB3MemberOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MemberotZero\000MemberotJoin\000MemberotLeave\000"
        "MemberotKickOut\000MemberotClean\000";
    static const int32_t values[] = {
        PB3MemberOptType_MemberotZero,
        PB3MemberOptType_MemberotJoin,
        PB3MemberOptType_MemberotLeave,
        PB3MemberOptType_MemberotKickOut,
        PB3MemberOptType_MemberotClean,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3MemberOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3MemberOptType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3MemberOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3MemberOptType_MemberotZero:
    case PB3MemberOptType_MemberotJoin:
    case PB3MemberOptType_MemberotLeave:
    case PB3MemberOptType_MemberotKickOut:
    case PB3MemberOptType_MemberotClean:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TeamMemberType

GPBEnumDescriptor *PB3TeamMemberType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TeamMtZero\000TeamMtLeader\000TeamMtNormal\000";
    static const int32_t values[] = {
        PB3TeamMemberType_TeamMtZero,
        PB3TeamMemberType_TeamMtLeader,
        PB3TeamMemberType_TeamMtNormal,
    };
    static const char *extraTextFormatInfo = "\003\000\005A\344\000\001\005A\346\000\002\005A\346\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TeamMemberType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TeamMemberType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TeamMemberType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TeamMemberType_TeamMtZero:
    case PB3TeamMemberType_TeamMtLeader:
    case PB3TeamMemberType_TeamMtNormal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TeamSaveType

GPBEnumDescriptor *PB3TeamSaveType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TeamstZero\000TeamstCreate\000TeamstMod\000";
    static const int32_t values[] = {
        PB3TeamSaveType_TeamstZero,
        PB3TeamSaveType_TeamstCreate,
        PB3TeamSaveType_TeamstMod,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TeamSaveType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TeamSaveType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TeamSaveType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TeamSaveType_TeamstZero:
    case PB3TeamSaveType_TeamstCreate:
    case PB3TeamSaveType_TeamstMod:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3MobaTeamStatus

GPBEnumDescriptor *PB3MobaTeamStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MobatsZero\000MobatsJoin\000MobatsLeave\000Mobats"
        "KickOut\000MobatsClean\000MobatsDelete\000MobatsL"
        "eader\000MobatsPublish\000";
    static const int32_t values[] = {
        PB3MobaTeamStatus_MobatsZero,
        PB3MobaTeamStatus_MobatsJoin,
        PB3MobaTeamStatus_MobatsLeave,
        PB3MobaTeamStatus_MobatsKickOut,
        PB3MobaTeamStatus_MobatsClean,
        PB3MobaTeamStatus_MobatsDelete,
        PB3MobaTeamStatus_MobatsLeader,
        PB3MobaTeamStatus_MobatsPublish,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3MobaTeamStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3MobaTeamStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3MobaTeamStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3MobaTeamStatus_MobatsZero:
    case PB3MobaTeamStatus_MobatsJoin:
    case PB3MobaTeamStatus_MobatsLeave:
    case PB3MobaTeamStatus_MobatsKickOut:
    case PB3MobaTeamStatus_MobatsClean:
    case PB3MobaTeamStatus_MobatsDelete:
    case PB3MobaTeamStatus_MobatsLeader:
    case PB3MobaTeamStatus_MobatsPublish:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PkStatus

GPBEnumDescriptor *PB3PkStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PsZero\000PsInPk\000PsPkEnd\000PsPkInviting\000PsPkM"
        "atching\000PsPkMatchSuccess\000PsPkPunishment\000";
    static const int32_t values[] = {
        PB3PkStatus_PsZero,
        PB3PkStatus_PsInPk,
        PB3PkStatus_PsPkEnd,
        PB3PkStatus_PsPkInviting,
        PB3PkStatus_PsPkMatching,
        PB3PkStatus_PsPkMatchSuccess,
        PB3PkStatus_PsPkPunishment,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PkStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PkStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PkStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PkStatus_PsZero:
    case PB3PkStatus_PsInPk:
    case PB3PkStatus_PsPkEnd:
    case PB3PkStatus_PsPkInviting:
    case PB3PkStatus_PsPkMatching:
    case PB3PkStatus_PsPkMatchSuccess:
    case PB3PkStatus_PsPkPunishment:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PkResult

GPBEnumDescriptor *PB3PkResult_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PkrZero\000PkrWinner\000PkrLoser\000PkrDraw\000";
    static const int32_t values[] = {
        PB3PkResult_PkrZero,
        PB3PkResult_PkrWinner,
        PB3PkResult_PkrLoser,
        PB3PkResult_PkrDraw,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PkResult)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PkResult_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PkResult_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PkResult_PkrZero:
    case PB3PkResult_PkrWinner:
    case PB3PkResult_PkrLoser:
    case PB3PkResult_PkrDraw:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SeckillStatus

GPBEnumDescriptor *PB3SeckillStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SksZero\000SksStart\000SksCancel\000";
    static const int32_t values[] = {
        PB3SeckillStatus_SksZero,
        PB3SeckillStatus_SksStart,
        PB3SeckillStatus_SksCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SeckillStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SeckillStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SeckillStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SeckillStatus_SksZero:
    case PB3SeckillStatus_SksStart:
    case PB3SeckillStatus_SksCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TreasureBoxStatus

GPBEnumDescriptor *PB3TreasureBoxStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TbsZero\000TbsBoxNull\000TbsSuccess\000TbsReceive"
        "d\000TbsNotHit\000";
    static const int32_t values[] = {
        PB3TreasureBoxStatus_TbsZero,
        PB3TreasureBoxStatus_TbsBoxNull,
        PB3TreasureBoxStatus_TbsSuccess,
        PB3TreasureBoxStatus_TbsReceived,
        PB3TreasureBoxStatus_TbsNotHit,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TreasureBoxStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TreasureBoxStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TreasureBoxStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TreasureBoxStatus_TbsZero:
    case PB3TreasureBoxStatus_TbsBoxNull:
    case PB3TreasureBoxStatus_TbsSuccess:
    case PB3TreasureBoxStatus_TbsReceived:
    case PB3TreasureBoxStatus_TbsNotHit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WeekPkRankType

GPBEnumDescriptor *PB3WeekPkRankType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WprtZero\000WprtThisWeek\000WprtLastWeek\000";
    static const int32_t values[] = {
        PB3WeekPkRankType_WprtZero,
        PB3WeekPkRankType_WprtThisWeek,
        PB3WeekPkRankType_WprtLastWeek,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WeekPkRankType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WeekPkRankType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WeekPkRankType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WeekPkRankType_WprtZero:
    case PB3WeekPkRankType_WprtThisWeek:
    case PB3WeekPkRankType_WprtLastWeek:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PkInviteAction

GPBEnumDescriptor *PB3PkInviteAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PkiaZero\000PkiaInvited\000PkiaInviteCancel\000Pk"
        "iaInviteReject\000PkiaInviteTimeout\000";
    static const int32_t values[] = {
        PB3PkInviteAction_PkiaZero,
        PB3PkInviteAction_PkiaInvited,
        PB3PkInviteAction_PkiaInviteCancel,
        PB3PkInviteAction_PkiaInviteReject,
        PB3PkInviteAction_PkiaInviteTimeout,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PkInviteAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PkInviteAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PkInviteAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PkInviteAction_PkiaZero:
    case PB3PkInviteAction_PkiaInvited:
    case PB3PkInviteAction_PkiaInviteCancel:
    case PB3PkInviteAction_PkiaInviteReject:
    case PB3PkInviteAction_PkiaInviteTimeout:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PkInviteRejectType

GPBEnumDescriptor *PB3PkInviteRejectType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PkirtZero\000PkirtOncePerson\000PkirtTodayPers"
        "on\000PkirtTodayForbid\000";
    static const int32_t values[] = {
        PB3PkInviteRejectType_PkirtZero,
        PB3PkInviteRejectType_PkirtOncePerson,
        PB3PkInviteRejectType_PkirtTodayPerson,
        PB3PkInviteRejectType_PkirtTodayForbid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PkInviteRejectType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PkInviteRejectType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PkInviteRejectType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PkInviteRejectType_PkirtZero:
    case PB3PkInviteRejectType_PkirtOncePerson:
    case PB3PkInviteRejectType_PkirtTodayPerson:
    case PB3PkInviteRejectType_PkirtTodayForbid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PkMatchAction

GPBEnumDescriptor *PB3PkMatchAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PkmaZero\000PkmaMatchTimeout\000PkmaMatchSucce"
        "ss\000PkmaMatchStart\000PkmaMatchStartTimeout\000"
        "PkmaMatchStartFail\000PkmaMatchCancel\000";
    static const int32_t values[] = {
        PB3PkMatchAction_PkmaZero,
        PB3PkMatchAction_PkmaMatchTimeout,
        PB3PkMatchAction_PkmaMatchSuccess,
        PB3PkMatchAction_PkmaMatchStart,
        PB3PkMatchAction_PkmaMatchStartTimeout,
        PB3PkMatchAction_PkmaMatchStartFail,
        PB3PkMatchAction_PkmaMatchCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PkMatchAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PkMatchAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PkMatchAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PkMatchAction_PkmaZero:
    case PB3PkMatchAction_PkmaMatchTimeout:
    case PB3PkMatchAction_PkmaMatchSuccess:
    case PB3PkMatchAction_PkmaMatchStart:
    case PB3PkMatchAction_PkmaMatchStartTimeout:
    case PB3PkMatchAction_PkmaMatchStartFail:
    case PB3PkMatchAction_PkmaMatchCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3MuteType

GPBEnumDescriptor *PB3MuteType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MutetZero\000MutetStart\000MutetStop\000";
    static const int32_t values[] = {
        PB3MuteType_MutetZero,
        PB3MuteType_MutetStart,
        PB3MuteType_MutetStop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3MuteType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3MuteType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3MuteType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3MuteType_MutetZero:
    case PB3MuteType_MutetStart:
    case PB3MuteType_MutetStop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkStatus

GPBEnumDescriptor *PB3SingleLivePkStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPsZero\000SlPsInPk\000SlPsPkEnd\000SlPsPkInviti"
        "ng\000SlPsPkMatching\000SlPsPkMatchSuccess\000SlP"
        "sPkPunishment\000";
    static const int32_t values[] = {
        PB3SingleLivePkStatus_SlPsZero,
        PB3SingleLivePkStatus_SlPsInPk,
        PB3SingleLivePkStatus_SlPsPkEnd,
        PB3SingleLivePkStatus_SlPsPkInviting,
        PB3SingleLivePkStatus_SlPsPkMatching,
        PB3SingleLivePkStatus_SlPsPkMatchSuccess,
        PB3SingleLivePkStatus_SlPsPkPunishment,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkStatus_SlPsZero:
    case PB3SingleLivePkStatus_SlPsInPk:
    case PB3SingleLivePkStatus_SlPsPkEnd:
    case PB3SingleLivePkStatus_SlPsPkInviting:
    case PB3SingleLivePkStatus_SlPsPkMatching:
    case PB3SingleLivePkStatus_SlPsPkMatchSuccess:
    case PB3SingleLivePkStatus_SlPsPkPunishment:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkResult

GPBEnumDescriptor *PB3SingleLivePkResult_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPkrZero\000SlPkrWinner\000SlPkrLoser\000SlPkrDr"
        "aw\000";
    static const int32_t values[] = {
        PB3SingleLivePkResult_SlPkrZero,
        PB3SingleLivePkResult_SlPkrWinner,
        PB3SingleLivePkResult_SlPkrLoser,
        PB3SingleLivePkResult_SlPkrDraw,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkResult)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkResult_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkResult_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkResult_SlPkrZero:
    case PB3SingleLivePkResult_SlPkrWinner:
    case PB3SingleLivePkResult_SlPkrLoser:
    case PB3SingleLivePkResult_SlPkrDraw:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLiveSeckillStatus

GPBEnumDescriptor *PB3SingleLiveSeckillStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlSksZero\000SlSksStart\000SlSksCancel\000";
    static const int32_t values[] = {
        PB3SingleLiveSeckillStatus_SlSksZero,
        PB3SingleLiveSeckillStatus_SlSksStart,
        PB3SingleLiveSeckillStatus_SlSksCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLiveSeckillStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLiveSeckillStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLiveSeckillStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLiveSeckillStatus_SlSksZero:
    case PB3SingleLiveSeckillStatus_SlSksStart:
    case PB3SingleLiveSeckillStatus_SlSksCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLiveWeekPkRankType

GPBEnumDescriptor *PB3SingleLiveWeekPkRankType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlWprtZero\000SlWprtThisWeek\000SlWprtLastWeek"
        "\000";
    static const int32_t values[] = {
        PB3SingleLiveWeekPkRankType_SlWprtZero,
        PB3SingleLiveWeekPkRankType_SlWprtThisWeek,
        PB3SingleLiveWeekPkRankType_SlWprtLastWeek,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLiveWeekPkRankType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLiveWeekPkRankType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLiveWeekPkRankType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLiveWeekPkRankType_SlWprtZero:
    case PB3SingleLiveWeekPkRankType_SlWprtThisWeek:
    case PB3SingleLiveWeekPkRankType_SlWprtLastWeek:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkInviteAction

GPBEnumDescriptor *PB3SingleLivePkInviteAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPkiaZero\000SlPkiaInvited\000SlPkiaInviteCan"
        "cel\000SlPkiaInviteReject\000SlPkiaInviteTimeo"
        "ut\000";
    static const int32_t values[] = {
        PB3SingleLivePkInviteAction_SlPkiaZero,
        PB3SingleLivePkInviteAction_SlPkiaInvited,
        PB3SingleLivePkInviteAction_SlPkiaInviteCancel,
        PB3SingleLivePkInviteAction_SlPkiaInviteReject,
        PB3SingleLivePkInviteAction_SlPkiaInviteTimeout,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkInviteAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkInviteAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkInviteAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkInviteAction_SlPkiaZero:
    case PB3SingleLivePkInviteAction_SlPkiaInvited:
    case PB3SingleLivePkInviteAction_SlPkiaInviteCancel:
    case PB3SingleLivePkInviteAction_SlPkiaInviteReject:
    case PB3SingleLivePkInviteAction_SlPkiaInviteTimeout:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkInviteRejectType

GPBEnumDescriptor *PB3SingleLivePkInviteRejectType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPkirtZero\000SlPkirtOncePerson\000SlPkirtTod"
        "ayPerson\000SlPkirtTodayForbid\000";
    static const int32_t values[] = {
        PB3SingleLivePkInviteRejectType_SlPkirtZero,
        PB3SingleLivePkInviteRejectType_SlPkirtOncePerson,
        PB3SingleLivePkInviteRejectType_SlPkirtTodayPerson,
        PB3SingleLivePkInviteRejectType_SlPkirtTodayForbid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkInviteRejectType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkInviteRejectType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkInviteRejectType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkInviteRejectType_SlPkirtZero:
    case PB3SingleLivePkInviteRejectType_SlPkirtOncePerson:
    case PB3SingleLivePkInviteRejectType_SlPkirtTodayPerson:
    case PB3SingleLivePkInviteRejectType_SlPkirtTodayForbid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkMatchAction

GPBEnumDescriptor *PB3SingleLivePkMatchAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPkmaZero\000SlPkmaMatchTimeout\000SlPkmaMatc"
        "hSuccess\000SlPkmaMatchStart\000SlPkmaMatchSta"
        "rtTimeout\000SlPkmaMatchStartFail\000SlPkmaMat"
        "chCancel\000";
    static const int32_t values[] = {
        PB3SingleLivePkMatchAction_SlPkmaZero,
        PB3SingleLivePkMatchAction_SlPkmaMatchTimeout,
        PB3SingleLivePkMatchAction_SlPkmaMatchSuccess,
        PB3SingleLivePkMatchAction_SlPkmaMatchStart,
        PB3SingleLivePkMatchAction_SlPkmaMatchStartTimeout,
        PB3SingleLivePkMatchAction_SlPkmaMatchStartFail,
        PB3SingleLivePkMatchAction_SlPkmaMatchCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkMatchAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkMatchAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkMatchAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkMatchAction_SlPkmaZero:
    case PB3SingleLivePkMatchAction_SlPkmaMatchTimeout:
    case PB3SingleLivePkMatchAction_SlPkmaMatchSuccess:
    case PB3SingleLivePkMatchAction_SlPkmaMatchStart:
    case PB3SingleLivePkMatchAction_SlPkmaMatchStartTimeout:
    case PB3SingleLivePkMatchAction_SlPkmaMatchStartFail:
    case PB3SingleLivePkMatchAction_SlPkmaMatchCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLiveMuteType

GPBEnumDescriptor *PB3SingleLiveMuteType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlMutetZero\000SlMutetStart\000SlMutetStop\000";
    static const int32_t values[] = {
        PB3SingleLiveMuteType_SlMutetZero,
        PB3SingleLiveMuteType_SlMutetStart,
        PB3SingleLiveMuteType_SlMutetStop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLiveMuteType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLiveMuteType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLiveMuteType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLiveMuteType_SlMutetZero:
    case PB3SingleLiveMuteType_SlMutetStart:
    case PB3SingleLiveMuteType_SlMutetStop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SingleLivePkChairChangeType

GPBEnumDescriptor *PB3SingleLivePkChairChangeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlPkCctZero\000SlPkCctMove\000SlPkCctSit\000";
    static const int32_t values[] = {
        PB3SingleLivePkChairChangeType_SlPkCctZero,
        PB3SingleLivePkChairChangeType_SlPkCctMove,
        PB3SingleLivePkChairChangeType_SlPkCctSit,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SingleLivePkChairChangeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SingleLivePkChairChangeType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SingleLivePkChairChangeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SingleLivePkChairChangeType_SlPkCctZero:
    case PB3SingleLivePkChairChangeType_SlPkCctMove:
    case PB3SingleLivePkChairChangeType_SlPkCctSit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3AuctionConfReq

@implementation PB3AuctionConfReq


typedef struct PB3AuctionConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AuctionConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionConfReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuctionConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionConfRes

@implementation PB3AuctionConfRes

@dynamic serviceListArray, serviceListArray_Count;
@dynamic timeListArray, timeListArray_Count;
@dynamic isUseCustom;
@dynamic rate;
@dynamic priceListArray, priceListArray_Count;

typedef struct PB3AuctionConfRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t rate;
  NSMutableArray *serviceListArray;
  NSMutableArray *timeListArray;
  GPBInt32Array *priceListArray;
} PB3AuctionConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serviceListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionConfRes_FieldNumber_ServiceListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuctionConfRes__storage_, serviceListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionConfRes_FieldNumber_TimeListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuctionConfRes__storage_, timeListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isUseCustom",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionConfRes_FieldNumber_IsUseCustom,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "rate",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionConfRes_FieldNumber_Rate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuctionConfRes__storage_, rate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "priceListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionConfRes_FieldNumber_PriceListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuctionConfRes__storage_, priceListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionConfRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionSetReq

@implementation PB3AuctionSetReq

@dynamic type;
@dynamic content;
@dynamic timeLong;
@dynamic giftId;
@dynamic isCustom;
@dynamic sellGiftId;
@dynamic sellGiftNum;
@dynamic price;

typedef struct PB3AuctionSetReq__storage_ {
  uint32_t _has_storage_[1];
  PB3AuctionType type;
  int32_t giftId;
  int32_t sellGiftId;
  int32_t sellGiftNum;
  int32_t price;
  NSString *content;
  NSString *timeLong;
} PB3AuctionSetReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AuctionType_EnumDescriptor,
        .number = PB3AuctionSetReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLong",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_TimeLong,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, timeLong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_GiftId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "isCustom",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_IsCustom,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sellGiftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_SellGiftId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, sellGiftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sellGiftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_SellGiftNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, sellGiftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionSetReq_FieldNumber_Price,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AuctionSetReq__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionSetReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionSetReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuctionSetReq_Type_RawValue(PB3AuctionSetReq *message) {
  GPBDescriptor *descriptor = [PB3AuctionSetReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionSetReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuctionSetReq_Type_RawValue(PB3AuctionSetReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuctionSetReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionSetReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuctionSetRes

@implementation PB3AuctionSetRes


typedef struct PB3AuctionSetRes__storage_ {
  uint32_t _has_storage_[1];
} PB3AuctionSetRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionSetRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuctionSetRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionTarget

@implementation PB3AuctionTarget

@dynamic type;
@dynamic hasPlayer, player;
@dynamic content;
@dynamic timeLong;
@dynamic giftId;
@dynamic sellGiftId;
@dynamic sellGiftNum;
@dynamic price;
@dynamic auctionId;

typedef struct PB3AuctionTarget__storage_ {
  uint32_t _has_storage_[1];
  PB3AuctionType type;
  int32_t giftId;
  int32_t sellGiftId;
  int32_t sellGiftNum;
  int32_t price;
  PB3SimplePlayer *player;
  NSString *content;
  NSString *timeLong;
  NSString *auctionId;
} PB3AuctionTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AuctionType_EnumDescriptor,
        .number = PB3AuctionTarget_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3AuctionTarget_FieldNumber_Player,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLong",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_TimeLong,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, timeLong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_GiftId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sellGiftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_SellGiftId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, sellGiftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sellGiftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_SellGiftNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, sellGiftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_Price,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "auctionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionTarget_FieldNumber_AuctionId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AuctionTarget__storage_, auctionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionTarget class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuctionTarget_Type_RawValue(PB3AuctionTarget *message) {
  GPBDescriptor *descriptor = [PB3AuctionTarget descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionTarget_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuctionTarget_Type_RawValue(PB3AuctionTarget *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuctionTarget descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionTarget_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuctionRank

@implementation PB3AuctionRank

@dynamic hasPlayer, player;
@dynamic price;
@dynamic rank;

typedef struct PB3AuctionRank__storage_ {
  uint32_t _has_storage_[1];
  int32_t rank;
  PB3SimplePlayer *player;
  int64_t price;
} PB3AuctionRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3AuctionRank_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionRank__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionRank_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionRank__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionRank_FieldNumber_Rank,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuctionRank__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionEndReq

@implementation PB3AuctionEndReq

@dynamic auctionId;

typedef struct PB3AuctionEndReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *auctionId;
} PB3AuctionEndReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "auctionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionEndReq_FieldNumber_AuctionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionEndReq__storage_, auctionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionEndReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionEndReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionEndRes

@implementation PB3AuctionEndRes


typedef struct PB3AuctionEndRes__storage_ {
  uint32_t _has_storage_[1];
} PB3AuctionEndRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionEndRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuctionEndRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionBiddingReq

@implementation PB3AuctionBiddingReq

@dynamic price;
@dynamic type;
@dynamic auctionId;

typedef struct PB3AuctionBiddingReq__storage_ {
  uint32_t _has_storage_[1];
  PB3BiddingType type;
  NSString *auctionId;
  int64_t price;
} PB3AuctionBiddingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionBiddingReq_FieldNumber_Price,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionBiddingReq__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3BiddingType_EnumDescriptor,
        .number = PB3AuctionBiddingReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionBiddingReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "auctionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionBiddingReq_FieldNumber_AuctionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AuctionBiddingReq__storage_, auctionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionBiddingReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionBiddingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AuctionBiddingReq_Type_RawValue(PB3AuctionBiddingReq *message) {
  GPBDescriptor *descriptor = [PB3AuctionBiddingReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionBiddingReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AuctionBiddingReq_Type_RawValue(PB3AuctionBiddingReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AuctionBiddingReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AuctionBiddingReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuctionBiddingRes

@implementation PB3AuctionBiddingRes


typedef struct PB3AuctionBiddingRes__storage_ {
  uint32_t _has_storage_[1];
} PB3AuctionBiddingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionBiddingRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuctionBiddingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastAuctionState

@implementation PB3BroadcastAuctionState

@dynamic state;
@dynamic hasTarget, target;
@dynamic price;
@dynamic URL;

typedef struct PB3BroadcastAuctionState__storage_ {
  uint32_t _has_storage_[1];
  PB3AuctionState state;
  PB3AuctionTarget *target;
  NSString *URL;
  int64_t price;
} PB3BroadcastAuctionState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3AuctionState_EnumDescriptor,
        .number = PB3BroadcastAuctionState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionState__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionTarget),
        .number = PB3BroadcastAuctionState_FieldNumber_Target,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionState__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionState_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionState__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionState_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionState__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionState class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastAuctionState_State_RawValue(PB3BroadcastAuctionState *message) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionState_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastAuctionState_State_RawValue(PB3BroadcastAuctionState *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionState_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BroadcastAuctionRank

@implementation PB3BroadcastAuctionRank

@dynamic rankArray, rankArray_Count;
@dynamic timeStamp;

typedef struct PB3BroadcastAuctionRank__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rankArray;
  int64_t timeStamp;
} PB3BroadcastAuctionRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionRank),
        .number = PB3BroadcastAuctionRank_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionRank__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionRank_FieldNumber_TimeStamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionRank__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastAuctionResult

@implementation PB3BroadcastAuctionResult

@dynamic type;
@dynamic isSuccess;
@dynamic hasSellPlayer, sellPlayer;
@dynamic hasBuyPlayer, buyPlayer;
@dynamic content;
@dynamic timeLong;
@dynamic giftId;
@dynamic giftNum;
@dynamic price;
@dynamic errorMsg;
@dynamic URL;

typedef struct PB3BroadcastAuctionResult__storage_ {
  uint32_t _has_storage_[1];
  PB3AuctionType type;
  int32_t giftId;
  int32_t giftNum;
  PB3SimplePlayer *sellPlayer;
  PB3SimplePlayer *buyPlayer;
  NSString *content;
  NSString *timeLong;
  NSString *errorMsg;
  NSString *URL;
  int64_t price;
} PB3BroadcastAuctionResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3AuctionType_EnumDescriptor,
        .number = PB3BroadcastAuctionResult_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isSuccess",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_IsSuccess,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sellPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3BroadcastAuctionResult_FieldNumber_SellPlayer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, sellPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buyPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3BroadcastAuctionResult_FieldNumber_BuyPlayer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, buyPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_Content,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLong",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_TimeLong,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, timeLong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_GiftId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_GiftNum,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_Price,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "errorMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_ErrorMsg,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, errorMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionResult_FieldNumber_URL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionResult__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionResult class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\013!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastAuctionResult_Type_RawValue(PB3BroadcastAuctionResult *message) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionResult_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastAuctionResult_Type_RawValue(PB3BroadcastAuctionResult *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionResult_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BroadcastAuctionGiftUpdate

@implementation PB3BroadcastAuctionGiftUpdate


typedef struct PB3BroadcastAuctionGiftUpdate__storage_ {
  uint32_t _has_storage_[1];
} PB3BroadcastAuctionGiftUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionGiftUpdate class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3BroadcastAuctionGiftUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastAuctionBiddingPrice

@implementation PB3BroadcastAuctionBiddingPrice

@dynamic price;

typedef struct PB3BroadcastAuctionBiddingPrice__storage_ {
  uint32_t _has_storage_[1];
  int64_t price;
} PB3BroadcastAuctionBiddingPrice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionBiddingPrice_FieldNumber_Price,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingPrice__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionBiddingPrice class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionBiddingPrice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastAuctionGift

@implementation PB3BroadcastAuctionGift

@dynamic roomId;
@dynamic msg;

typedef struct PB3BroadcastAuctionGift__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
  int64_t roomId;
} PB3BroadcastAuctionGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionGift_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionGift__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionGift_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionGift__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionGift class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionGift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastAuctionBiddingSystem

@implementation PB3BroadcastAuctionBiddingSystem

@dynamic type;
@dynamic hasCurPlayer, curPlayer;
@dynamic hasOldPlayer, oldPlayer;
@dynamic msg;

typedef struct PB3BroadcastAuctionBiddingSystem__storage_ {
  uint32_t _has_storage_[1];
  PB3SurpassType type;
  PB3SimplePlayer *curPlayer;
  PB3SimplePlayer *oldPlayer;
  NSString *msg;
} PB3BroadcastAuctionBiddingSystem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3SurpassType_EnumDescriptor,
        .number = PB3BroadcastAuctionBiddingSystem_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingSystem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "curPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3BroadcastAuctionBiddingSystem_FieldNumber_CurPlayer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingSystem__storage_, curPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "oldPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3BroadcastAuctionBiddingSystem_FieldNumber_OldPlayer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingSystem__storage_, oldPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BroadcastAuctionBiddingSystem_FieldNumber_Msg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingSystem__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionBiddingSystem class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionBiddingSystem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastAuctionBiddingSystem_Type_RawValue(PB3BroadcastAuctionBiddingSystem *message) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionBiddingSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionBiddingSystem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastAuctionBiddingSystem_Type_RawValue(PB3BroadcastAuctionBiddingSystem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionBiddingSystem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionBiddingSystem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3BroadcastAuctionBiddingArtificial

@implementation PB3BroadcastAuctionBiddingArtificial

@dynamic type;
@dynamic hasPlayer, player;

typedef struct PB3BroadcastAuctionBiddingArtificial__storage_ {
  uint32_t _has_storage_[1];
  PB3TranscendType type;
  PB3SimplePlayer *player;
} PB3BroadcastAuctionBiddingArtificial__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TranscendType_EnumDescriptor,
        .number = PB3BroadcastAuctionBiddingArtificial_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingArtificial__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SimplePlayer),
        .number = PB3BroadcastAuctionBiddingArtificial_FieldNumber_Player,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BroadcastAuctionBiddingArtificial__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastAuctionBiddingArtificial class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastAuctionBiddingArtificial__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3BroadcastAuctionBiddingArtificial_Type_RawValue(PB3BroadcastAuctionBiddingArtificial *message) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionBiddingArtificial descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionBiddingArtificial_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3BroadcastAuctionBiddingArtificial_Type_RawValue(PB3BroadcastAuctionBiddingArtificial *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3BroadcastAuctionBiddingArtificial descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3BroadcastAuctionBiddingArtificial_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuctionDetail

@implementation PB3AuctionDetail

@dynamic giftId;
@dynamic giftNum;
@dynamic isBuy;
@dynamic price;
@dynamic createAt;
@dynamic auctionId;

typedef struct PB3AuctionDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t giftNum;
  NSString *auctionId;
  int64_t price;
  int64_t createAt;
} PB3AuctionDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionDetail__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_GiftNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionDetail__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "isBuy",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_IsBuy,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_Price,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AuctionDetail__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_CreateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AuctionDetail__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "auctionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionDetail_FieldNumber_AuctionId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AuctionDetail__storage_, auctionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionDetail class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionRecordReq

@implementation PB3AuctionRecordReq

@dynamic page;
@dynamic pageSize;

typedef struct PB3AuctionRecordReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
} PB3AuctionRecordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionRecordReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionRecordReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionRecordReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AuctionRecordReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionRecordReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionRecordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionRecordRes

@implementation PB3AuctionRecordRes

@dynamic auctionListArray, auctionListArray_Count;

typedef struct PB3AuctionRecordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *auctionListArray;
} PB3AuctionRecordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "auctionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionDetail),
        .number = PB3AuctionRecordRes_FieldNumber_AuctionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuctionRecordRes__storage_, auctionListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionRecordRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionRecordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InitAuctionReq

@implementation PB3InitAuctionReq


typedef struct PB3InitAuctionReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InitAuctionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InitAuctionReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InitAuctionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InitAuctionRes

@implementation PB3InitAuctionRes

@dynamic state;
@dynamic hasTarget, target;
@dynamic price;
@dynamic rankArray, rankArray_Count;

typedef struct PB3InitAuctionRes__storage_ {
  uint32_t _has_storage_[1];
  PB3AuctionState state;
  PB3AuctionTarget *target;
  NSMutableArray *rankArray;
  int64_t price;
} PB3InitAuctionRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3AuctionState_EnumDescriptor,
        .number = PB3InitAuctionRes_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InitAuctionRes__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionTarget),
        .number = PB3InitAuctionRes_FieldNumber_Target,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InitAuctionRes__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB3InitAuctionRes_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InitAuctionRes__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionRank),
        .number = PB3InitAuctionRes_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InitAuctionRes__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InitAuctionRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InitAuctionRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3InitAuctionRes_State_RawValue(PB3InitAuctionRes *message) {
  GPBDescriptor *descriptor = [PB3InitAuctionRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InitAuctionRes_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3InitAuctionRes_State_RawValue(PB3InitAuctionRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3InitAuctionRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3InitAuctionRes_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AuctionGiftConf

@implementation PB3AuctionGiftConf

@dynamic giftId;
@dynamic isSell;
@dynamic isAuction;
@dynamic minPrice;
@dynamic sort;

typedef struct PB3AuctionGiftConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  uint32_t minPrice;
  int32_t sort;
} PB3AuctionGiftConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionGiftConf_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AuctionGiftConf__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "isSell",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionGiftConf_FieldNumber_IsSell,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAuction",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionGiftConf_FieldNumber_IsAuction,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionGiftConf_FieldNumber_MinPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AuctionGiftConf__storage_, minPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB3AuctionGiftConf_FieldNumber_Sort,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AuctionGiftConf__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionGiftConf class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionGiftConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionGiftConfReq

@implementation PB3AuctionGiftConfReq


typedef struct PB3AuctionGiftConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AuctionGiftConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionGiftConfReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AuctionGiftConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AuctionGiftConfRes

@implementation PB3AuctionGiftConfRes

@dynamic auctionGiftConfListArray, auctionGiftConfListArray_Count;

typedef struct PB3AuctionGiftConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *auctionGiftConfListArray;
} PB3AuctionGiftConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "auctionGiftConfListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AuctionGiftConf),
        .number = PB3AuctionGiftConfRes_FieldNumber_AuctionGiftConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AuctionGiftConfRes__storage_, auctionGiftConfListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AuctionGiftConfRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AuctionGiftConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamListReq

@implementation PB3MobaTeamListReq


typedef struct PB3MobaTeamListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamListRes

@implementation PB3MobaTeamListRes

@dynamic teamListArray, teamListArray_Count;

typedef struct PB3MobaTeamListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *teamListArray;
} PB3MobaTeamListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "teamListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TeamBaseInfo),
        .number = PB3MobaTeamListRes_FieldNumber_TeamListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MobaTeamListRes__storage_, teamListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TeamBaseInfo

@implementation PB3TeamBaseInfo

@dynamic id_p;
@dynamic number;
@dynamic leaderId;
@dynamic leaderName;
@dynamic leaderIcon;
@dynamic memberCount;
@dynamic teamStatus;
@dynamic hasGameInfo, gameInfo;

typedef struct PB3TeamBaseInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t number;
  int32_t memberCount;
  PB3TermStatus teamStatus;
  NSString *id_p;
  NSString *leaderName;
  NSString *leaderIcon;
  PB3MobaTeamGameInfo *gameInfo;
  int64_t leaderId;
} PB3TeamBaseInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "leaderId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_LeaderId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, leaderId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leaderName",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_LeaderName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, leaderName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leaderIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_LeaderIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, leaderIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamBaseInfo_FieldNumber_MemberCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, memberCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "teamStatus",
        .dataTypeSpecific.enumDescFunc = PB3TermStatus_EnumDescriptor,
        .number = PB3TeamBaseInfo_FieldNumber_TeamStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, teamStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gameInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MobaTeamGameInfo),
        .number = PB3TeamBaseInfo_FieldNumber_GameInfo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3TeamBaseInfo__storage_, gameInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TeamBaseInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TeamBaseInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TeamBaseInfo_TeamStatus_RawValue(PB3TeamBaseInfo *message) {
  GPBDescriptor *descriptor = [PB3TeamBaseInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TeamBaseInfo_FieldNumber_TeamStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TeamBaseInfo_TeamStatus_RawValue(PB3TeamBaseInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TeamBaseInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TeamBaseInfo_FieldNumber_TeamStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamOptReq

@implementation PB3MobaTeamOptReq

@dynamic type;
@dynamic id_p;

typedef struct PB3MobaTeamOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TeamOptType type;
  NSString *id_p;
} PB3MobaTeamOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TeamOptType_EnumDescriptor,
        .number = PB3MobaTeamOptReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamOptReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamOptReq_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamOptReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamOptReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MobaTeamOptReq_Type_RawValue(PB3MobaTeamOptReq *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamOptReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamOptReq_Type_RawValue(PB3MobaTeamOptReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamOptReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamOptRes

@implementation PB3MobaTeamOptRes


typedef struct PB3MobaTeamOptRes__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamOptRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamMemberOptReq

@implementation PB3MobaTeamMemberOptReq

@dynamic type;
@dynamic id_p;
@dynamic targetId;

typedef struct PB3MobaTeamMemberOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB3MemberOptType type;
  NSString *id_p;
  int64_t targetId;
} PB3MobaTeamMemberOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3MemberOptType_EnumDescriptor,
        .number = PB3MobaTeamMemberOptReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamMemberOptReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamMemberOptReq_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamMemberOptReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamMemberOptReq_FieldNumber_TargetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MobaTeamMemberOptReq__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamMemberOptReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamMemberOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MobaTeamMemberOptReq_Type_RawValue(PB3MobaTeamMemberOptReq *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamMemberOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamMemberOptReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamMemberOptReq_Type_RawValue(PB3MobaTeamMemberOptReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamMemberOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamMemberOptReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamMemberOptRes

@implementation PB3MobaTeamMemberOptRes

@dynamic id_p;
@dynamic type;

typedef struct PB3MobaTeamMemberOptRes__storage_ {
  uint32_t _has_storage_[1];
  PB3TeamMemberType type;
  NSString *id_p;
} PB3MobaTeamMemberOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamMemberOptRes_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamMemberOptRes__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TeamMemberType_EnumDescriptor,
        .number = PB3MobaTeamMemberOptRes_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamMemberOptRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamMemberOptRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamMemberOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MobaTeamMemberOptRes_Type_RawValue(PB3MobaTeamMemberOptRes *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamMemberOptRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamMemberOptRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamMemberOptRes_Type_RawValue(PB3MobaTeamMemberOptRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamMemberOptRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamMemberOptRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TeamMemberInfo

@implementation PB3TeamMemberInfo

@dynamic id_p;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasTeamInfo, teamInfo;

typedef struct PB3TeamMemberInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSMutableArray *memberListArray;
  PB3TeamBaseInfo *teamInfo;
} PB3TeamMemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamMemberInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TeamMemberInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TeamMember),
        .number = PB3TeamMemberInfo_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TeamMemberInfo__storage_, memberListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "teamInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TeamBaseInfo),
        .number = PB3TeamMemberInfo_FieldNumber_TeamInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TeamMemberInfo__storage_, teamInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TeamMemberInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TeamMemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TeamMember

@implementation PB3TeamMember

@dynamic playerId;
@dynamic playerName;
@dynamic playerIcon;
@dynamic type;

typedef struct PB3TeamMember__storage_ {
  uint32_t _has_storage_[1];
  PB3TeamMemberType type;
  NSString *playerName;
  NSString *playerIcon;
  int64_t playerId;
} PB3TeamMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamMember_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TeamMember__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamMember_FieldNumber_PlayerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TeamMember__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3TeamMember_FieldNumber_PlayerIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TeamMember__storage_, playerIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TeamMemberType_EnumDescriptor,
        .number = PB3TeamMember_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TeamMember__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TeamMember class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TeamMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TeamMember_Type_RawValue(PB3TeamMember *message) {
  GPBDescriptor *descriptor = [PB3TeamMember descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TeamMember_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TeamMember_Type_RawValue(PB3TeamMember *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TeamMember descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TeamMember_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamDepartureBroadcast

@implementation PB3MobaTeamDepartureBroadcast

@dynamic lobbyId;
@dynamic teamLeaderId;
@dynamic teamId;
@dynamic password;

typedef struct PB3MobaTeamDepartureBroadcast__storage_ {
  uint32_t _has_storage_[1];
  NSString *teamId;
  NSString *password;
  int64_t lobbyId;
  int64_t teamLeaderId;
} PB3MobaTeamDepartureBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lobbyId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamDepartureBroadcast_FieldNumber_LobbyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamDepartureBroadcast__storage_, lobbyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "teamLeaderId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamDepartureBroadcast_FieldNumber_TeamLeaderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamDepartureBroadcast__storage_, teamLeaderId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "teamId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamDepartureBroadcast_FieldNumber_TeamId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MobaTeamDepartureBroadcast__storage_, teamId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamDepartureBroadcast_FieldNumber_Password,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MobaTeamDepartureBroadcast__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamDepartureBroadcast class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamDepartureBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamGameCfgCDNReq

@implementation PB3MobaTeamGameCfgCDNReq

@dynamic confURL;

typedef struct PB3MobaTeamGameCfgCDNReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *confURL;
} PB3MobaTeamGameCfgCDNReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamGameCfgCDNReq_FieldNumber_ConfURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamGameCfgCDNReq__storage_, confURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamGameCfgCDNReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamGameCfgCDNReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamGameCfgCDNRes

@implementation PB3MobaTeamGameCfgCDNRes

@dynamic confURL;

typedef struct PB3MobaTeamGameCfgCDNRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *confURL;
} PB3MobaTeamGameCfgCDNRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamGameCfgCDNRes_FieldNumber_ConfURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamGameCfgCDNRes__storage_, confURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamGameCfgCDNRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamGameCfgCDNRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamSaveReq

@implementation PB3MobaTeamSaveReq

@dynamic type;
@dynamic hasGameInfo, gameInfo;
@dynamic id_p;

typedef struct PB3MobaTeamSaveReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TeamSaveType type;
  PB3MobaTeamGameInfo *gameInfo;
  NSString *id_p;
} PB3MobaTeamSaveReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TeamSaveType_EnumDescriptor,
        .number = PB3MobaTeamSaveReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamSaveReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gameInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MobaTeamGameInfo),
        .number = PB3MobaTeamSaveReq_FieldNumber_GameInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamSaveReq__storage_, gameInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamSaveReq_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MobaTeamSaveReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamSaveReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamSaveReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MobaTeamSaveReq_Type_RawValue(PB3MobaTeamSaveReq *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamSaveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamSaveReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamSaveReq_Type_RawValue(PB3MobaTeamSaveReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamSaveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamSaveReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamSaveRes

@implementation PB3MobaTeamSaveRes


typedef struct PB3MobaTeamSaveRes__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamSaveRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamSaveRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamSaveRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamChange

@implementation PB3MobaTeamChange

@dynamic status;
@dynamic id_p;
@dynamic type;
@dynamic pushTime;
@dynamic hasTeam, team;

typedef struct PB3MobaTeamChange__storage_ {
  uint32_t _has_storage_[1];
  PB3MobaTeamStatus status;
  PB3TeamMemberType type;
  NSString *id_p;
  PB3TeamMemberInfo *team;
  int64_t pushTime;
} PB3MobaTeamChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3MobaTeamStatus_EnumDescriptor,
        .number = PB3MobaTeamChange_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamChange__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamChange_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamChange__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TeamMemberType_EnumDescriptor,
        .number = PB3MobaTeamChange_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MobaTeamChange__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pushTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamChange_FieldNumber_PushTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MobaTeamChange__storage_, pushTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "team",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TeamMemberInfo),
        .number = PB3MobaTeamChange_FieldNumber_Team,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3MobaTeamChange__storage_, team),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamChange class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MobaTeamChange_Status_RawValue(PB3MobaTeamChange *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamChange_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamChange_Status_RawValue(PB3MobaTeamChange *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamChange_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3MobaTeamChange_Type_RawValue(PB3MobaTeamChange *message) {
  GPBDescriptor *descriptor = [PB3MobaTeamChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamChange_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MobaTeamChange_Type_RawValue(PB3MobaTeamChange *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MobaTeamChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MobaTeamChange_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MobaTeamPatternBroadcast

@implementation PB3MobaTeamPatternBroadcast

@dynamic roomId;
@dynamic mobaTeamName;

typedef struct PB3MobaTeamPatternBroadcast__storage_ {
  uint32_t _has_storage_[1];
  NSString *mobaTeamName;
  int64_t roomId;
} PB3MobaTeamPatternBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamPatternBroadcast_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamPatternBroadcast__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mobaTeamName",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamPatternBroadcast_FieldNumber_MobaTeamName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamPatternBroadcast__storage_, mobaTeamName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamPatternBroadcast class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamPatternBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamUpdateRoomInfoReq

@implementation PB3MobaTeamUpdateRoomInfoReq

@dynamic hasGameInfo, gameInfo;

typedef struct PB3MobaTeamUpdateRoomInfoReq__storage_ {
  uint32_t _has_storage_[1];
  PB3MobaTeamGameInfo *gameInfo;
} PB3MobaTeamUpdateRoomInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MobaTeamGameInfo),
        .number = PB3MobaTeamUpdateRoomInfoReq_FieldNumber_GameInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamUpdateRoomInfoReq__storage_, gameInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamUpdateRoomInfoReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamUpdateRoomInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamUpdateRoomInfoRes

@implementation PB3MobaTeamUpdateRoomInfoRes


typedef struct PB3MobaTeamUpdateRoomInfoRes__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamUpdateRoomInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamUpdateRoomInfoRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamUpdateRoomInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamRoomInfoReq

@implementation PB3MobaTeamRoomInfoReq


typedef struct PB3MobaTeamRoomInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamRoomInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamRoomInfoReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamRoomInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamRoomInfoRes

@implementation PB3MobaTeamRoomInfoRes

@dynamic hasGameInfo, gameInfo;

typedef struct PB3MobaTeamRoomInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3MobaTeamGameInfo *gameInfo;
} PB3MobaTeamRoomInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MobaTeamGameInfo),
        .number = PB3MobaTeamRoomInfoRes_FieldNumber_GameInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamRoomInfoRes__storage_, gameInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamRoomInfoRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamRoomInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamPatternGuide

@implementation PB3MobaTeamPatternGuide

@dynamic roomId;

typedef struct PB3MobaTeamPatternGuide__storage_ {
  uint32_t _has_storage_[1];
  int64_t roomId;
} PB3MobaTeamPatternGuide__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamPatternGuide_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamPatternGuide__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamPatternGuide class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamPatternGuide__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamShowGameInfoBroadcast

@implementation PB3MobaTeamShowGameInfoBroadcast

@dynamic roomId;
@dynamic isShowMobaTeamInfo;

typedef struct PB3MobaTeamShowGameInfoBroadcast__storage_ {
  uint32_t _has_storage_[1];
  int64_t roomId;
} PB3MobaTeamShowGameInfoBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamShowGameInfoBroadcast_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamShowGameInfoBroadcast__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isShowMobaTeamInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamShowGameInfoBroadcast_FieldNumber_IsShowMobaTeamInfo,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamShowGameInfoBroadcast class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamShowGameInfoBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamBroadcastGameNickNameReq

@implementation PB3MobaTeamBroadcastGameNickNameReq

@dynamic nickName;
@dynamic gameId;

typedef struct PB3MobaTeamBroadcastGameNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickName;
  int64_t gameId;
} PB3MobaTeamBroadcastGameNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamBroadcastGameNickNameReq_FieldNumber_NickName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamBroadcastGameNickNameReq__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamBroadcastGameNickNameReq_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MobaTeamBroadcastGameNickNameReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamBroadcastGameNickNameReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamBroadcastGameNickNameReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamBroadcastGameNickNameRes

@implementation PB3MobaTeamBroadcastGameNickNameRes


typedef struct PB3MobaTeamBroadcastGameNickNameRes__storage_ {
  uint32_t _has_storage_[1];
} PB3MobaTeamBroadcastGameNickNameRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamBroadcastGameNickNameRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3MobaTeamBroadcastGameNickNameRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamGameNickNameReq

@implementation PB3MobaTeamGameNickNameReq

@dynamic gameId;

typedef struct PB3MobaTeamGameNickNameReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t gameId;
} PB3MobaTeamGameNickNameReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamGameNickNameReq_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MobaTeamGameNickNameReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamGameNickNameReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamGameNickNameReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MobaTeamGameNickNameRes

@implementation PB3MobaTeamGameNickNameRes

@dynamic nickNameArray, nickNameArray_Count;

typedef struct PB3MobaTeamGameNickNameRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nickNameArray;
} PB3MobaTeamGameNickNameRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickNameArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3MobaTeamGameNickNameRes_FieldNumber_NickNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MobaTeamGameNickNameRes__storage_, nickNameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MobaTeamGameNickNameRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MobaTeamGameNickNameRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInfo

@implementation PB3PkInfo

@dynamic id_p;
@dynamic pkReward;
@dynamic teamsArray, teamsArray_Count;
@dynamic endTime;
@dynamic timestamp;
@dynamic status;
@dynamic rewardRate;
@dynamic tipsArray, tipsArray_Count;
@dynamic scrollTime;
@dynamic mode;
@dynamic secKillId;
@dynamic cancelScore;
@dynamic isBeginPk;
@dynamic deviceType;
@dynamic openTime;
@dynamic pkStatus;
@dynamic punishContent;
@dynamic isEndPk;

typedef struct PB3PkInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t pkReward;
  PB3PkStatus status;
  int32_t rewardRate;
  int32_t scrollTime;
  PB3PkMode mode;
  int32_t cancelScore;
  PB3DeviceType deviceType;
  int32_t openTime;
  PB3PkStatus pkStatus;
  NSString *id_p;
  NSMutableArray *teamsArray;
  NSMutableArray *tipsArray;
  NSString *punishContent;
  int64_t endTime;
  int64_t timestamp;
  int64_t secKillId;
} PB3PkInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkReward",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_PkReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, pkReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "teamsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkTeam),
        .number = PB3PkInfo_FieldNumber_TeamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, teamsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3PkStatus_EnumDescriptor,
        .number = PB3PkInfo_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rewardRate",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_RewardRate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, rewardRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tipsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_TipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, tipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scrollTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_ScrollTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, scrollTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = PB3PkMode_EnumDescriptor,
        .number = PB3PkInfo_FieldNumber_Mode,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secKillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_SecKillId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, secKillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cancelScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_CancelScore,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, cancelScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isBeginPk",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_IsBeginPk,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3PkInfo_FieldNumber_DeviceType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "openTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_OpenTime,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, openTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pkStatus",
        .dataTypeSpecific.enumDescFunc = PB3PkStatus_EnumDescriptor,
        .number = PB3PkInfo_FieldNumber_PkStatus,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, pkStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "punishContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_PunishContent,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3PkInfo__storage_, punishContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isEndPk",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInfo_FieldNumber_IsEndPk,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkInfo_Status_RawValue(PB3PkInfo *message) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInfo_Status_RawValue(PB3PkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PkInfo_Mode_RawValue(PB3PkInfo *message) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInfo_Mode_RawValue(PB3PkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PkInfo_DeviceType_RawValue(PB3PkInfo *message) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInfo_DeviceType_RawValue(PB3PkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PkInfo_PkStatus_RawValue(PB3PkInfo *message) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_PkStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInfo_PkStatus_RawValue(PB3PkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInfo_FieldNumber_PkStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkTeam

@implementation PB3PkTeam

@dynamic roomId;
@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic income;
@dynamic playerListArray, playerListArray_Count;
@dynamic result;
@dynamic isPunishment;

typedef struct PB3PkTeam__storage_ {
  uint32_t _has_storage_[1];
  int32_t income;
  PB3PkResult result;
  NSString *hostName;
  NSString *hostIcon;
  NSMutableArray *playerListArray;
  int64_t roomId;
  int64_t hostId;
} PB3PkTeam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_HostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_HostName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_HostIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "income",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_Income,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, income),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkTeam_FieldNumber_PlayerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, playerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = PB3PkResult_EnumDescriptor,
        .number = PB3PkTeam_FieldNumber_Result,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PkTeam__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isPunishment",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeam_FieldNumber_IsPunishment,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkTeam class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkTeam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkTeam_Result_RawValue(PB3PkTeam *message) {
  GPBDescriptor *descriptor = [PB3PkTeam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkTeam_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkTeam_Result_RawValue(PB3PkTeam *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkTeam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkTeam_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkPlayer

@implementation PB3PkPlayer

@dynamic playerId;
@dynamic name;
@dynamic icon;
@dynamic score;
@dynamic rank;
@dynamic startMatchTime;
@dynamic roomId;

typedef struct PB3PkPlayer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t score;
  uint32_t rank;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t startMatchTime;
  int64_t roomId;
} PB3PkPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_Rank,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startMatchTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_StartMatchTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, startMatchTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPlayer_FieldNumber_RoomId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PkPlayer__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkPlayer class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkTeamPush

@implementation PB3PkTeamPush

@dynamic id_p;
@dynamic pkReward;
@dynamic hasTeam, team;
@dynamic timestamp;

typedef struct PB3PkTeamPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t pkReward;
  NSString *id_p;
  PB3PkTeam *team;
  int64_t timestamp;
} PB3PkTeamPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeamPush_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkTeamPush__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkReward",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeamPush_FieldNumber_PkReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkTeamPush__storage_, pkReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "team",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkTeam),
        .number = PB3PkTeamPush_FieldNumber_Team,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkTeamPush__storage_, team),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTeamPush_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkTeamPush__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkTeamPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkTeamPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkSkillPush

@implementation PB3PkSkillPush

@dynamic dataOneOfCase;
@dynamic id_p;
@dynamic skill;
@dynamic useRoomId;
@dynamic targetRoomId;
@dynamic secKill;
@dynamic taunt;

typedef struct PB3PkSkillPush__storage_ {
  uint32_t _has_storage_[2];
  PB3PkSkillType skill;
  NSString *id_p;
  PB3SeckillPush *secKill;
  PB3TauntPush *taunt;
  int64_t useRoomId;
  int64_t targetRoomId;
} PB3PkSkillPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkSkillPush_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3PkSkillType_EnumDescriptor,
        .number = PB3PkSkillPush_FieldNumber_Skill,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "useRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkSkillPush_FieldNumber_UseRoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, useRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkSkillPush_FieldNumber_TargetRoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, targetRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "secKill",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SeckillPush),
        .number = PB3PkSkillPush_FieldNumber_SecKill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, secKill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "taunt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TauntPush),
        .number = PB3PkSkillPush_FieldNumber_Taunt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3PkSkillPush__storage_, taunt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkSkillPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkSkillPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkSkillPush_Skill_RawValue(PB3PkSkillPush *message) {
  GPBDescriptor *descriptor = [PB3PkSkillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkSkillPush_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkSkillPush_Skill_RawValue(PB3PkSkillPush *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkSkillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkSkillPush_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3PkSkillPush_ClearDataOneOfCase(PB3PkSkillPush *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3SeckillPush

@implementation PB3SeckillPush

@dynamic status;
@dynamic endTime;
@dynamic cancelScore;
@dynamic cancelTime;

typedef struct PB3SeckillPush__storage_ {
  uint32_t _has_storage_[1];
  PB3SeckillStatus status;
  int32_t cancelScore;
  int32_t cancelTime;
  int64_t endTime;
} PB3SeckillPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3SeckillStatus_EnumDescriptor,
        .number = PB3SeckillPush_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SeckillPush__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SeckillPush_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SeckillPush__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cancelScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3SeckillPush_FieldNumber_CancelScore,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SeckillPush__storage_, cancelScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cancelTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SeckillPush_FieldNumber_CancelTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SeckillPush__storage_, cancelTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SeckillPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SeckillPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SeckillPush_Status_RawValue(PB3SeckillPush *message) {
  GPBDescriptor *descriptor = [PB3SeckillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SeckillPush_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SeckillPush_Status_RawValue(PB3SeckillPush *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SeckillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SeckillPush_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TauntPush

@implementation PB3TauntPush

@dynamic gold;

typedef struct PB3TauntPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
} PB3TauntPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3TauntPush_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TauntPush__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TauntPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TauntPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UsePkSkillReq

@implementation PB3UsePkSkillReq

@dynamic id_p;
@dynamic skill;
@dynamic gold;

typedef struct PB3UsePkSkillReq__storage_ {
  uint32_t _has_storage_[1];
  PB3PkSkillType skill;
  int32_t gold;
  NSString *id_p;
} PB3UsePkSkillReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UsePkSkillReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UsePkSkillReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3PkSkillType_EnumDescriptor,
        .number = PB3UsePkSkillReq_FieldNumber_Skill,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UsePkSkillReq__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3UsePkSkillReq_FieldNumber_Gold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UsePkSkillReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UsePkSkillReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UsePkSkillReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UsePkSkillReq_Skill_RawValue(PB3UsePkSkillReq *message) {
  GPBDescriptor *descriptor = [PB3UsePkSkillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UsePkSkillReq_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UsePkSkillReq_Skill_RawValue(PB3UsePkSkillReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UsePkSkillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UsePkSkillReq_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UsePkSkillRes

@implementation PB3UsePkSkillRes


typedef struct PB3UsePkSkillRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UsePkSkillRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UsePkSkillRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UsePkSkillRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkSkillListReq

@implementation PB3PkSkillListReq


typedef struct PB3PkSkillListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PkSkillListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkSkillListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkSkillListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkSkillListRes

@implementation PB3PkSkillListRes

@dynamic skillsArray, skillsArray_Count;

typedef struct PB3PkSkillListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *skillsArray;
} PB3PkSkillListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkSkill),
        .number = PB3PkSkillListRes_FieldNumber_SkillsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkSkillListRes__storage_, skillsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkSkillListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkSkillListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkSkill

@implementation PB3PkSkill

@dynamic dataOneOfCase;
@dynamic skill;
@dynamic icon;
@dynamic secKill;
@dynamic taunt;

typedef struct PB3PkSkill__storage_ {
  uint32_t _has_storage_[2];
  PB3PkSkillType skill;
  NSString *icon;
  PB3Seckill *secKill;
  PB3Taunt *taunt;
} PB3PkSkill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3PkSkillType_EnumDescriptor,
        .number = PB3PkSkill_FieldNumber_Skill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkSkill__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkSkill_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkSkill__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secKill",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Seckill),
        .number = PB3PkSkill_FieldNumber_SecKill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3PkSkill__storage_, secKill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "taunt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Taunt),
        .number = PB3PkSkill_FieldNumber_Taunt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3PkSkill__storage_, taunt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkSkill class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkSkill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkSkill_Skill_RawValue(PB3PkSkill *message) {
  GPBDescriptor *descriptor = [PB3PkSkill descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkSkill_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkSkill_Skill_RawValue(PB3PkSkill *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkSkill descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkSkill_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3PkSkill_ClearDataOneOfCase(PB3PkSkill *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3Seckill

@implementation PB3Seckill

@dynamic score;
@dynamic startTime;
@dynamic endTime;
@dynamic isUsed;

typedef struct PB3Seckill__storage_ {
  uint32_t _has_storage_[1];
  int32_t score;
  int64_t startTime;
  int64_t endTime;
} PB3Seckill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3Seckill_FieldNumber_Score,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Seckill__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Seckill_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Seckill__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3Seckill_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Seckill__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isUsed",
        .dataTypeSpecific.className = NULL,
        .number = PB3Seckill_FieldNumber_IsUsed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Seckill class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Seckill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3Taunt

@implementation PB3Taunt

@dynamic gold;
@dynamic goldSuperposition;

typedef struct PB3Taunt__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
} PB3Taunt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3Taunt_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Taunt__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldSuperposition",
        .dataTypeSpecific.className = NULL,
        .number = PB3Taunt_FieldNumber_GoldSuperposition,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Taunt class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Taunt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkTreasureBox

@implementation PB3PkTreasureBox

@dynamic id_p;
@dynamic name;
@dynamic roomId;
@dynamic endTime;

typedef struct PB3PkTreasureBox__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  int64_t roomId;
  int64_t endTime;
} PB3PkTreasureBox__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTreasureBox_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkTreasureBox__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTreasureBox_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkTreasureBox__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTreasureBox_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkTreasureBox__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTreasureBox_FieldNumber_EndTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkTreasureBox__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkTreasureBox class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkTreasureBox__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3OpenPkTreasureBoxReq

@implementation PB3OpenPkTreasureBoxReq

@dynamic id_p;
@dynamic roomId;

typedef struct PB3OpenPkTreasureBoxReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  int64_t roomId;
} PB3OpenPkTreasureBoxReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenPkTreasureBoxReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenPkTreasureBoxReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3OpenPkTreasureBoxReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3OpenPkTreasureBoxReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3OpenPkTreasureBoxRes

@implementation PB3OpenPkTreasureBoxRes

@dynamic status;
@dynamic icon;
@dynamic content;
@dynamic validTime;

typedef struct PB3OpenPkTreasureBoxRes__storage_ {
  uint32_t _has_storage_[1];
  PB3TreasureBoxStatus status;
  NSString *icon;
  NSString *content;
  int64_t validTime;
} PB3OpenPkTreasureBoxRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3TreasureBoxStatus_EnumDescriptor,
        .number = PB3OpenPkTreasureBoxRes_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxRes__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenPkTreasureBoxRes_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenPkTreasureBoxRes_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxRes__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3OpenPkTreasureBoxRes_FieldNumber_ValidTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3OpenPkTreasureBoxRes__storage_, validTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3OpenPkTreasureBoxRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3OpenPkTreasureBoxRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3OpenPkTreasureBoxRes_Status_RawValue(PB3OpenPkTreasureBoxRes *message) {
  GPBDescriptor *descriptor = [PB3OpenPkTreasureBoxRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3OpenPkTreasureBoxRes_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3OpenPkTreasureBoxRes_Status_RawValue(PB3OpenPkTreasureBoxRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3OpenPkTreasureBoxRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3OpenPkTreasureBoxRes_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3InPkRankListReq

@implementation PB3InPkRankListReq


typedef struct PB3InPkRankListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3InPkRankListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InPkRankListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InPkRankListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InPkRankListRes

@implementation PB3InPkRankListRes

@dynamic listArray, listArray_Count;

typedef struct PB3InPkRankListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3InPkRankListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InPkRank),
        .number = PB3InPkRankListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InPkRankListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InPkRankListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InPkRankListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InPkRank

@implementation PB3InPkRank

@dynamic teamsArray, teamsArray_Count;

typedef struct PB3InPkRank__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *teamsArray;
} PB3InPkRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "teamsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3InPkTeam),
        .number = PB3InPkRank_FieldNumber_TeamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3InPkRank__storage_, teamsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InPkRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InPkRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InPkTeam

@implementation PB3InPkTeam

@dynamic roomId;
@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic income;
@dynamic winOrLose;

typedef struct PB3InPkTeam__storage_ {
  uint32_t _has_storage_[1];
  int32_t income;
  int32_t winOrLose;
  NSString *hostName;
  NSString *hostIcon;
  int64_t roomId;
  int64_t hostId;
} PB3InPkTeam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_HostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_HostName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_HostIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "income",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_Income,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, income),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "winOrLose",
        .dataTypeSpecific.className = NULL,
        .number = PB3InPkTeam_FieldNumber_WinOrLose,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3InPkTeam__storage_, winOrLose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InPkTeam class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InPkTeam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekPkRankListReq

@implementation PB3WeekPkRankListReq

@dynamic page;
@dynamic pageSize;
@dynamic type;

typedef struct PB3WeekPkRankListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  PB3WeekPkRankType type;
} PB3WeekPkRankListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRankListReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekPkRankListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRankListReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekPkRankListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekPkRankType_EnumDescriptor,
        .number = PB3WeekPkRankListReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekPkRankListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekPkRankListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekPkRankListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekPkRankListReq_Type_RawValue(PB3WeekPkRankListReq *message) {
  GPBDescriptor *descriptor = [PB3WeekPkRankListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekPkRankListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekPkRankListReq_Type_RawValue(PB3WeekPkRankListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekPkRankListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekPkRankListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekPkRankListRes

@implementation PB3WeekPkRankListRes

@dynamic listArray, listArray_Count;

typedef struct PB3WeekPkRankListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3WeekPkRankListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekPkRank),
        .number = PB3WeekPkRankListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeekPkRankListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekPkRankListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekPkRankListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekPkRank

@implementation PB3WeekPkRank

@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic score;
@dynamic mvpId;
@dynamic mvpName;
@dynamic mvpIcon;
@dynamic winOrLose;

typedef struct PB3WeekPkRank__storage_ {
  uint32_t _has_storage_[1];
  int32_t score;
  int32_t winOrLose;
  NSString *hostName;
  NSString *hostIcon;
  NSString *mvpName;
  NSString *mvpIcon;
  int64_t hostId;
  int64_t mvpId;
} PB3WeekPkRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_HostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_HostName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_HostIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mvpId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_MvpId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, mvpId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mvpName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_MvpName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, mvpName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mvpIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_MvpIcon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, mvpIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "winOrLose",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekPkRank_FieldNumber_WinOrLose,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3WeekPkRank__storage_, winOrLose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekPkRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekPkRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkRecInviteListReq

@implementation PB3PkRecInviteListReq

@dynamic isFromMatch;

typedef struct PB3PkRecInviteListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PkRecInviteListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isFromMatch",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkRecInviteListReq_FieldNumber_IsFromMatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkRecInviteListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkRecInviteListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkRecInviteListRes

@implementation PB3PkRecInviteListRes

@dynamic playersArray, playersArray_Count;

typedef struct PB3PkRecInviteListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *playersArray;
} PB3PkRecInviteListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkRecInviteListRes_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkRecInviteListRes__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkRecInviteListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkRecInviteListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteReq

@implementation PB3PkInviteReq

@dynamic invitedPlayerId;
@dynamic invitedRoomId;

typedef struct PB3PkInviteReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t invitedPlayerId;
  int64_t invitedRoomId;
} PB3PkInviteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteReq_FieldNumber_InvitedPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteReq__storage_, invitedPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "invitedRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteReq_FieldNumber_InvitedRoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkInviteReq__storage_, invitedRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteRes

@implementation PB3PkInviteRes

@dynamic inviteId;
@dynamic playersArray, playersArray_Count;
@dynamic tip;
@dynamic endTime;

typedef struct PB3PkInviteRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
  NSMutableArray *playersArray;
  NSString *tip;
  int64_t endTime;
} PB3PkInviteRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteRes_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteRes__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkInviteRes_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkInviteRes__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tip",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteRes_FieldNumber_Tip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkInviteRes__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteRes_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkInviteRes__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteInfo

@implementation PB3PkInviteInfo

@dynamic inviteId;
@dynamic hasPlayer, player;
@dynamic endTime;
@dynamic operatorId;
@dynamic pkInviteAction;

typedef struct PB3PkInviteInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3PkInviteAction pkInviteAction;
  NSString *inviteId;
  PB3PkPlayer *player;
  int64_t endTime;
  int64_t operatorId;
} PB3PkInviteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteInfo_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteInfo__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkInviteInfo_FieldNumber_Player,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkInviteInfo__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteInfo_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkInviteInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "operatorId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteInfo_FieldNumber_OperatorId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkInviteInfo__storage_, operatorId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pkInviteAction",
        .dataTypeSpecific.enumDescFunc = PB3PkInviteAction_EnumDescriptor,
        .number = PB3PkInviteInfo_FieldNumber_PkInviteAction,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PkInviteInfo__storage_, pkInviteAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkInviteInfo_PkInviteAction_RawValue(PB3PkInviteInfo *message) {
  GPBDescriptor *descriptor = [PB3PkInviteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInviteInfo_FieldNumber_PkInviteAction];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInviteInfo_PkInviteAction_RawValue(PB3PkInviteInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInviteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInviteInfo_FieldNumber_PkInviteAction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkInviteCancelReq

@implementation PB3PkInviteCancelReq

@dynamic inviteId;

typedef struct PB3PkInviteCancelReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
} PB3PkInviteCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteCancelReq_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteCancelReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteCancelReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteCancelRes

@implementation PB3PkInviteCancelRes


typedef struct PB3PkInviteCancelRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkInviteCancelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteCancelRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkInviteCancelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteRejectReq

@implementation PB3PkInviteRejectReq

@dynamic rejectType;
@dynamic inviteId;

typedef struct PB3PkInviteRejectReq__storage_ {
  uint32_t _has_storage_[1];
  PB3PkInviteRejectType rejectType;
  NSString *inviteId;
} PB3PkInviteRejectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rejectType",
        .dataTypeSpecific.enumDescFunc = PB3PkInviteRejectType_EnumDescriptor,
        .number = PB3PkInviteRejectReq_FieldNumber_RejectType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteRejectReq__storage_, rejectType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteRejectReq_FieldNumber_InviteId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkInviteRejectReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteRejectReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteRejectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkInviteRejectReq_RejectType_RawValue(PB3PkInviteRejectReq *message) {
  GPBDescriptor *descriptor = [PB3PkInviteRejectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInviteRejectReq_FieldNumber_RejectType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkInviteRejectReq_RejectType_RawValue(PB3PkInviteRejectReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkInviteRejectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkInviteRejectReq_FieldNumber_RejectType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkInviteRejectRes

@implementation PB3PkInviteRejectRes


typedef struct PB3PkInviteRejectRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkInviteRejectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteRejectRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkInviteRejectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteAcceptReq

@implementation PB3PkInviteAcceptReq

@dynamic inviteId;

typedef struct PB3PkInviteAcceptReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
} PB3PkInviteAcceptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkInviteAcceptReq_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkInviteAcceptReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteAcceptReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkInviteAcceptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkInviteAcceptRes

@implementation PB3PkInviteAcceptRes


typedef struct PB3PkInviteAcceptRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkInviteAcceptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkInviteAcceptRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkInviteAcceptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchReq

@implementation PB3PkMatchReq


typedef struct PB3PkMatchReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchRes

@implementation PB3PkMatchRes

@dynamic hasPlayer, player;
@dynamic timeoutAt;
@dynamic tip;

typedef struct PB3PkMatchRes__storage_ {
  uint32_t _has_storage_[1];
  PB3PkPlayer *player;
  NSString *tip;
  int64_t timeoutAt;
} PB3PkMatchRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkMatchRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkMatchRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeoutAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchRes_FieldNumber_TimeoutAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkMatchRes__storage_, timeoutAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tip",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchRes_FieldNumber_Tip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkMatchRes__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkMatchRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchCancelReq

@implementation PB3PkMatchCancelReq


typedef struct PB3PkMatchCancelReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchCancelReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchCancelRes

@implementation PB3PkMatchCancelRes


typedef struct PB3PkMatchCancelRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchCancelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchCancelRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchCancelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchInfo

@implementation PB3PkMatchInfo

@dynamic matchId;
@dynamic playersArray, playersArray_Count;
@dynamic endTime;
@dynamic msg;
@dynamic pkMatchAction;

typedef struct PB3PkMatchInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3PkMatchAction pkMatchAction;
  NSString *matchId;
  NSMutableArray *playersArray;
  NSString *msg;
  int64_t endTime;
} PB3PkMatchInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchInfo_FieldNumber_MatchId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkMatchInfo__storage_, matchId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PkPlayer),
        .number = PB3PkMatchInfo_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PkMatchInfo__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchInfo_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkMatchInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchInfo_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkMatchInfo__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkMatchAction",
        .dataTypeSpecific.enumDescFunc = PB3PkMatchAction_EnumDescriptor,
        .number = PB3PkMatchInfo_FieldNumber_PkMatchAction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkMatchInfo__storage_, pkMatchAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkMatchInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkMatchInfo_PkMatchAction_RawValue(PB3PkMatchInfo *message) {
  GPBDescriptor *descriptor = [PB3PkMatchInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkMatchInfo_FieldNumber_PkMatchAction];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkMatchInfo_PkMatchAction_RawValue(PB3PkMatchInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkMatchInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkMatchInfo_FieldNumber_PkMatchAction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkMatchStartReq

@implementation PB3PkMatchStartReq

@dynamic matchId;

typedef struct PB3PkMatchStartReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *matchId;
} PB3PkMatchStartReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMatchStartReq_FieldNumber_MatchId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkMatchStartReq__storage_, matchId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchStartReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkMatchStartReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchStartRes

@implementation PB3PkMatchStartRes


typedef struct PB3PkMatchStartRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchStartRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchStartRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchStartRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchKeepWaitReq

@implementation PB3PkMatchKeepWaitReq


typedef struct PB3PkMatchKeepWaitReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchKeepWaitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchKeepWaitReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchKeepWaitReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMatchKeepWaitRes

@implementation PB3PkMatchKeepWaitRes


typedef struct PB3PkMatchKeepWaitRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkMatchKeepWaitRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMatchKeepWaitRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkMatchKeepWaitRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkProtectPush

@implementation PB3PkProtectPush

@dynamic endTime;

typedef struct PB3PkProtectPush__storage_ {
  uint32_t _has_storage_[1];
  int64_t endTime;
} PB3PkProtectPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkProtectPush_FieldNumber_EndTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkProtectPush__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkProtectPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkProtectPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkMvpGlobalPush

@implementation PB3PkMvpGlobalPush

@dynamic mvpId;
@dynamic mvpName;
@dynamic roomId;

typedef struct PB3PkMvpGlobalPush__storage_ {
  uint32_t _has_storage_[1];
  NSString *mvpName;
  int64_t mvpId;
  int64_t roomId;
} PB3PkMvpGlobalPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mvpId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMvpGlobalPush_FieldNumber_MvpId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkMvpGlobalPush__storage_, mvpId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mvpName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMvpGlobalPush_FieldNumber_MvpName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkMvpGlobalPush__storage_, mvpName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkMvpGlobalPush_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkMvpGlobalPush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkMvpGlobalPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkMvpGlobalPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkRewardTicketPush

@implementation PB3PkRewardTicketPush

@dynamic ticket;
@dynamic roomId;

typedef struct PB3PkRewardTicketPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t ticket;
  int64_t roomId;
} PB3PkRewardTicketPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkRewardTicketPush_FieldNumber_Ticket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkRewardTicketPush__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkRewardTicketPush_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkRewardTicketPush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkRewardTicketPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkRewardTicketPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkTauntRoomNoticePush

@implementation PB3PkTauntRoomNoticePush

@dynamic useTauntPlayerId;
@dynamic useTauntPlayerName;
@dynamic roomId;
@dynamic tauntRoomId;
@dynamic tauntRoomName;

typedef struct PB3PkTauntRoomNoticePush__storage_ {
  uint32_t _has_storage_[1];
  NSString *useTauntPlayerName;
  NSString *tauntRoomName;
  int64_t useTauntPlayerId;
  int64_t roomId;
  int64_t tauntRoomId;
} PB3PkTauntRoomNoticePush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "useTauntPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTauntRoomNoticePush_FieldNumber_UseTauntPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkTauntRoomNoticePush__storage_, useTauntPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "useTauntPlayerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTauntRoomNoticePush_FieldNumber_UseTauntPlayerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkTauntRoomNoticePush__storage_, useTauntPlayerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTauntRoomNoticePush_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkTauntRoomNoticePush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tauntRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTauntRoomNoticePush_FieldNumber_TauntRoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PkTauntRoomNoticePush__storage_, tauntRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tauntRoomName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkTauntRoomNoticePush_FieldNumber_TauntRoomName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PkTauntRoomNoticePush__storage_, tauntRoomName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkTauntRoomNoticePush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkTauntRoomNoticePush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkHostInfo

@implementation PB3PkHostInfo

@dynamic roomId;
@dynamic hostId;
@dynamic voice;
@dynamic isWinner;
@dynamic ownHostId;
@dynamic mute;
@dynamic opponentMute;

typedef struct PB3PkHostInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3RoomVoice voice;
  PB3MuteType mute;
  PB3MuteType opponentMute;
  int64_t roomId;
  int64_t hostId;
  int64_t ownHostId;
} PB3PkHostInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkHostInfo_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkHostInfo_FieldNumber_HostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "voice",
        .dataTypeSpecific.enumDescFunc = PB3RoomVoice_EnumDescriptor,
        .number = PB3PkHostInfo_FieldNumber_Voice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, voice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isWinner",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkHostInfo_FieldNumber_IsWinner,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ownHostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkHostInfo_FieldNumber_OwnHostId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, ownHostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3MuteType_EnumDescriptor,
        .number = PB3PkHostInfo_FieldNumber_Mute,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "opponentMute",
        .dataTypeSpecific.enumDescFunc = PB3MuteType_EnumDescriptor,
        .number = PB3PkHostInfo_FieldNumber_OpponentMute,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PkHostInfo__storage_, opponentMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkHostInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkHostInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkHostInfo_Voice_RawValue(PB3PkHostInfo *message) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_Voice];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkHostInfo_Voice_RawValue(PB3PkHostInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_Voice];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PkHostInfo_Mute_RawValue(PB3PkHostInfo *message) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkHostInfo_Mute_RawValue(PB3PkHostInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PkHostInfo_OpponentMute_RawValue(PB3PkHostInfo *message) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_OpponentMute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkHostInfo_OpponentMute_RawValue(PB3PkHostInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkHostInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkHostInfo_FieldNumber_OpponentMute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkVoiceMuteReq

@implementation PB3PkVoiceMuteReq

@dynamic mute;
@dynamic pkId;

typedef struct PB3PkVoiceMuteReq__storage_ {
  uint32_t _has_storage_[1];
  PB3MuteType mute;
  NSString *pkId;
} PB3PkVoiceMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3MuteType_EnumDescriptor,
        .number = PB3PkVoiceMuteReq_FieldNumber_Mute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkVoiceMuteReq__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pkId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkVoiceMuteReq_FieldNumber_PkId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkVoiceMuteReq__storage_, pkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkVoiceMuteReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkVoiceMuteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkVoiceMuteReq_Mute_RawValue(PB3PkVoiceMuteReq *message) {
  GPBDescriptor *descriptor = [PB3PkVoiceMuteReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkVoiceMuteReq_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkVoiceMuteReq_Mute_RawValue(PB3PkVoiceMuteReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkVoiceMuteReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkVoiceMuteReq_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkVoiceMuteRes

@implementation PB3PkVoiceMuteRes


typedef struct PB3PkVoiceMuteRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkVoiceMuteRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkVoiceMuteRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkVoiceMuteRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkPushMuteType

@implementation PB3PkPushMuteType

@dynamic mute;
@dynamic roomId;

typedef struct PB3PkPushMuteType__storage_ {
  uint32_t _has_storage_[1];
  PB3MuteType mute;
  int64_t roomId;
} PB3PkPushMuteType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3MuteType_EnumDescriptor,
        .number = PB3PkPushMuteType_FieldNumber_Mute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkPushMuteType__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkPushMuteType_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PkPushMuteType__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkPushMuteType class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkPushMuteType__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PkPushMuteType_Mute_RawValue(PB3PkPushMuteType *message) {
  GPBDescriptor *descriptor = [PB3PkPushMuteType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkPushMuteType_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PkPushMuteType_Mute_RawValue(PB3PkPushMuteType *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PkPushMuteType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PkPushMuteType_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PkStartPunishReq

@implementation PB3PkStartPunishReq

@dynamic pkId;

typedef struct PB3PkStartPunishReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *pkId;
} PB3PkStartPunishReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pkId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PkStartPunishReq_FieldNumber_PkId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PkStartPunishReq__storage_, pkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkStartPunishReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PkStartPunishReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PkStartPunishRes

@implementation PB3PkStartPunishRes


typedef struct PB3PkStartPunishRes__storage_ {
  uint32_t _has_storage_[1];
} PB3PkStartPunishRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PkStartPunishRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PkStartPunishRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInfo

@implementation PB3SingleLivePkInfo

@dynamic id_p;
@dynamic pkReward;
@dynamic teamsArray, teamsArray_Count;
@dynamic endTime;
@dynamic timestamp;
@dynamic rewardRate;
@dynamic tipsArray, tipsArray_Count;
@dynamic scrollTime;
@dynamic mode;
@dynamic secKillId;
@dynamic cancelScore;
@dynamic isBeginPk;
@dynamic deviceType;
@dynamic openTime;
@dynamic pkStatus;
@dynamic punishContent;
@dynamic isEndPk;
@dynamic roomInfoArray, roomInfoArray_Count;
@dynamic voice;
@dynamic routerURL;

typedef struct PB3SingleLivePkInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t pkReward;
  int32_t rewardRate;
  int32_t scrollTime;
  PB3SingleLivePkMode mode;
  int32_t cancelScore;
  PB3DeviceType deviceType;
  int32_t openTime;
  PB3SingleLivePkStatus pkStatus;
  PB3RoomVoice voice;
  NSString *id_p;
  NSMutableArray *teamsArray;
  NSMutableArray *tipsArray;
  NSString *punishContent;
  NSMutableArray *roomInfoArray;
  NSString *routerURL;
  int64_t endTime;
  int64_t timestamp;
  int64_t secKillId;
} PB3SingleLivePkInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkReward",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_PkReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, pkReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "teamsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkTeam),
        .number = PB3SingleLivePkInfo_FieldNumber_TeamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, teamsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardRate",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_RewardRate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, rewardRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tipsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_TipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, tipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scrollTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_ScrollTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, scrollTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkMode_EnumDescriptor,
        .number = PB3SingleLivePkInfo_FieldNumber_Mode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secKillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_SecKillId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, secKillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cancelScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_CancelScore,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, cancelScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isBeginPk",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_IsBeginPk,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3SingleLivePkInfo_FieldNumber_DeviceType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "openTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_OpenTime,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, openTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pkStatus",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkStatus_EnumDescriptor,
        .number = PB3SingleLivePkInfo_FieldNumber_PkStatus,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, pkStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "punishContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_PunishContent,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, punishContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isEndPk",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_IsEndPk,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "roomInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkRoomInfo),
        .number = PB3SingleLivePkInfo_FieldNumber_RoomInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, roomInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.enumDescFunc = PB3RoomVoice_EnumDescriptor,
        .number = PB3SingleLivePkInfo_FieldNumber_Voice,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, voice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInfo_FieldNumber_RouterURL,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInfo__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\024\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkInfo_Mode_RawValue(PB3SingleLivePkInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInfo_Mode_RawValue(PB3SingleLivePkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3SingleLivePkInfo_DeviceType_RawValue(PB3SingleLivePkInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInfo_DeviceType_RawValue(PB3SingleLivePkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3SingleLivePkInfo_PkStatus_RawValue(PB3SingleLivePkInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_PkStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInfo_PkStatus_RawValue(PB3SingleLivePkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_PkStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3SingleLivePkInfo_Voice_RawValue(PB3SingleLivePkInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_Voice];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInfo_Voice_RawValue(PB3SingleLivePkInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInfo_FieldNumber_Voice];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkRoomInfo

@implementation PB3SingleLivePkRoomInfo

@dynamic roomId;
@dynamic chairPlayerArray, chairPlayerArray_Count;
@dynamic mute;
@dynamic opponentMute;

typedef struct PB3SingleLivePkRoomInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLiveMuteType mute;
  PB3SingleLiveMuteType opponentMute;
  NSMutableArray *chairPlayerArray;
  int64_t roomId;
} PB3SingleLivePkRoomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkRoomInfo_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRoomInfo__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chairPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveChairPlayer),
        .number = PB3SingleLivePkRoomInfo_FieldNumber_ChairPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRoomInfo__storage_, chairPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveMuteType_EnumDescriptor,
        .number = PB3SingleLivePkRoomInfo_FieldNumber_Mute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRoomInfo__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "opponentMute",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveMuteType_EnumDescriptor,
        .number = PB3SingleLivePkRoomInfo_FieldNumber_OpponentMute,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRoomInfo__storage_, opponentMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkRoomInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkRoomInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkRoomInfo_Mute_RawValue(PB3SingleLivePkRoomInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkRoomInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkRoomInfo_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkRoomInfo_Mute_RawValue(PB3SingleLivePkRoomInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkRoomInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkRoomInfo_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3SingleLivePkRoomInfo_OpponentMute_RawValue(PB3SingleLivePkRoomInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkRoomInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkRoomInfo_FieldNumber_OpponentMute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkRoomInfo_OpponentMute_RawValue(PB3SingleLivePkRoomInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkRoomInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkRoomInfo_FieldNumber_OpponentMute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkTeam

@implementation PB3SingleLivePkTeam

@dynamic roomId;
@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic income;
@dynamic playerListArray, playerListArray_Count;
@dynamic result;
@dynamic isPunishment;

typedef struct PB3SingleLivePkTeam__storage_ {
  uint32_t _has_storage_[1];
  int32_t income;
  PB3SingleLivePkResult result;
  NSString *hostName;
  NSString *hostIcon;
  NSMutableArray *playerListArray;
  int64_t roomId;
  int64_t hostId;
} PB3SingleLivePkTeam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_HostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_HostName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_HostIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "income",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_Income,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, income),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkTeam_FieldNumber_PlayerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, playerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkResult_EnumDescriptor,
        .number = PB3SingleLivePkTeam_FieldNumber_Result,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeam__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isPunishment",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeam_FieldNumber_IsPunishment,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkTeam class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkTeam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkTeam_Result_RawValue(PB3SingleLivePkTeam *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkTeam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkTeam_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkTeam_Result_RawValue(PB3SingleLivePkTeam *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkTeam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkTeam_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLiveChairPlayer

@implementation PB3SingleLiveChairPlayer

@dynamic playerId;
@dynamic name;
@dynamic icon;
@dynamic chairId;
@dynamic effectId;
@dynamic sex;

typedef struct PB3SingleLiveChairPlayer__storage_ {
  uint32_t _has_storage_[1];
  int32_t chairId;
  int32_t effectId;
  PB3SexType sex;
  NSString *name;
  NSString *icon;
  int64_t playerId;
} PB3SingleLiveChairPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveChairPlayer_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveChairPlayer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveChairPlayer_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chairId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveChairPlayer_FieldNumber_ChairId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, chairId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveChairPlayer_FieldNumber_EffectId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, effectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3SingleLiveChairPlayer_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLiveChairPlayer__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveChairPlayer class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveChairPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLiveChairPlayer_Sex_RawValue(PB3SingleLiveChairPlayer *message) {
  GPBDescriptor *descriptor = [PB3SingleLiveChairPlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveChairPlayer_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLiveChairPlayer_Sex_RawValue(PB3SingleLiveChairPlayer *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLiveChairPlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveChairPlayer_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkPlayer

@implementation PB3SingleLivePkPlayer

@dynamic playerId;
@dynamic name;
@dynamic icon;
@dynamic score;
@dynamic rank;
@dynamic startMatchTime;
@dynamic roomId;

typedef struct PB3SingleLivePkPlayer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t score;
  uint32_t rank;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t startMatchTime;
  int64_t roomId;
} PB3SingleLivePkPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_Rank,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startMatchTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_StartMatchTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, startMatchTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPlayer_FieldNumber_RoomId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPlayer__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkPlayer class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkTeamPush

@implementation PB3SingleLivePkTeamPush

@dynamic id_p;
@dynamic pkReward;
@dynamic hasTeam, team;
@dynamic timestamp;

typedef struct PB3SingleLivePkTeamPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t pkReward;
  NSString *id_p;
  PB3SingleLivePkTeam *team;
  int64_t timestamp;
} PB3SingleLivePkTeamPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeamPush_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeamPush__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkReward",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeamPush_FieldNumber_PkReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeamPush__storage_, pkReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "team",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkTeam),
        .number = PB3SingleLivePkTeamPush_FieldNumber_Team,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeamPush__storage_, team),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTeamPush_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTeamPush__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkTeamPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkTeamPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkSkillPush

@implementation PB3SingleLivePkSkillPush

@dynamic dataOneOfCase;
@dynamic id_p;
@dynamic skill;
@dynamic useRoomId;
@dynamic targetRoomId;
@dynamic secKill;
@dynamic taunt;

typedef struct PB3SingleLivePkSkillPush__storage_ {
  uint32_t _has_storage_[2];
  PB3SingleLivePkSkillType skill;
  NSString *id_p;
  PB3SingleLiveSeckillPush *secKill;
  PB3SingleLiveTauntPush *taunt;
  int64_t useRoomId;
  int64_t targetRoomId;
} PB3SingleLivePkSkillPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkSkillPush_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkSkillType_EnumDescriptor,
        .number = PB3SingleLivePkSkillPush_FieldNumber_Skill,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "useRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkSkillPush_FieldNumber_UseRoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, useRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkSkillPush_FieldNumber_TargetRoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, targetRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "secKill",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveSeckillPush),
        .number = PB3SingleLivePkSkillPush_FieldNumber_SecKill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, secKill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "taunt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveTauntPush),
        .number = PB3SingleLivePkSkillPush_FieldNumber_Taunt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillPush__storage_, taunt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkSkillPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkSkillPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkSkillPush_Skill_RawValue(PB3SingleLivePkSkillPush *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkSkillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkSkillPush_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkSkillPush_Skill_RawValue(PB3SingleLivePkSkillPush *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkSkillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkSkillPush_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3SingleLivePkSkillPush_ClearDataOneOfCase(PB3SingleLivePkSkillPush *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3SingleLiveSeckillPush

@implementation PB3SingleLiveSeckillPush

@dynamic status;
@dynamic endTime;
@dynamic cancelScore;
@dynamic cancelTime;

typedef struct PB3SingleLiveSeckillPush__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLiveSeckillStatus status;
  int32_t cancelScore;
  int32_t cancelTime;
  int64_t endTime;
} PB3SingleLiveSeckillPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveSeckillStatus_EnumDescriptor,
        .number = PB3SingleLiveSeckillPush_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckillPush__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckillPush_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckillPush__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cancelScore",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckillPush_FieldNumber_CancelScore,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckillPush__storage_, cancelScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cancelTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckillPush_FieldNumber_CancelTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckillPush__storage_, cancelTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveSeckillPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveSeckillPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLiveSeckillPush_Status_RawValue(PB3SingleLiveSeckillPush *message) {
  GPBDescriptor *descriptor = [PB3SingleLiveSeckillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveSeckillPush_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLiveSeckillPush_Status_RawValue(PB3SingleLiveSeckillPush *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLiveSeckillPush descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveSeckillPush_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLiveTauntPush

@implementation PB3SingleLiveTauntPush

@dynamic gold;

typedef struct PB3SingleLiveTauntPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
} PB3SingleLiveTauntPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveTauntPush_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveTauntPush__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveTauntPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveTauntPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveUsePkSkillReq

@implementation PB3SingleLiveUsePkSkillReq

@dynamic id_p;
@dynamic skill;
@dynamic gold;

typedef struct PB3SingleLiveUsePkSkillReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLivePkSkillType skill;
  int32_t gold;
  NSString *id_p;
} PB3SingleLiveUsePkSkillReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveUsePkSkillReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveUsePkSkillReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkSkillType_EnumDescriptor,
        .number = PB3SingleLiveUsePkSkillReq_FieldNumber_Skill,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveUsePkSkillReq__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveUsePkSkillReq_FieldNumber_Gold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveUsePkSkillReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveUsePkSkillReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveUsePkSkillReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLiveUsePkSkillReq_Skill_RawValue(PB3SingleLiveUsePkSkillReq *message) {
  GPBDescriptor *descriptor = [PB3SingleLiveUsePkSkillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveUsePkSkillReq_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLiveUsePkSkillReq_Skill_RawValue(PB3SingleLiveUsePkSkillReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLiveUsePkSkillReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveUsePkSkillReq_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLiveUsePkSkillRes

@implementation PB3SingleLiveUsePkSkillRes


typedef struct PB3SingleLiveUsePkSkillRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLiveUsePkSkillRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveUsePkSkillRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLiveUsePkSkillRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkSkillListReq

@implementation PB3SingleLivePkSkillListReq


typedef struct PB3SingleLivePkSkillListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkSkillListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkSkillListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkSkillListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkSkillListRes

@implementation PB3SingleLivePkSkillListRes

@dynamic skillsArray, skillsArray_Count;

typedef struct PB3SingleLivePkSkillListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *skillsArray;
} PB3SingleLivePkSkillListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkSkill),
        .number = PB3SingleLivePkSkillListRes_FieldNumber_SkillsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkillListRes__storage_, skillsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkSkillListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkSkillListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkSkill

@implementation PB3SingleLivePkSkill

@dynamic dataOneOfCase;
@dynamic skill;
@dynamic icon;
@dynamic secKill;
@dynamic taunt;

typedef struct PB3SingleLivePkSkill__storage_ {
  uint32_t _has_storage_[2];
  PB3SingleLivePkSkillType skill;
  NSString *icon;
  PB3SingleLiveSeckill *secKill;
  PB3SingleLiveTaunt *taunt;
} PB3SingleLivePkSkill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skill",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkSkillType_EnumDescriptor,
        .number = PB3SingleLivePkSkill_FieldNumber_Skill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkill__storage_, skill),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkSkill_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkill__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secKill",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveSeckill),
        .number = PB3SingleLivePkSkill_FieldNumber_SecKill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkill__storage_, secKill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "taunt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveTaunt),
        .number = PB3SingleLivePkSkill_FieldNumber_Taunt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkSkill__storage_, taunt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkSkill class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkSkill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkSkill_Skill_RawValue(PB3SingleLivePkSkill *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkSkill descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkSkill_FieldNumber_Skill];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkSkill_Skill_RawValue(PB3SingleLivePkSkill *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkSkill descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkSkill_FieldNumber_Skill];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3SingleLivePkSkill_ClearDataOneOfCase(PB3SingleLivePkSkill *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PB3SingleLiveSeckill

@implementation PB3SingleLiveSeckill

@dynamic score;
@dynamic startTime;
@dynamic endTime;
@dynamic isUsed;

typedef struct PB3SingleLiveSeckill__storage_ {
  uint32_t _has_storage_[1];
  int32_t score;
  int64_t startTime;
  int64_t endTime;
} PB3SingleLiveSeckill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckill_FieldNumber_Score,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckill__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckill_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckill__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckill_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveSeckill__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isUsed",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveSeckill_FieldNumber_IsUsed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveSeckill class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveSeckill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveTaunt

@implementation PB3SingleLiveTaunt

@dynamic gold;
@dynamic goldSuperposition;

typedef struct PB3SingleLiveTaunt__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
} PB3SingleLiveTaunt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveTaunt_FieldNumber_Gold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveTaunt__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "goldSuperposition",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveTaunt_FieldNumber_GoldSuperposition,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveTaunt class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveTaunt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkTreasureBox

@implementation PB3SingleLivePkTreasureBox

@dynamic id_p;
@dynamic name;
@dynamic roomId;
@dynamic endTime;

typedef struct PB3SingleLivePkTreasureBox__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  int64_t roomId;
  int64_t endTime;
} PB3SingleLivePkTreasureBox__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTreasureBox_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTreasureBox__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTreasureBox_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTreasureBox__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTreasureBox_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTreasureBox__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTreasureBox_FieldNumber_EndTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTreasureBox__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkTreasureBox class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkTreasureBox__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveInPkRankListReq

@implementation PB3SingleLiveInPkRankListReq


typedef struct PB3SingleLiveInPkRankListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLiveInPkRankListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveInPkRankListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLiveInPkRankListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveInPkRankListRes

@implementation PB3SingleLiveInPkRankListRes

@dynamic listArray, listArray_Count;

typedef struct PB3SingleLiveInPkRankListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SingleLiveInPkRankListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveInPkRank),
        .number = PB3SingleLiveInPkRankListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkRankListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveInPkRankListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveInPkRankListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveInPkRank

@implementation PB3SingleLiveInPkRank

@dynamic teamsArray, teamsArray_Count;

typedef struct PB3SingleLiveInPkRank__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *teamsArray;
} PB3SingleLiveInPkRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "teamsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveInPkTeam),
        .number = PB3SingleLiveInPkRank_FieldNumber_TeamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkRank__storage_, teamsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveInPkRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveInPkRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveInPkTeam

@implementation PB3SingleLiveInPkTeam

@dynamic roomId;
@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic income;
@dynamic winOrLose;

typedef struct PB3SingleLiveInPkTeam__storage_ {
  uint32_t _has_storage_[1];
  int32_t income;
  int32_t winOrLose;
  NSString *hostName;
  NSString *hostIcon;
  int64_t roomId;
  int64_t hostId;
} PB3SingleLiveInPkTeam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_HostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_HostName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_HostIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "income",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_Income,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, income),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "winOrLose",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveInPkTeam_FieldNumber_WinOrLose,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLiveInPkTeam__storage_, winOrLose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveInPkTeam class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveInPkTeam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveWeekPkRankListReq

@implementation PB3SingleLiveWeekPkRankListReq

@dynamic page;
@dynamic pageSize;
@dynamic type;

typedef struct PB3SingleLiveWeekPkRankListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  PB3SingleLiveWeekPkRankType type;
} PB3SingleLiveWeekPkRankListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRankListReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRankListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRankListReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRankListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveWeekPkRankType_EnumDescriptor,
        .number = PB3SingleLiveWeekPkRankListReq_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRankListReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveWeekPkRankListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveWeekPkRankListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLiveWeekPkRankListReq_Type_RawValue(PB3SingleLiveWeekPkRankListReq *message) {
  GPBDescriptor *descriptor = [PB3SingleLiveWeekPkRankListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveWeekPkRankListReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLiveWeekPkRankListReq_Type_RawValue(PB3SingleLiveWeekPkRankListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLiveWeekPkRankListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLiveWeekPkRankListReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLiveWeekPkRankListRes

@implementation PB3SingleLiveWeekPkRankListRes

@dynamic listArray, listArray_Count;

typedef struct PB3SingleLiveWeekPkRankListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SingleLiveWeekPkRankListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLiveWeekPkRank),
        .number = PB3SingleLiveWeekPkRankListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRankListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveWeekPkRankListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveWeekPkRankListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLiveWeekPkRank

@implementation PB3SingleLiveWeekPkRank

@dynamic hostId;
@dynamic hostName;
@dynamic hostIcon;
@dynamic score;
@dynamic mvpId;
@dynamic mvpName;
@dynamic mvpIcon;
@dynamic winOrLose;

typedef struct PB3SingleLiveWeekPkRank__storage_ {
  uint32_t _has_storage_[1];
  int32_t score;
  int32_t winOrLose;
  NSString *hostName;
  NSString *hostIcon;
  NSString *mvpName;
  NSString *mvpIcon;
  int64_t hostId;
  int64_t mvpId;
} PB3SingleLiveWeekPkRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_HostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, hostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_HostName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, hostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_HostIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, hostIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mvpId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_MvpId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, mvpId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mvpName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_MvpName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, mvpName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mvpIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_MvpIcon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, mvpIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "winOrLose",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLiveWeekPkRank_FieldNumber_WinOrLose,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SingleLiveWeekPkRank__storage_, winOrLose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLiveWeekPkRank class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLiveWeekPkRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkRecInviteListReq

@implementation PB3SingleLivePkRecInviteListReq

@dynamic isFromMatch;

typedef struct PB3SingleLivePkRecInviteListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkRecInviteListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isFromMatch",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkRecInviteListReq_FieldNumber_IsFromMatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkRecInviteListReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkRecInviteListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkRecInviteListRes

@implementation PB3SingleLivePkRecInviteListRes

@dynamic playersArray, playersArray_Count;

typedef struct PB3SingleLivePkRecInviteListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *playersArray;
} PB3SingleLivePkRecInviteListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkRecInviteListRes_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRecInviteListRes__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkRecInviteListRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkRecInviteListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteReq

@implementation PB3SingleLivePkInviteReq

@dynamic invitedPlayerId;
@dynamic invitedRoomId;

typedef struct PB3SingleLivePkInviteReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t invitedPlayerId;
  int64_t invitedRoomId;
} PB3SingleLivePkInviteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteReq_FieldNumber_InvitedPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteReq__storage_, invitedPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "invitedRoomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteReq_FieldNumber_InvitedRoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteReq__storage_, invitedRoomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteRes

@implementation PB3SingleLivePkInviteRes

@dynamic inviteId;
@dynamic playersArray, playersArray_Count;
@dynamic tip;
@dynamic endTime;

typedef struct PB3SingleLivePkInviteRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
  NSMutableArray *playersArray;
  NSString *tip;
  int64_t endTime;
} PB3SingleLivePkInviteRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteRes_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRes__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkInviteRes_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRes__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tip",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteRes_FieldNumber_Tip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRes__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteRes_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRes__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteInfo

@implementation PB3SingleLivePkInviteInfo

@dynamic inviteId;
@dynamic hasPlayer, player;
@dynamic endTime;
@dynamic operatorId;
@dynamic pkInviteAction;

typedef struct PB3SingleLivePkInviteInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLivePkInviteAction pkInviteAction;
  NSString *inviteId;
  PB3SingleLivePkPlayer *player;
  int64_t endTime;
  int64_t operatorId;
} PB3SingleLivePkInviteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteInfo_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteInfo__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkInviteInfo_FieldNumber_Player,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteInfo__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteInfo_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "operatorId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteInfo_FieldNumber_OperatorId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteInfo__storage_, operatorId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pkInviteAction",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkInviteAction_EnumDescriptor,
        .number = PB3SingleLivePkInviteInfo_FieldNumber_PkInviteAction,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteInfo__storage_, pkInviteAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkInviteInfo_PkInviteAction_RawValue(PB3SingleLivePkInviteInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInviteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInviteInfo_FieldNumber_PkInviteAction];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInviteInfo_PkInviteAction_RawValue(PB3SingleLivePkInviteInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInviteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInviteInfo_FieldNumber_PkInviteAction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkInviteCancelReq

@implementation PB3SingleLivePkInviteCancelReq

@dynamic inviteId;

typedef struct PB3SingleLivePkInviteCancelReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
} PB3SingleLivePkInviteCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteCancelReq_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteCancelReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteCancelReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteCancelRes

@implementation PB3SingleLivePkInviteCancelRes


typedef struct PB3SingleLivePkInviteCancelRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkInviteCancelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteCancelRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkInviteCancelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteRejectReq

@implementation PB3SingleLivePkInviteRejectReq

@dynamic rejectType;
@dynamic inviteId;

typedef struct PB3SingleLivePkInviteRejectReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLivePkInviteRejectType rejectType;
  NSString *inviteId;
} PB3SingleLivePkInviteRejectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rejectType",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkInviteRejectType_EnumDescriptor,
        .number = PB3SingleLivePkInviteRejectReq_FieldNumber_RejectType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRejectReq__storage_, rejectType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteRejectReq_FieldNumber_InviteId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteRejectReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteRejectReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteRejectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkInviteRejectReq_RejectType_RawValue(PB3SingleLivePkInviteRejectReq *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInviteRejectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInviteRejectReq_FieldNumber_RejectType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkInviteRejectReq_RejectType_RawValue(PB3SingleLivePkInviteRejectReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkInviteRejectReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkInviteRejectReq_FieldNumber_RejectType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkInviteRejectRes

@implementation PB3SingleLivePkInviteRejectRes


typedef struct PB3SingleLivePkInviteRejectRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkInviteRejectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteRejectRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkInviteRejectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteAcceptReq

@implementation PB3SingleLivePkInviteAcceptReq

@dynamic inviteId;

typedef struct PB3SingleLivePkInviteAcceptReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteId;
} PB3SingleLivePkInviteAcceptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkInviteAcceptReq_FieldNumber_InviteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkInviteAcceptReq__storage_, inviteId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteAcceptReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkInviteAcceptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkInviteAcceptRes

@implementation PB3SingleLivePkInviteAcceptRes


typedef struct PB3SingleLivePkInviteAcceptRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkInviteAcceptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkInviteAcceptRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkInviteAcceptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchReq

@implementation PB3SingleLivePkMatchReq


typedef struct PB3SingleLivePkMatchReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchRes

@implementation PB3SingleLivePkMatchRes

@dynamic hasPlayer, player;
@dynamic timeoutAt;
@dynamic tip;

typedef struct PB3SingleLivePkMatchRes__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLivePkPlayer *player;
  NSString *tip;
  int64_t timeoutAt;
} PB3SingleLivePkMatchRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkMatchRes_FieldNumber_Player,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchRes__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeoutAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchRes_FieldNumber_TimeoutAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchRes__storage_, timeoutAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tip",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchRes_FieldNumber_Tip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchRes__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkMatchRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchCancelReq

@implementation PB3SingleLivePkMatchCancelReq


typedef struct PB3SingleLivePkMatchCancelReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchCancelReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchCancelRes

@implementation PB3SingleLivePkMatchCancelRes


typedef struct PB3SingleLivePkMatchCancelRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchCancelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchCancelRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchCancelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchInfo

@implementation PB3SingleLivePkMatchInfo

@dynamic matchId;
@dynamic playersArray, playersArray_Count;
@dynamic endTime;
@dynamic msg;
@dynamic pkMatchAction;

typedef struct PB3SingleLivePkMatchInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLivePkMatchAction pkMatchAction;
  NSString *matchId;
  NSMutableArray *playersArray;
  NSString *msg;
  int64_t endTime;
} PB3SingleLivePkMatchInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchInfo_FieldNumber_MatchId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchInfo__storage_, matchId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingleLivePkPlayer),
        .number = PB3SingleLivePkMatchInfo_FieldNumber_PlayersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchInfo__storage_, playersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchInfo_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchInfo_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchInfo__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pkMatchAction",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkMatchAction_EnumDescriptor,
        .number = PB3SingleLivePkMatchInfo_FieldNumber_PkMatchAction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchInfo__storage_, pkMatchAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchInfo class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkMatchInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkMatchInfo_PkMatchAction_RawValue(PB3SingleLivePkMatchInfo *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkMatchInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkMatchInfo_FieldNumber_PkMatchAction];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkMatchInfo_PkMatchAction_RawValue(PB3SingleLivePkMatchInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkMatchInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkMatchInfo_FieldNumber_PkMatchAction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkMatchStartReq

@implementation PB3SingleLivePkMatchStartReq

@dynamic matchId;

typedef struct PB3SingleLivePkMatchStartReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *matchId;
} PB3SingleLivePkMatchStartReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMatchStartReq_FieldNumber_MatchId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMatchStartReq__storage_, matchId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchStartReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkMatchStartReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchStartRes

@implementation PB3SingleLivePkMatchStartRes


typedef struct PB3SingleLivePkMatchStartRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchStartRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchStartRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchStartRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchKeepWaitReq

@implementation PB3SingleLivePkMatchKeepWaitReq


typedef struct PB3SingleLivePkMatchKeepWaitReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchKeepWaitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchKeepWaitReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchKeepWaitReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMatchKeepWaitRes

@implementation PB3SingleLivePkMatchKeepWaitRes


typedef struct PB3SingleLivePkMatchKeepWaitRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkMatchKeepWaitRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMatchKeepWaitRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkMatchKeepWaitRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkProtectPush

@implementation PB3SingleLivePkProtectPush

@dynamic endTime;

typedef struct PB3SingleLivePkProtectPush__storage_ {
  uint32_t _has_storage_[1];
  int64_t endTime;
} PB3SingleLivePkProtectPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkProtectPush_FieldNumber_EndTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkProtectPush__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkProtectPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkProtectPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkMvpGlobalPush

@implementation PB3SingleLivePkMvpGlobalPush

@dynamic mvpId;
@dynamic mvpName;
@dynamic roomId;

typedef struct PB3SingleLivePkMvpGlobalPush__storage_ {
  uint32_t _has_storage_[1];
  NSString *mvpName;
  int64_t mvpId;
  int64_t roomId;
} PB3SingleLivePkMvpGlobalPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mvpId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMvpGlobalPush_FieldNumber_MvpId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMvpGlobalPush__storage_, mvpId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mvpName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMvpGlobalPush_FieldNumber_MvpName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMvpGlobalPush__storage_, mvpName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkMvpGlobalPush_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkMvpGlobalPush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkMvpGlobalPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkMvpGlobalPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkRewardTicketPush

@implementation PB3SingleLivePkRewardTicketPush

@dynamic ticket;
@dynamic roomId;

typedef struct PB3SingleLivePkRewardTicketPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t ticket;
  int64_t roomId;
} PB3SingleLivePkRewardTicketPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkRewardTicketPush_FieldNumber_Ticket,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRewardTicketPush__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkRewardTicketPush_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkRewardTicketPush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkRewardTicketPush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkRewardTicketPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkTauntRoomNoticePush

@implementation PB3SingleLivePkTauntRoomNoticePush

@dynamic useTauntPlayerId;
@dynamic useTauntPlayerName;
@dynamic roomId;
@dynamic tauntHostId;
@dynamic tauntHostName;

typedef struct PB3SingleLivePkTauntRoomNoticePush__storage_ {
  uint32_t _has_storage_[1];
  NSString *useTauntPlayerName;
  NSString *tauntHostName;
  int64_t useTauntPlayerId;
  int64_t roomId;
  int64_t tauntHostId;
} PB3SingleLivePkTauntRoomNoticePush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "useTauntPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTauntRoomNoticePush_FieldNumber_UseTauntPlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTauntRoomNoticePush__storage_, useTauntPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "useTauntPlayerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTauntRoomNoticePush_FieldNumber_UseTauntPlayerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTauntRoomNoticePush__storage_, useTauntPlayerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTauntRoomNoticePush_FieldNumber_RoomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTauntRoomNoticePush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tauntHostId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTauntRoomNoticePush_FieldNumber_TauntHostId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTauntRoomNoticePush__storage_, tauntHostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tauntHostName",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkTauntRoomNoticePush_FieldNumber_TauntHostName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SingleLivePkTauntRoomNoticePush__storage_, tauntHostName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkTauntRoomNoticePush class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkTauntRoomNoticePush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkVoiceMuteReq

@implementation PB3SingleLivePkVoiceMuteReq

@dynamic mute;
@dynamic pkId;

typedef struct PB3SingleLivePkVoiceMuteReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLiveMuteType mute;
  NSString *pkId;
} PB3SingleLivePkVoiceMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveMuteType_EnumDescriptor,
        .number = PB3SingleLivePkVoiceMuteReq_FieldNumber_Mute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkVoiceMuteReq__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pkId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkVoiceMuteReq_FieldNumber_PkId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkVoiceMuteReq__storage_, pkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkVoiceMuteReq class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkVoiceMuteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkVoiceMuteReq_Mute_RawValue(PB3SingleLivePkVoiceMuteReq *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkVoiceMuteReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkVoiceMuteReq_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkVoiceMuteReq_Mute_RawValue(PB3SingleLivePkVoiceMuteReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkVoiceMuteReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkVoiceMuteReq_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkVoiceMuteRes

@implementation PB3SingleLivePkVoiceMuteRes


typedef struct PB3SingleLivePkVoiceMuteRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SingleLivePkVoiceMuteRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkVoiceMuteRes class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SingleLivePkVoiceMuteRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingleLivePkPushMuteType

@implementation PB3SingleLivePkPushMuteType

@dynamic mute;
@dynamic roomId;

typedef struct PB3SingleLivePkPushMuteType__storage_ {
  uint32_t _has_storage_[1];
  PB3SingleLiveMuteType mute;
  int64_t roomId;
} PB3SingleLivePkPushMuteType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mute",
        .dataTypeSpecific.enumDescFunc = PB3SingleLiveMuteType_EnumDescriptor,
        .number = PB3SingleLivePkPushMuteType_FieldNumber_Mute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPushMuteType__storage_, mute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingleLivePkPushMuteType_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkPushMuteType__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkPushMuteType class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkPushMuteType__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkPushMuteType_Mute_RawValue(PB3SingleLivePkPushMuteType *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkPushMuteType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkPushMuteType_FieldNumber_Mute];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkPushMuteType_Mute_RawValue(PB3SingleLivePkPushMuteType *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkPushMuteType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkPushMuteType_FieldNumber_Mute];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SingleLivePkChairChange

@implementation PB3SingleLivePkChairChange

@dynamic dataOneOfCase;
@dynamic changeType;
@dynamic move;
@dynamic sit;

typedef struct PB3SingleLivePkChairChange__storage_ {
  uint32_t _has_storage_[2];
  PB3SingleLivePkChairChangeType changeType;
  PB3BroadcastChairMove *move;
  PB3BroadcastChair *sit;
} PB3SingleLivePkChairChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "changeType",
        .dataTypeSpecific.enumDescFunc = PB3SingleLivePkChairChangeType_EnumDescriptor,
        .number = PB3SingleLivePkChairChange_FieldNumber_ChangeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingleLivePkChairChange__storage_, changeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "move",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BroadcastChairMove),
        .number = PB3SingleLivePkChairChange_FieldNumber_Move,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkChairChange__storage_, move),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sit",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BroadcastChair),
        .number = PB3SingleLivePkChairChange_FieldNumber_Sit,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PB3SingleLivePkChairChange__storage_, sit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingleLivePkChairChange class]
                                     rootClass:[PB3RoomPatternExtRoot class]
                                          file:PB3RoomPatternExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingleLivePkChairChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingleLivePkChairChange_ChangeType_RawValue(PB3SingleLivePkChairChange *message) {
  GPBDescriptor *descriptor = [PB3SingleLivePkChairChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkChairChange_FieldNumber_ChangeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingleLivePkChairChange_ChangeType_RawValue(PB3SingleLivePkChairChange *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingleLivePkChairChange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingleLivePkChairChange_FieldNumber_ChangeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void PB3SingleLivePkChairChange_ClearDataOneOfCase(PB3SingleLivePkChairChange *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
