// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/index.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/IndexExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
#import "pb/PlayExt.pbobjc.h"
#import "pb/ShowExt.pbobjc.h"
#import "pb/AcmConfExt.pbobjc.h"
#import "pb/SystemExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3IndexExtRoot

@implementation PB3IndexExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3IndexExtRoot_FileDescriptor

static GPBFileDescriptor *PB3IndexExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3IndexErr

GPBEnumDescriptor *PB3IndexErr_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ErrIndexZero\000";
    static const int32_t values[] = {
        PB3IndexErr_ErrIndexZero,
    };
    static const char *extraTextFormatInfo = "\001\000\010\344\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexErr)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexErr_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexErr_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexErr_ErrIndexZero:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexCmdId

GPBEnumDescriptor *PB3IndexCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcIndexZero\000IcActivityRoom\000IcSearchRoom\000"
        "IcYoungModel\000IcExchangeCode\000IcAcGameConf"
        "\000IcThemeConfig\000IcPendantConfig\000IcHomePus"
        "hApppopUp\000IcSubInfoCountDown\000IcListSubIn"
        "fo\000IcRealmNameConf\000IcActSubInfoPush\000IcCo"
        "untDownConf\000";
    static const int32_t values[] = {
        PB3IndexCmdId_IcIndexZero,
        PB3IndexCmdId_IcActivityRoom,
        PB3IndexCmdId_IcSearchRoom,
        PB3IndexCmdId_IcYoungModel,
        PB3IndexCmdId_IcExchangeCode,
        PB3IndexCmdId_IcAcGameConf,
        PB3IndexCmdId_IcThemeConfig,
        PB3IndexCmdId_IcPendantConfig,
        PB3IndexCmdId_IcHomePushApppopUp,
        PB3IndexCmdId_IcSubInfoCountDown,
        PB3IndexCmdId_IcListSubInfo,
        PB3IndexCmdId_IcRealmNameConf,
        PB3IndexCmdId_IcActSubInfoPush,
        PB3IndexCmdId_IcCountDownConf,
    };
    static const char *extraTextFormatInfo = "\016\000b\211\000\001b\214\000\002b\212\000\003b\212\000\004b\214\000\005b\212\000\006b\213\000\007b\215\000\010b\211c\003A\000\tb\220\000\nb\213\000\013b\215\000\014b\216\000\rb\215\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexCmdId_IcIndexZero:
    case PB3IndexCmdId_IcActivityRoom:
    case PB3IndexCmdId_IcSearchRoom:
    case PB3IndexCmdId_IcYoungModel:
    case PB3IndexCmdId_IcExchangeCode:
    case PB3IndexCmdId_IcAcGameConf:
    case PB3IndexCmdId_IcThemeConfig:
    case PB3IndexCmdId_IcPendantConfig:
    case PB3IndexCmdId_IcHomePushApppopUp:
    case PB3IndexCmdId_IcSubInfoCountDown:
    case PB3IndexCmdId_IcListSubInfo:
    case PB3IndexCmdId_IcRealmNameConf:
    case PB3IndexCmdId_IcActSubInfoPush:
    case PB3IndexCmdId_IcCountDownConf:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexTab

GPBEnumDescriptor *PB3IndexTab_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TabZore\000TabNew\000TabHot\000TabRecommend\000TabKe"
        "yWord\000TabCall\000TabSupperMan\000TabMoreHot\000Ta"
        "bUserDefine\000TabTjKeyWord\000TabRecommendV2\000";
    static const int32_t values[] = {
        PB3IndexTab_TabZore,
        PB3IndexTab_TabNew,
        PB3IndexTab_TabHot,
        PB3IndexTab_TabRecommend,
        PB3IndexTab_TabKeyWord,
        PB3IndexTab_TabCall,
        PB3IndexTab_TabSupperMan,
        PB3IndexTab_TabMoreHot,
        PB3IndexTab_TabUserDefine,
        PB3IndexTab_TabTjKeyWord,
        PB3IndexTab_TabRecommendV2,
    };
    static const char *extraTextFormatInfo = "\013\000c\204\000\001c\203\000\002c\203\000\003c\211\000\004c\207\000\005c\204\000\006c\211\000\007c\207\000\010c\212\000\tc\342\207\000\nc\211\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexTab)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexTab_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexTab_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexTab_TabZore:
    case PB3IndexTab_TabNew:
    case PB3IndexTab_TabHot:
    case PB3IndexTab_TabRecommend:
    case PB3IndexTab_TabKeyWord:
    case PB3IndexTab_TabCall:
    case PB3IndexTab_TabSupperMan:
    case PB3IndexTab_TabMoreHot:
    case PB3IndexTab_TabUserDefine:
    case PB3IndexTab_TabTjKeyWord:
    case PB3IndexTab_TabRecommendV2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexConfType

GPBEnumDescriptor *PB3IndexConfType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ConfZore\000ConfSubscript\000ConfAcGameLimit\000";
    static const int32_t values[] = {
        PB3IndexConfType_ConfZore,
        PB3IndexConfType_ConfSubscript,
        PB3IndexConfType_ConfAcGameLimit,
    };
    static const char *extraTextFormatInfo = "\003\000\004\204\000\001\004\211\000\002\004\202\204\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexConfType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexConfType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexConfType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexConfType_ConfZore:
    case PB3IndexConfType_ConfSubscript:
    case PB3IndexConfType_ConfAcGameLimit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ClickType

GPBEnumDescriptor *PB3ClickType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClickBroadFriend\000ClickRecommend\000ClickPer"
        "sonal\000ClIckRecommendV2\000";
    static const int32_t values[] = {
        PB3ClickType_ClickBroadFriend,
        PB3ClickType_ClickRecommend,
        PB3ClickType_ClickPersonal,
        PB3ClickType_ClIckRecommendV2,
    };
    static const char *extraTextFormatInfo = "\001\003\003b\351\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClickType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClickType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClickType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClickType_ClickBroadFriend:
    case PB3ClickType_ClickRecommend:
    case PB3ClickType_ClickPersonal:
    case PB3ClickType_ClIckRecommendV2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPwdType

GPBEnumDescriptor *PB3YoungModelPwdType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPwdTypeZero\000YoungModelPwdTypeS"
        "et\000YoungModelPwdTypeOpen\000YoungModelPwdTy"
        "peClosed\000YoungModelPwdTypeModify\000YoungMo"
        "delPwdTypeForget\000YoungModelPwdTypeOrigin"
        "\000YoungModelPwdTypeRenewal\000";
    static const int32_t values[] = {
        PB3YoungModelPwdType_YoungModelPwdTypeZero,
        PB3YoungModelPwdType_YoungModelPwdTypeSet,
        PB3YoungModelPwdType_YoungModelPwdTypeOpen,
        PB3YoungModelPwdType_YoungModelPwdTypeClosed,
        PB3YoungModelPwdType_YoungModelPwdTypeModify,
        PB3YoungModelPwdType_YoungModelPwdTypeForget,
        PB3YoungModelPwdType_YoungModelPwdTypeOrigin,
        PB3YoungModelPwdType_YoungModelPwdTypeRenewal,
    };
    static const char *extraTextFormatInfo = "\010\000\021\204\000\001\021\203\000\002\021\204\000\003\021\206\000\004\021\206\000\005\021\206\000\006\021\206\000\007\021\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPwdType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPwdType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPwdType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPwdType_YoungModelPwdTypeZero:
    case PB3YoungModelPwdType_YoungModelPwdTypeSet:
    case PB3YoungModelPwdType_YoungModelPwdTypeOpen:
    case PB3YoungModelPwdType_YoungModelPwdTypeClosed:
    case PB3YoungModelPwdType_YoungModelPwdTypeModify:
    case PB3YoungModelPwdType_YoungModelPwdTypeForget:
    case PB3YoungModelPwdType_YoungModelPwdTypeOrigin:
    case PB3YoungModelPwdType_YoungModelPwdTypeRenewal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPhoneType

GPBEnumDescriptor *PB3YoungModelPhoneType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPhoneTypeZero\000YoungModelPhoneT"
        "ypeGet\000YoungModelPwdTypeSendCode\000YoungMo"
        "delPwdTypeConfirmCode\000";
    static const int32_t values[] = {
        PB3YoungModelPhoneType_YoungModelPhoneTypeZero,
        PB3YoungModelPhoneType_YoungModelPhoneTypeGet,
        PB3YoungModelPhoneType_YoungModelPwdTypeSendCode,
        PB3YoungModelPhoneType_YoungModelPwdTypeConfirmCode,
    };
    static const char *extraTextFormatInfo = "\004\000\023\204\000\001\023\203\000\002\021\210\000\003\021\213\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPhoneType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPhoneType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPhoneType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPhoneType_YoungModelPhoneTypeZero:
    case PB3YoungModelPhoneType_YoungModelPhoneTypeGet:
    case PB3YoungModelPhoneType_YoungModelPwdTypeSendCode:
    case PB3YoungModelPhoneType_YoungModelPwdTypeConfirmCode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPageType

GPBEnumDescriptor *PB3YoungModelPageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPageTypeZero\000YoungModelPageTyp"
        "eTimeout\000YoungModelPageTypeBanNight\000Youn"
        "gModelPageTypeWhiteList\000";
    static const int32_t values[] = {
        PB3YoungModelPageType_YoungModelPageTypeZero,
        PB3YoungModelPageType_YoungModelPageTypeTimeout,
        PB3YoungModelPageType_YoungModelPageTypeBanNight,
        PB3YoungModelPageType_YoungModelPageTypeWhiteList,
    };
    static const char *extraTextFormatInfo = "\004\000\022\204\000\001\022\207\000\002\022\210\000\003\022\211\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPageType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPageType_YoungModelPageTypeZero:
    case PB3YoungModelPageType_YoungModelPageTypeTimeout:
    case PB3YoungModelPageType_YoungModelPageTypeBanNight:
    case PB3YoungModelPageType_YoungModelPageTypeWhiteList:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WeekStarType

GPBEnumDescriptor *PB3WeekStarType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ThisWeek\000LastWeek\000";
    static const int32_t values[] = {
        PB3WeekStarType_ThisWeek,
        PB3WeekStarType_LastWeek,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WeekStarType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WeekStarType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WeekStarType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WeekStarType_ThisWeek:
    case PB3WeekStarType_LastWeek:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3KeepNo1ShowType

GPBEnumDescriptor *PB3KeepNo1ShowType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Kn1StNone\000Kn1StShutDown\000Kn1StWait\000Kn1StK"
        "eep\000";
    static const int32_t values[] = {
        PB3KeepNo1ShowType_Kn1StNone,
        PB3KeepNo1ShowType_Kn1StShutDown,
        PB3KeepNo1ShowType_Kn1StWait,
        PB3KeepNo1ShowType_Kn1StKeep,
    };
    static const char *extraTextFormatInfo = "\004\000b\002A\344\000\001b\002A\344\344\000\002b\002A\344\000\003b\002A\344\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3KeepNo1ShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3KeepNo1ShowType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3KeepNo1ShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3KeepNo1ShowType_Kn1StNone:
    case PB3KeepNo1ShowType_Kn1StShutDown:
    case PB3KeepNo1ShowType_Kn1StWait:
    case PB3KeepNo1ShowType_Kn1StKeep:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SubLocation

GPBEnumDescriptor *PB3SubLocation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SublZero\000SublRightBottom\000SublRightTop\000Su"
        "blRightMiddle\000";
    static const int32_t values[] = {
        PB3SubLocation_SublZero,
        PB3SubLocation_SublRightBottom,
        PB3SubLocation_SublRightTop,
        PB3SubLocation_SublRightMiddle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SubLocation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SubLocation_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SubLocation_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SubLocation_SublZero:
    case PB3SubLocation_SublRightBottom:
    case PB3SubLocation_SublRightTop:
    case PB3SubLocation_SublRightMiddle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AdEventType

GPBEnumDescriptor *PB3AdEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Activate\000Register\000Recharge\000Login\000";
    static const int32_t values[] = {
        PB3AdEventType_Activate,
        PB3AdEventType_Register,
        PB3AdEventType_Recharge,
        PB3AdEventType_Login,
    };
    static const char *extraTextFormatInfo = "\004\000\010\000\001\010\000\002\010\000\003\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AdEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AdEventType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AdEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AdEventType_Activate:
    case PB3AdEventType_Register:
    case PB3AdEventType_Recharge:
    case PB3AdEventType_Login:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WeekStarRankType

GPBEnumDescriptor *PB3WeekStarRankType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WsrtWeekStar\000WsrtWeekStarFans\000";
    static const int32_t values[] = {
        PB3WeekStarRankType_WsrtWeekStar,
        PB3WeekStarRankType_WsrtWeekStarFans,
    };
    static const char *extraTextFormatInfo = "\002\000d\210\000\001d\214\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WeekStarRankType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WeekStarRankType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WeekStarRankType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WeekStarRankType_WsrtWeekStar:
    case PB3WeekStarRankType_WsrtWeekStarFans:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SensitiveWordLib

GPBEnumDescriptor *PB3SensitiveWordLib_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SensitiveWordLibNone\000SensitiveWordLibNam"
        "e\000";
    static const int32_t values[] = {
        PB3SensitiveWordLib_SensitiveWordLibNone,
        PB3SensitiveWordLib_SensitiveWordLibName,
    };
    static const char *extraTextFormatInfo = "\002\000\020\204\000\001\020\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SensitiveWordLib)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SensitiveWordLib_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SensitiveWordLib_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SensitiveWordLib_SensitiveWordLibNone:
    case PB3SensitiveWordLib_SensitiveWordLibName:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ReportType

GPBEnumDescriptor *PB3ReportType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Politics\000Sexy\000Advert\000Other\000Child\000Protect"
        "ion\000Song\000History\000AbuseIndecent\000AbuseAssa"
        "ult\000IncitementSuicide\000FalseInformation\000";
    static const int32_t values[] = {
        PB3ReportType_Politics,
        PB3ReportType_Sexy,
        PB3ReportType_Advert,
        PB3ReportType_Other,
        PB3ReportType_Child,
        PB3ReportType_Protection,
        PB3ReportType_Song,
        PB3ReportType_History,
        PB3ReportType_AbuseIndecent,
        PB3ReportType_AbuseAssault,
        PB3ReportType_IncitementSuicide,
        PB3ReportType_FalseInformation,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ReportType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ReportType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ReportType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ReportType_Politics:
    case PB3ReportType_Sexy:
    case PB3ReportType_Advert:
    case PB3ReportType_Other:
    case PB3ReportType_Child:
    case PB3ReportType_Protection:
    case PB3ReportType_Song:
    case PB3ReportType_History:
    case PB3ReportType_AbuseIndecent:
    case PB3ReportType_AbuseAssault:
    case PB3ReportType_IncitementSuicide:
    case PB3ReportType_FalseInformation:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ReportFrom

GPBEnumDescriptor *PB3ReportFrom_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ReportFromZero\000General\000Harass\000";
    static const int32_t values[] = {
        PB3ReportFrom_ReportFromZero,
        PB3ReportFrom_General,
        PB3ReportFrom_Harass,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ReportFrom)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ReportFrom_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ReportFrom_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ReportFrom_ReportFromZero:
    case PB3ReportFrom_General:
    case PB3ReportFrom_Harass:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WechatNotifyType

GPBEnumDescriptor *PB3WechatNotifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WntNone\000WntVisit\000WntOrder\000WntMsg\000WntBill"
        "\000";
    static const int32_t values[] = {
        PB3WechatNotifyType_WntNone,
        PB3WechatNotifyType_WntVisit,
        PB3WechatNotifyType_WntOrder,
        PB3WechatNotifyType_WntMsg,
        PB3WechatNotifyType_WntBill,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WechatNotifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WechatNotifyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WechatNotifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WechatNotifyType_WntNone:
    case PB3WechatNotifyType_WntVisit:
    case PB3WechatNotifyType_WntOrder:
    case PB3WechatNotifyType_WntMsg:
    case PB3WechatNotifyType_WntBill:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TaxConfType

GPBEnumDescriptor *PB3TaxConfType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TaxConfTypeNone\000TaxConfTypeWhiteList\000";
    static const int32_t values[] = {
        PB3TaxConfType_TaxConfTypeNone,
        PB3TaxConfType_TaxConfTypeWhiteList,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TaxConfType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TaxConfType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TaxConfType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TaxConfType_TaxConfTypeNone:
    case PB3TaxConfType_TaxConfTypeWhiteList:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexAcGameType

GPBEnumDescriptor *PB3IndexAcGameType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IagtNone\000IagtClimbingTower\000IagtUfo\000IagtH"
        "5All\000IagtH5Half\000";
    static const int32_t values[] = {
        PB3IndexAcGameType_IagtNone,
        PB3IndexAcGameType_IagtClimbingTower,
        PB3IndexAcGameType_IagtUfo,
        PB3IndexAcGameType_IagtH5All,
        PB3IndexAcGameType_IagtH5Half,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexAcGameType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexAcGameType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexAcGameType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexAcGameType_IagtNone:
    case PB3IndexAcGameType_IagtClimbingTower:
    case PB3IndexAcGameType_IagtUfo:
    case PB3IndexAcGameType_IagtH5All:
    case PB3IndexAcGameType_IagtH5Half:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PendantState

GPBEnumDescriptor *PB3PendantState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PendantDefault\000PendantStatic\000PendantMove"
        "\000";
    static const int32_t values[] = {
        PB3PendantState_PendantDefault,
        PB3PendantState_PendantStatic,
        PB3PendantState_PendantMove,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PendantState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PendantState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PendantState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PendantState_PendantDefault:
    case PB3PendantState_PendantStatic:
    case PB3PendantState_PendantMove:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PendantType

GPBEnumDescriptor *PB3PendantType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PtZero\000PtMusic\000PtH5\000PtShengdian\000PtOrder\000"
        "PtChatCp\000";
    static const int32_t values[] = {
        PB3PendantType_PtZero,
        PB3PendantType_PtMusic,
        PB3PendantType_PtH5,
        PB3PendantType_PtShengdian,
        PB3PendantType_PtOrder,
        PB3PendantType_PtChatCp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PendantType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PendantType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PendantType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PendantType_PtZero:
    case PB3PendantType_PtMusic:
    case PB3PendantType_PtH5:
    case PB3PendantType_PtShengdian:
    case PB3PendantType_PtOrder:
    case PB3PendantType_PtChatCp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BannerState

GPBEnumDescriptor *PB3BannerState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BannerDefault\000BannerOpen\000BannerHide\000";
    static const int32_t values[] = {
        PB3BannerState_BannerDefault,
        PB3BannerState_BannerOpen,
        PB3BannerState_BannerHide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BannerState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BannerState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BannerState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BannerState_BannerDefault:
    case PB3BannerState_BannerOpen:
    case PB3BannerState_BannerHide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BannerType

GPBEnumDescriptor *PB3BannerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BannerTypeBoxAward\000BannerTypeNormal\000";
    static const int32_t values[] = {
        PB3BannerType_BannerTypeBoxAward,
        PB3BannerType_BannerTypeNormal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BannerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BannerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BannerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BannerType_BannerTypeBoxAward:
    case PB3BannerType_BannerTypeNormal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3EventTrackingArgType

GPBEnumDescriptor *PB3EventTrackingArgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EtatUnknow\000EtatInt\000EtatStr\000EtatFloat\000";
    static const int32_t values[] = {
        PB3EventTrackingArgType_EtatUnknow,
        PB3EventTrackingArgType_EtatInt,
        PB3EventTrackingArgType_EtatStr,
        PB3EventTrackingArgType_EtatFloat,
    };
    static const char *extraTextFormatInfo = "\004\000d\206\000\001d\203\000\002d\203\000\003d\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3EventTrackingArgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3EventTrackingArgType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3EventTrackingArgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3EventTrackingArgType_EtatUnknow:
    case PB3EventTrackingArgType_EtatInt:
    case PB3EventTrackingArgType_EtatStr:
    case PB3EventTrackingArgType_EtatFloat:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TouchAreaType

GPBEnumDescriptor *PB3TouchAreaType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TatNone\000TatButton\000TatPicture\000TatAll\000";
    static const int32_t values[] = {
        PB3TouchAreaType_TatNone,
        PB3TouchAreaType_TatButton,
        PB3TouchAreaType_TatPicture,
        PB3TouchAreaType_TatAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TouchAreaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TouchAreaType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TouchAreaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TouchAreaType_TatNone:
    case PB3TouchAreaType_TatButton:
    case PB3TouchAreaType_TatPicture:
    case PB3TouchAreaType_TatAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TargetType

GPBEnumDescriptor *PB3TargetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TtNone\000TtCustomizeId\000TtOnline\000TtInstallI"
        "n\000TtCharge\000";
    static const int32_t values[] = {
        PB3TargetType_TtNone,
        PB3TargetType_TtCustomizeId,
        PB3TargetType_TtOnline,
        PB3TargetType_TtInstallIn,
        PB3TargetType_TtCharge,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TargetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TargetType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TargetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TargetType_TtNone:
    case PB3TargetType_TtCustomizeId:
    case PB3TargetType_TtOnline:
    case PB3TargetType_TtInstallIn:
    case PB3TargetType_TtCharge:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AppearArea

GPBEnumDescriptor *PB3AppearArea_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AaNone\000AaAllArea\000AaRoomArea\000AaIndexArea\000";
    static const int32_t values[] = {
        PB3AppearArea_AaNone,
        PB3AppearArea_AaAllArea,
        PB3AppearArea_AaRoomArea,
        PB3AppearArea_AaIndexArea,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AppearArea)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AppearArea_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AppearArea_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AppearArea_AaNone:
    case PB3AppearArea_AaAllArea:
    case PB3AppearArea_AaRoomArea:
    case PB3AppearArea_AaIndexArea:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3FirstPayGiftBoxStatus

GPBEnumDescriptor *PB3FirstPayGiftBoxStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FpgbsNone\000FpgbsReward\000FpgbsGain\000";
    static const int32_t values[] = {
        PB3FirstPayGiftBoxStatus_FpgbsNone,
        PB3FirstPayGiftBoxStatus_FpgbsReward,
        PB3FirstPayGiftBoxStatus_FpgbsGain,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3FirstPayGiftBoxStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3FirstPayGiftBoxStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3FirstPayGiftBoxStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3FirstPayGiftBoxStatus_FpgbsNone:
    case PB3FirstPayGiftBoxStatus_FpgbsReward:
    case PB3FirstPayGiftBoxStatus_FpgbsGain:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3UserBehaviorsType

GPBEnumDescriptor *PB3UserBehaviorsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UbtZero\000UbtAppOperationScreen\000UbtAppCutB"
        "ackReception\000UbtPcOperationMouse\000UbtPcOp"
        "erationKeyboard\000UbtPcCutBackReception\000Ub"
        "tAppTurnBack\000UbtGmeVoiceBack\000";
    static const int32_t values[] = {
        PB3UserBehaviorsType_UbtZero,
        PB3UserBehaviorsType_UbtAppOperationScreen,
        PB3UserBehaviorsType_UbtAppCutBackReception,
        PB3UserBehaviorsType_UbtPcOperationMouse,
        PB3UserBehaviorsType_UbtPcOperationKeyboard,
        PB3UserBehaviorsType_UbtPcCutBackReception,
        PB3UserBehaviorsType_UbtAppTurnBack,
        PB3UserBehaviorsType_UbtGmeVoiceBack,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3UserBehaviorsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3UserBehaviorsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3UserBehaviorsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3UserBehaviorsType_UbtZero:
    case PB3UserBehaviorsType_UbtAppOperationScreen:
    case PB3UserBehaviorsType_UbtAppCutBackReception:
    case PB3UserBehaviorsType_UbtPcOperationMouse:
    case PB3UserBehaviorsType_UbtPcOperationKeyboard:
    case PB3UserBehaviorsType_UbtPcCutBackReception:
    case PB3UserBehaviorsType_UbtAppTurnBack:
    case PB3UserBehaviorsType_UbtGmeVoiceBack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CompositeSearchType

GPBEnumDescriptor *PB3CompositeSearchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CstNone\000CstRoom\000CstPlayer\000";
    static const int32_t values[] = {
        PB3CompositeSearchType_CstNone,
        PB3CompositeSearchType_CstRoom,
        PB3CompositeSearchType_CstPlayer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CompositeSearchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CompositeSearchType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CompositeSearchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CompositeSearchType_CstNone:
    case PB3CompositeSearchType_CstRoom:
    case PB3CompositeSearchType_CstPlayer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ReqCustomerType

GPBEnumDescriptor *PB3ReqCustomerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RctNone\000RctBlackWhale\000";
    static const int32_t values[] = {
        PB3ReqCustomerType_RctNone,
        PB3ReqCustomerType_RctBlackWhale,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ReqCustomerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ReqCustomerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ReqCustomerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ReqCustomerType_RctNone:
    case PB3ReqCustomerType_RctBlackWhale:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AdminHandleYoungModelType

GPBEnumDescriptor *PB3AdminHandleYoungModelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AhymtNone\000AhymtOpen\000AhymtClose\000";
    static const int32_t values[] = {
        PB3AdminHandleYoungModelType_AhymtNone,
        PB3AdminHandleYoungModelType_AhymtOpen,
        PB3AdminHandleYoungModelType_AhymtClose,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AdminHandleYoungModelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AdminHandleYoungModelType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AdminHandleYoungModelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AdminHandleYoungModelType_AhymtNone:
    case PB3AdminHandleYoungModelType_AhymtOpen:
    case PB3AdminHandleYoungModelType_AhymtClose:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3GetIndexTabReq

@implementation PB3GetIndexTabReq


typedef struct PB3GetIndexTabReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetIndexTabReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetIndexTabReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetIndexTabReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetIndexTabRes

@implementation PB3GetIndexTabRes

@dynamic tabsArray, tabsArray_Count;

typedef struct PB3GetIndexTabRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabsArray;
} PB3GetIndexTabRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetIndexTabRes_FieldNumber_TabsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetIndexTabRes__storage_, tabsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetIndexTabRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetIndexTabRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetHotSearchWordReq

@implementation PB3GetHotSearchWordReq


typedef struct PB3GetHotSearchWordReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetHotSearchWordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetHotSearchWordReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetHotSearchWordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetHotSearchWordRes

@implementation PB3GetHotSearchWordRes

@dynamic hotSearchWordArray, hotSearchWordArray_Count;

typedef struct PB3GetHotSearchWordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hotSearchWordArray;
} PB3GetHotSearchWordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotSearchWordArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetHotSearchWordRes_FieldNumber_HotSearchWordArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetHotSearchWordRes__storage_, hotSearchWordArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetHotSearchWordRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetHotSearchWordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TabListReq

@implementation PB3TabListReq

@dynamic tab;
@dynamic position;
@dynamic keyWord;
@dynamic sex;
@dynamic page;
@dynamic pageSize;
@dynamic mid;

typedef struct PB3TabListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3IndexTab tab;
  int32_t position;
  int32_t sex;
  int32_t page;
  int32_t pageSize;
  int32_t mid;
  NSString *keyWord;
} PB3TabListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3TabListReq_FieldNumber_Tab,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_KeyWord,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, keyWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Page,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_PageSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Mid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TabListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TabListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TabListReq_Tab_RawValue(PB3TabListReq *message) {
  GPBDescriptor *descriptor = [PB3TabListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListReq_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TabListReq_Tab_RawValue(PB3TabListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TabListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListReq_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TabListRes

@implementation PB3TabListRes

@dynamic listArray, listArray_Count;
@dynamic mid;
@dynamic name;
@dynamic page;
@dynamic position;
@dynamic tab;
@dynamic sex;

typedef struct PB3TabListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t page;
  int32_t position;
  PB3IndexTab tab;
  int32_t sex;
  NSMutableArray *listArray;
  NSString *name;
} PB3TabListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3TabListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Position,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3TabListRes_FieldNumber_Tab,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TabListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TabListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TabListRes_Tab_RawValue(PB3TabListRes *message) {
  GPBDescriptor *descriptor = [PB3TabListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListRes_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TabListRes_Tab_RawValue(PB3TabListRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TabListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListRes_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3Recommend

@implementation PB3Recommend

@dynamic mid;
@dynamic sex;

typedef struct PB3Recommend__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t sex;
} PB3Recommend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3Recommend_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Recommend__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3Recommend_FieldNumber_Sex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Recommend__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Recommend class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Recommend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserDefineReq

@implementation PB3UserDefineReq

@dynamic tab;
@dynamic recommendsArray, recommendsArray_Count;

typedef struct PB3UserDefineReq__storage_ {
  uint32_t _has_storage_[1];
  PB3IndexTab tab;
  NSMutableArray *recommendsArray;
} PB3UserDefineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3UserDefineReq_FieldNumber_Tab,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDefineReq__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recommendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Recommend),
        .number = PB3UserDefineReq_FieldNumber_RecommendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefineReq__storage_, recommendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefineReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserDefineReq_Tab_RawValue(PB3UserDefineReq *message) {
  GPBDescriptor *descriptor = [PB3UserDefineReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDefineReq_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserDefineReq_Tab_RawValue(PB3UserDefineReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserDefineReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDefineReq_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserDefineRes

@implementation PB3UserDefineRes

@dynamic userDefineArray, userDefineArray_Count;

typedef struct PB3UserDefineRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userDefineArray;
} PB3UserDefineRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userDefineArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserDefined),
        .number = PB3UserDefineRes_FieldNumber_UserDefineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefineRes__storage_, userDefineArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefineRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefineRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserDefined

@implementation PB3UserDefined

@dynamic mid;
@dynamic name;
@dynamic listArray, listArray_Count;
@dynamic sex;

typedef struct PB3UserDefined__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t sex;
  NSString *name;
  NSMutableArray *listArray;
} PB3UserDefined__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3UserDefined_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefined class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefined__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAppAdConfigReq

@implementation PB3GetAppAdConfigReq

@dynamic version;
@dynamic system;

typedef struct PB3GetAppAdConfigReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSString *system;
} PB3GetAppAdConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigReq_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigReq__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "system",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigReq_FieldNumber_System,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigReq__storage_, system),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAppAdConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAppAdConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAppAdConfigRes

@implementation PB3GetAppAdConfigRes

@dynamic name;
@dynamic duration;
@dynamic URL;
@dynamic image;
@dynamic title;
@dynamic soundURL;
@dynamic video;
@dynamic coverURL;
@dynamic miniImage;
@dynamic loginImage;
@dynamic loginMiniImage;
@dynamic loginVideo;
@dynamic loginCoverURL;
@dynamic loginIsShow;
@dynamic endTime;
@dynamic loginEndTime;
@dynamic videoTrancode;
@dynamic loginVideoTrancode;

typedef struct PB3GetAppAdConfigRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  int32_t loginIsShow;
  NSString *name;
  NSString *URL;
  NSString *image;
  NSString *title;
  NSString *soundURL;
  NSString *video;
  NSString *coverURL;
  NSString *miniImage;
  NSString *loginImage;
  NSString *loginMiniImage;
  NSString *loginVideo;
  NSString *loginCoverURL;
  NSString *videoTrancode;
  NSString *loginVideoTrancode;
  int64_t endTime;
  int64_t loginEndTime;
} PB3GetAppAdConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "soundURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_SoundURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, soundURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_Video,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_CoverURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "miniImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_MiniImage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, miniImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginImage,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginMiniImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginMiniImage,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginMiniImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginVideo",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginVideo,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginVideo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginCoverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginCoverURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginCoverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginIsShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginIsShow,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginIsShow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_EndTime,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "loginEndTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginEndTime,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginEndTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "videoTrancode",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_VideoTrancode,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, videoTrancode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginVideoTrancode",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAppAdConfigRes_FieldNumber_LoginVideoTrancode,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, loginVideoTrancode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAppAdConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAppAdConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\003!!!\000\006\005\241!!\000\010\005\241!!\000\r\005\245\241!!\000\020E\243\244\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBannerReq

@implementation PB3IndexBannerReq

@dynamic language;

typedef struct PB3IndexBannerReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t language;
} PB3IndexBannerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerReq_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBannerReq__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBannerReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBannerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBanner

@implementation PB3IndexBanner

@dynamic name;
@dynamic bannerURL;
@dynamic tranType;
@dynamic tranURL;
@dynamic shareType;
@dynamic shareTitle;
@dynamic shareContent;
@dynamic shareImg;

typedef struct PB3IndexBanner__storage_ {
  uint32_t _has_storage_[1];
  int32_t tranType;
  int32_t shareType;
  NSString *name;
  NSString *bannerURL;
  NSString *tranURL;
  NSString *shareTitle;
  NSString *shareContent;
  NSString *shareImg;
} PB3IndexBanner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bannerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_BannerURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, bannerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tranType",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_TranType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, tranType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tranURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_TranURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, tranURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareType",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shareTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareTitle,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareImg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBanner class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBanner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\006\241!!\000\004\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBannerRes

@implementation PB3IndexBannerRes

@dynamic flag;
@dynamic language;
@dynamic listArray, listArray_Count;

typedef struct PB3IndexBannerRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t flag;
  int32_t language;
  NSMutableArray *listArray;
} PB3IndexBannerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerRes_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexBanner),
        .number = PB3IndexBannerRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBannerRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBannerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClickCountReq

@implementation PB3ClickCountReq

@dynamic clickType;
@dynamic deviceId;
@dynamic mid;

typedef struct PB3ClickCountReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ClickType clickType;
  int32_t mid;
  NSString *deviceId;
} PB3ClickCountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clickType",
        .dataTypeSpecific.enumDescFunc = PB3ClickType_EnumDescriptor,
        .number = PB3ClickCountReq_FieldNumber_ClickType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, clickType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickCountReq_FieldNumber_DeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickCountReq_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickCountReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClickCountReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClickCountReq_ClickType_RawValue(PB3ClickCountReq *message) {
  GPBDescriptor *descriptor = [PB3ClickCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickCountReq_FieldNumber_ClickType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClickCountReq_ClickType_RawValue(PB3ClickCountReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClickCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickCountReq_FieldNumber_ClickType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClickCountRes

@implementation PB3ClickCountRes


typedef struct PB3ClickCountRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClickCountRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickCountRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClickCountRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoomReq

@implementation PB3SearchRoomReq

@dynamic name;
@dynamic page;

typedef struct PB3SearchRoomReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *name;
} PB3SearchRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoomReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchRoomReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoomReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchRoomReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoomReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoomRes

@implementation PB3SearchRoomRes

@dynamic listArray, listArray_Count;

typedef struct PB3SearchRoomRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SearchRoomRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3SearchRoomRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchRoomRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoomRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoomRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoom

@implementation PB3SearchRoom

@dynamic name;
@dynamic page;
@dynamic listArray, listArray_Count;

typedef struct PB3SearchRoom__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *name;
  NSMutableArray *listArray;
} PB3SearchRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoom_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoom_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3SearchRoom_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoom class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckMaintainReq

@implementation PB3CheckMaintainReq


typedef struct PB3CheckMaintainReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckMaintainReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckMaintainReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckMaintainReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckMaintainRes

@implementation PB3CheckMaintainRes


typedef struct PB3CheckMaintainRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckMaintainRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckMaintainRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckMaintainRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetActivityRoomReq

@implementation PB3GetActivityRoomReq


typedef struct PB3GetActivityRoomReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetActivityRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityRoomReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetActivityRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetActivityRoomRes

@implementation PB3GetActivityRoomRes

@dynamic roomIdArray, roomIdArray_Count;
@dynamic chatInterval;

typedef struct PB3GetActivityRoomRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t chatInterval;
  GPBInt64Array *roomIdArray;
} PB3GetActivityRoomRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetActivityRoomRes_FieldNumber_RoomIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetActivityRoomRes__storage_, roomIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chatInterval",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetActivityRoomRes_FieldNumber_ChatInterval,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetActivityRoomRes__storage_, chatInterval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityRoomRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetActivityRoomRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastActivityRoom

@implementation PB3BroadcastActivityRoom

@dynamic hasInfo, info;

typedef struct PB3BroadcastActivityRoom__storage_ {
  uint32_t _has_storage_[1];
  PB3GetActivityRoomRes *info;
} PB3BroadcastActivityRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GetActivityRoomRes),
        .number = PB3BroadcastActivityRoom_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastActivityRoom__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastActivityRoom class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastActivityRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RankDetail

@implementation PB3RankDetail

@dynamic rankArray, rankArray_Count;
@dynamic hasMy, my;

typedef struct PB3RankDetail__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rankArray;
  PB3Rank *my;
} PB3RankDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Rank),
        .number = PB3RankDetail_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RankDetail__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "my",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Rank),
        .number = PB3RankDetail_FieldNumber_My,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RankDetail__storage_, my),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RankDetail class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RankDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRankReq

@implementation PB3GetRankReq

@dynamic type;
@dynamic playerId;
@dynamic sex;
@dynamic genderShow;

typedef struct PB3GetRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3RankType type;
  PB3SexType sex;
  PB3SexType genderShow;
  int64_t playerId;
} PB3GetRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RankType_EnumDescriptor,
        .number = PB3GetRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3GetRankReq_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "genderShow",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3GetRankReq_FieldNumber_GenderShow,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, genderShow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetRankReq_Type_RawValue(PB3GetRankReq *message) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetRankReq_Type_RawValue(PB3GetRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3GetRankReq_Sex_RawValue(PB3GetRankReq *message) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetRankReq_Sex_RawValue(PB3GetRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3GetRankReq_GenderShow_RawValue(PB3GetRankReq *message) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_GenderShow];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetRankReq_GenderShow_RawValue(PB3GetRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_GenderShow];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetRankRes

@implementation PB3GetRankRes

@dynamic rankType;
@dynamic hasDay, day;
@dynamic hasWeek, week;
@dynamic hasTotal, total;
@dynamic hasManHour, manHour;
@dynamic hasGirlHour, girlHour;
@dynamic reloadTime;
@dynamic hasMonth, month;
@dynamic hasYear, year;

typedef struct PB3GetRankRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t rankType;
  PB3RankDetail *day;
  PB3RankDetail *week;
  PB3RankDetail *total;
  PB3RankDetail *manHour;
  PB3RankDetail *girlHour;
  PB3RankDetail *month;
  PB3RankDetail *year;
  int64_t reloadTime;
} PB3GetRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankRes_FieldNumber_RankType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, rankType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Day,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "week",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Week,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, week),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Total,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "manHour",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_ManHour,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, manHour),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "girlHour",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_GirlHour,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, girlHour),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reloadTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankRes_FieldNumber_ReloadTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, reloadTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "month",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Month,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, month),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "year",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Year,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, year),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGiftRankReq

@implementation PB3GetGiftRankReq

@dynamic giftId;
@dynamic playerId;

typedef struct PB3GetGiftRankReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t giftId;
  int64_t playerId;
} PB3GetGiftRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGiftRankReq_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGiftRankReq__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGiftRankReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetGiftRankReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGiftRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGiftRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGiftRankRes

@implementation PB3GetGiftRankRes

@dynamic hasGiftRank, giftRank;

typedef struct PB3GetGiftRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RankDetail *giftRank;
} PB3GetGiftRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftRank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetGiftRankRes_FieldNumber_GiftRank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGiftRankRes__storage_, giftRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGiftRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGiftRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoadClickRep

@implementation PB3LoadClickRep

@dynamic type;
@dynamic isLoad;

typedef struct PB3LoadClickRep__storage_ {
  uint32_t _has_storage_[1];
  PB3LoadClickType type;
} PB3LoadClickRep__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3LoadClickType_EnumDescriptor,
        .number = PB3LoadClickRep_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoadClickRep__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isLoad",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoadClickRep_FieldNumber_IsLoad,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoadClickRep class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoadClickRep__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LoadClickRep_Type_RawValue(PB3LoadClickRep *message) {
  GPBDescriptor *descriptor = [PB3LoadClickRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoadClickRep_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LoadClickRep_Type_RawValue(PB3LoadClickRep *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LoadClickRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoadClickRep_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LoadClickRes

@implementation PB3LoadClickRes


typedef struct PB3LoadClickRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LoadClickRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoadClickRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LoadClickRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetYoungModelReq

@implementation PB3GetYoungModelReq

@dynamic playerId;

typedef struct PB3GetYoungModelReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetYoungModelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetYoungModelReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetYoungModelReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetYoungModelReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetYoungModelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelReq

@implementation PB3YoungModelReq

@dynamic playerId;

typedef struct PB3YoungModelReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3YoungModelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModel

@implementation PB3YoungModel

@dynamic msg;
@dynamic isPwd;
@dynamic isOpen;
@dynamic onlineTime;
@dynamic dayMaxTime;
@dynamic startTime;
@dynamic endTime;
@dynamic isLimitTime;
@dynamic adminOptType;
@dynamic showDialog;

typedef struct PB3YoungModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t onlineTime;
  int32_t dayMaxTime;
  PB3AdminHandleYoungModelType adminOptType;
  NSString *msg;
  NSString *startTime;
  NSString *endTime;
} PB3YoungModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsPwd,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsOpen,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "onlineTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_OnlineTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, onlineTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dayMaxTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_DayMaxTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, dayMaxTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_StartTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_EndTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isLimitTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsLimitTime,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "adminOptType",
        .dataTypeSpecific.enumDescFunc = PB3AdminHandleYoungModelType_EnumDescriptor,
        .number = PB3YoungModel_FieldNumber_AdminOptType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, adminOptType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "showDialog",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_ShowDialog,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModel class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModel_AdminOptType_RawValue(PB3YoungModel *message) {
  GPBDescriptor *descriptor = [PB3YoungModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModel_FieldNumber_AdminOptType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModel_AdminOptType_RawValue(PB3YoungModel *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModel_FieldNumber_AdminOptType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelRes

@implementation PB3YoungModelRes

@dynamic hasModel, model;

typedef struct PB3YoungModelRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModel *model;
} PB3YoungModelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "model",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3YoungModel),
        .number = PB3YoungModelRes_FieldNumber_Model,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelRes__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelPwdReq

@implementation PB3YoungModelPwdReq

@dynamic type;
@dynamic pwd;
@dynamic originalPwd;

typedef struct PB3YoungModelPwdReq__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPwdType type;
  NSString *pwd;
  NSString *originalPwd;
} PB3YoungModelPwdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPwdType_EnumDescriptor,
        .number = PB3YoungModelPwdReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPwdReq_FieldNumber_Pwd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalPwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPwdReq_FieldNumber_OriginalPwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, originalPwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPwdReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPwdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPwdReq_Type_RawValue(PB3YoungModelPwdReq *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPwdReq_Type_RawValue(PB3YoungModelPwdReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPwdRes

@implementation PB3YoungModelPwdRes

@dynamic type;

typedef struct PB3YoungModelPwdRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPwdType type;
} PB3YoungModelPwdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPwdType_EnumDescriptor,
        .number = PB3YoungModelPwdRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPwdRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPwdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPwdRes_Type_RawValue(PB3YoungModelPwdRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPwdRes_Type_RawValue(PB3YoungModelPwdRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPhoneReq

@implementation PB3YoungModelPhoneReq

@dynamic type;
@dynamic code;

typedef struct PB3YoungModelPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPhoneType type;
  NSString *code;
} PB3YoungModelPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPhoneType_EnumDescriptor,
        .number = PB3YoungModelPhoneReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPhoneReq_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPhoneReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPhoneReq_Type_RawValue(PB3YoungModelPhoneReq *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPhoneReq_Type_RawValue(PB3YoungModelPhoneReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPhoneRes

@implementation PB3YoungModelPhoneRes

@dynamic type;
@dynamic phone;

typedef struct PB3YoungModelPhoneRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPhoneType type;
  NSString *phone;
} PB3YoungModelPhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPhoneType_EnumDescriptor,
        .number = PB3YoungModelPhoneRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPhoneRes_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPhoneRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPhoneRes_Type_RawValue(PB3YoungModelPhoneRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPhoneRes_Type_RawValue(PB3YoungModelPhoneRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelStatusReq

@implementation PB3YoungModelStatusReq


typedef struct PB3YoungModelStatusReq__storage_ {
  uint32_t _has_storage_[1];
} PB3YoungModelStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelStatusReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3YoungModelStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelStatusRes

@implementation PB3YoungModelStatusRes

@dynamic type;

typedef struct PB3YoungModelStatusRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPageType type;
} PB3YoungModelStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPageType_EnumDescriptor,
        .number = PB3YoungModelStatusRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelStatusRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelStatusRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelStatusRes_Type_RawValue(PB3YoungModelStatusRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelStatusRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelStatusRes_Type_RawValue(PB3YoungModelStatusRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelStatusRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarChampion

@implementation PB3WeekStarChampion

@dynamic id_p;
@dynamic id2;
@dynamic name;
@dynamic charm;
@dynamic icon;
@dynamic remark;

typedef struct PB3WeekStarChampion__storage_ {
  uint32_t _has_storage_[1];
  uint32_t charm;
  NSString *name;
  NSString *icon;
  NSString *remark;
  int64_t id_p;
  int64_t id2;
} PB3WeekStarChampion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Charm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarChampion class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarChampion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarData

@implementation PB3WeekStarData

@dynamic id_p;
@dynamic id2;
@dynamic name;
@dynamic charm;
@dynamic icon;
@dynamic remark;
@dynamic sex;
@dynamic level;
@dynamic value;
@dynamic gapVal;

typedef struct PB3WeekStarData__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  int32_t level;
  NSString *name;
  NSString *icon;
  NSString *remark;
  int64_t id_p;
  int64_t id2;
  int64_t charm;
  int64_t value;
  int64_t gapVal;
} PB3WeekStarData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Charm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3WeekStarData_FieldNumber_Sex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Level,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Value,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "gapVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_GapVal,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, gapVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarData class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarData_Sex_RawValue(PB3WeekStarData *message) {
  GPBDescriptor *descriptor = [PB3WeekStarData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarData_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarData_Sex_RawValue(PB3WeekStarData *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarData_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StarRank

@implementation PB3StarRank

@dynamic type;
@dynamic rankArray, rankArray_Count;
@dynamic id_p;
@dynamic myVal;
@dynamic myRank;
@dynamic icon;
@dynamic name;
@dynamic timeNow;
@dynamic timeEnd;
@dynamic keepNo1PlayerId;
@dynamic keepNo1PlayerName;
@dynamic keepNo1Num;
@dynamic oldKeepNo1PlayerName;
@dynamic keepNo1ShowType;

typedef struct PB3StarRank__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
  int32_t myRank;
  PB3KeepNo1ShowType keepNo1ShowType;
  NSMutableArray *rankArray;
  NSString *icon;
  NSString *name;
  NSString *keepNo1PlayerName;
  NSString *oldKeepNo1PlayerName;
  int64_t id_p;
  int64_t myVal;
  int64_t timeNow;
  int64_t timeEnd;
  int64_t keepNo1PlayerId;
  int64_t keepNo1Num;
} PB3StarRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3StarRank_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarData),
        .number = PB3StarRank_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "myVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_MyVal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, myVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "myRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_MyRank,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, myRank),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeNow",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_TimeNow,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, timeNow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_TimeEnd,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, timeEnd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "keepNo1PlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_KeepNo1PlayerId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, keepNo1PlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "keepNo1PlayerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_KeepNo1PlayerName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, keepNo1PlayerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keepNo1Num",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_KeepNo1Num,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, keepNo1Num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "oldKeepNo1PlayerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_OldKeepNo1PlayerName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, oldKeepNo1PlayerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keepNo1ShowType",
        .dataTypeSpecific.enumDescFunc = PB3KeepNo1ShowType_EnumDescriptor,
        .number = PB3StarRank_FieldNumber_KeepNo1ShowType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, keepNo1ShowType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StarRank class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StarRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\004\005\000\005\006\000\010\007\000\t\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StarRank_Type_RawValue(PB3StarRank *message) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StarRank_Type_RawValue(PB3StarRank *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3StarRank_KeepNo1ShowType_RawValue(PB3StarRank *message) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_KeepNo1ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StarRank_KeepNo1ShowType_RawValue(PB3StarRank *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_KeepNo1ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekNum

@implementation PB3WeekNum

@dynamic num;

typedef struct PB3WeekNum__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB3WeekNum__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekNum_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekNum__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNum class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekNum__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarSpecialGift

@implementation PB3WeekStarSpecialGift

@dynamic giftId;
@dynamic giftName;
@dynamic giftPrice;
@dynamic giftIcon;

typedef struct PB3WeekStarSpecialGift__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t giftPrice;
  NSString *giftName;
  NSString *giftIcon;
} PB3WeekStarSpecialGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarSpecialGift class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarSpecialGift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRankReq

@implementation PB3WeekStarRankReq

@dynamic type;

typedef struct PB3WeekStarRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarRankReq_Type_RawValue(PB3WeekStarRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarRankReq_Type_RawValue(PB3WeekStarRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarRankRes

@implementation PB3WeekStarRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarFansRankReq

@implementation PB3WeekStarFansRankReq

@dynamic type;

typedef struct PB3WeekStarFansRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarFansRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarFansRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarFansRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarFansRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarFansRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarFansRankReq_Type_RawValue(PB3WeekStarFansRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarFansRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarFansRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarFansRankReq_Type_RawValue(PB3WeekStarFansRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarFansRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarFansRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarFansRankRes

@implementation PB3WeekStarFansRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarFansRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarFansRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarFansRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarFansRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarFansRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarFansRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRoomRankReq

@implementation PB3WeekStarRoomRankReq

@dynamic type;

typedef struct PB3WeekStarRoomRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarRoomRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarRoomRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRoomRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRoomRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRoomRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarRoomRankReq_Type_RawValue(PB3WeekStarRoomRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarRoomRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRoomRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarRoomRankReq_Type_RawValue(PB3WeekStarRoomRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarRoomRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRoomRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarRoomRankRes

@implementation PB3WeekStarRoomRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarRoomRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarRoomRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarRoomRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRoomRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRoomRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRoomRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarReq

@implementation PB3WeekStarReq


typedef struct PB3WeekStarReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WeekStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WeekStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRes

@implementation PB3WeekStarRes

@dynamic hasStar, star;

typedef struct PB3WeekStarRes__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarData *star;
} PB3WeekStarRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "star",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarData),
        .number = PB3WeekStarRes_FieldNumber_Star,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRes__storage_, star),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekGiftReq

@implementation PB3WeekGiftReq

@dynamic type;

typedef struct PB3WeekGiftReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekGiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekGiftReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekGiftReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekGiftReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekGiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekGiftReq_Type_RawValue(PB3WeekGiftReq *message) {
  GPBDescriptor *descriptor = [PB3WeekGiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekGiftReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekGiftReq_Type_RawValue(PB3WeekGiftReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekGiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekGiftReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekGiftRes

@implementation PB3WeekGiftRes

@dynamic giftArray, giftArray_Count;
@dynamic specialGiftsArray, specialGiftsArray_Count;

typedef struct PB3WeekGiftRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *giftArray;
  NSMutableArray *specialGiftsArray;
} PB3WeekGiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekGiftRes_FieldNumber_GiftArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeekGiftRes__storage_, giftArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "specialGiftsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarSpecialGift),
        .number = PB3WeekGiftRes_FieldNumber_SpecialGiftsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeekGiftRes__storage_, specialGiftsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekGiftRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekGiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekNumReq

@implementation PB3WeekNumReq


typedef struct PB3WeekNumReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WeekNumReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNumReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WeekNumReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekNumRes

@implementation PB3WeekNumRes

@dynamic num;

typedef struct PB3WeekNumRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB3WeekNumRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekNumRes_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekNumRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNumRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekNumRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SubInfo

@implementation PB3SubInfo

@dynamic name;
@dynamic URL;
@dynamic location;
@dynamic backgroundImg;
@dynamic pcBackgroundImg;
@dynamic weight;
@dynamic startTime;
@dynamic endTime;
@dynamic roomsubinfoShow;
@dynamic playerPageURL;
@dynamic slipFrequency;
@dynamic actId;
@dynamic androidVerMin;
@dynamic androidVerMax;
@dynamic iosVerMax;
@dynamic iosVerMin;
@dynamic pcVerMin;
@dynamic pcVerMax;
@dynamic wealthLevelMin;
@dynamic wealthLevelMax;
@dynamic charmLevelMin;
@dynamic charmLevelMax;
@dynamic andOr;
@dynamic blacklist;
@dynamic registerTimeLimit;
@dynamic registerDayLimit;
@dynamic openRegisterTime;
@dynamic registerTimeLimitType;
@dynamic rankText;
@dynamic scoreText;
@dynamic hasActData, actData;
@dynamic showPattern, showPattern_Count;
@dynamic applicationsArray, applicationsArray_Count;

typedef struct PB3SubInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t location;
  int32_t weight;
  int32_t roomsubinfoShow;
  int32_t slipFrequency;
  int32_t actId;
  int32_t wealthLevelMin;
  int32_t wealthLevelMax;
  int32_t charmLevelMin;
  int32_t charmLevelMax;
  int32_t andOr;
  int32_t registerDayLimit;
  int32_t registerTimeLimitType;
  NSString *name;
  NSString *URL;
  NSString *backgroundImg;
  NSString *pcBackgroundImg;
  NSString *playerPageURL;
  NSString *androidVerMin;
  NSString *androidVerMax;
  NSString *iosVerMax;
  NSString *iosVerMin;
  NSString *pcVerMin;
  NSString *pcVerMax;
  NSString *blacklist;
  NSString *registerTimeLimit;
  NSString *rankText;
  NSString *scoreText;
  PB3SubInfoActivity *actData;
  GPBInt32BoolDictionary *showPattern;
  NSMutableArray *applicationsArray;
  int64_t startTime;
  int64_t endTime;
  int64_t openRegisterTime;
} PB3SubInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Location,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_BackgroundImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, backgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBackgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcBackgroundImg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcBackgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Weight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_StartTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_EndTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomsubinfoShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RoomsubinfoShow,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, roomsubinfoShow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerPageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PlayerPageURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, playerPageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slipFrequency",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_SlipFrequency,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, slipFrequency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_ActId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, actId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "androidVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndroidVerMin,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, androidVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndroidVerMax,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, androidVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_IosVerMax,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, iosVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_IosVerMin,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, iosVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcVerMin,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcVerMax,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wealthLevelMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_WealthLevelMin,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, wealthLevelMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevelMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_WealthLevelMax,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, wealthLevelMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevelMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_CharmLevelMin,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, charmLevelMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevelMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_CharmLevelMax,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, charmLevelMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "andOr",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndOr,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, andOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Blacklist,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, blacklist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "registerTimeLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RegisterTimeLimit,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, registerTimeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "registerDayLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RegisterDayLimit,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, registerDayLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "openRegisterTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_OpenRegisterTime,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, openRegisterTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "registerTimeLimitType",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RegisterTimeLimitType,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, registerTimeLimitType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rankText",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RankText,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, rankText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scoreText",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_ScoreText,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, scoreText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actData",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SubInfoActivity),
        .number = PB3SubInfo_FieldNumber_ActData,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, actData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showPattern",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_ShowPattern,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, showPattern),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "applicationsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_ApplicationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, applicationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SubInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002!!!\000\n\006\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SubInfoActivity

@implementation PB3SubInfoActivity

@dynamic actType;
@dynamic actData;

typedef struct PB3SubInfoActivity__storage_ {
  uint32_t _has_storage_[1];
  PB3SubInfoActivityType actType;
  NSData *actData;
} PB3SubInfoActivity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actType",
        .dataTypeSpecific.enumDescFunc = PB3SubInfoActivityType_EnumDescriptor,
        .number = PB3SubInfoActivity_FieldNumber_ActType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SubInfoActivity__storage_, actType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "actData",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfoActivity_FieldNumber_ActData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SubInfoActivity__storage_, actData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubInfoActivity class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SubInfoActivity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SubInfoActivity_ActType_RawValue(PB3SubInfoActivity *message) {
  GPBDescriptor *descriptor = [PB3SubInfoActivity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SubInfoActivity_FieldNumber_ActType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SubInfoActivity_ActType_RawValue(PB3SubInfoActivity *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SubInfoActivity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SubInfoActivity_FieldNumber_ActType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SubInfoCountDown

@implementation PB3SubInfoCountDown

@dynamic curStatus;
@dynamic remainTime;

typedef struct PB3SubInfoCountDown__storage_ {
  uint32_t _has_storage_[1];
  PB3RedEnvelopeStatus curStatus;
  int64_t remainTime;
} PB3SubInfoCountDown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "curStatus",
        .dataTypeSpecific.enumDescFunc = PB3RedEnvelopeStatus_EnumDescriptor,
        .number = PB3SubInfoCountDown_FieldNumber_CurStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SubInfoCountDown__storage_, curStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "remainTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfoCountDown_FieldNumber_RemainTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SubInfoCountDown__storage_, remainTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubInfoCountDown class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SubInfoCountDown__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SubInfoCountDown_CurStatus_RawValue(PB3SubInfoCountDown *message) {
  GPBDescriptor *descriptor = [PB3SubInfoCountDown descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SubInfoCountDown_FieldNumber_CurStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SubInfoCountDown_CurStatus_RawValue(PB3SubInfoCountDown *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SubInfoCountDown descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SubInfoCountDown_FieldNumber_CurStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ListSubInfoReq

@implementation PB3ListSubInfoReq

@dynamic reqFromType;

typedef struct PB3ListSubInfoReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ReqFromType reqFromType;
} PB3ListSubInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reqFromType",
        .dataTypeSpecific.enumDescFunc = PB3ReqFromType_EnumDescriptor,
        .number = PB3ListSubInfoReq_FieldNumber_ReqFromType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ListSubInfoReq__storage_, reqFromType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListSubInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListSubInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ListSubInfoReq_ReqFromType_RawValue(PB3ListSubInfoReq *message) {
  GPBDescriptor *descriptor = [PB3ListSubInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ListSubInfoReq_FieldNumber_ReqFromType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ListSubInfoReq_ReqFromType_RawValue(PB3ListSubInfoReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ListSubInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ListSubInfoReq_FieldNumber_ReqFromType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ListSubInfoRes

@implementation PB3ListSubInfoRes

@dynamic listArray, listArray_Count;

typedef struct PB3ListSubInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListSubInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SubInfo),
        .number = PB3ListSubInfoRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListSubInfoRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListSubInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListSubInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAdActiveReq

@implementation PB3GetAdActiveReq

@dynamic adChannel;
@dynamic adType;
@dynamic idfa;
@dynamic androidId;
@dynamic imei;
@dynamic mac;
@dynamic eventType;
@dynamic deviceId;
@dynamic oaid;
@dynamic adToken;
@dynamic extends, extends_Count;

typedef struct PB3GetAdActiveReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t adChannel;
  int32_t adType;
  PB3AdEventType eventType;
  NSString *idfa;
  NSString *androidId;
  NSString *imei;
  NSString *mac;
  NSString *deviceId;
  NSString *oaid;
  NSString *adToken;
  NSMutableDictionary *extends;
} PB3GetAdActiveReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "adChannel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdChannel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idfa",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Idfa,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, idfa),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AndroidId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, androidId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Imei,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, imei),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mac",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Mac,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, mac),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventType",
        .dataTypeSpecific.enumDescFunc = PB3AdEventType_EnumDescriptor,
        .number = PB3GetAdActiveReq_FieldNumber_EventType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_DeviceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Oaid,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, oaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdToken,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extends",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Extends,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, extends),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAdActiveReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAdActiveReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetAdActiveReq_EventType_RawValue(PB3GetAdActiveReq *message) {
  GPBDescriptor *descriptor = [PB3GetAdActiveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetAdActiveReq_FieldNumber_EventType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetAdActiveReq_EventType_RawValue(PB3GetAdActiveReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetAdActiveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetAdActiveReq_FieldNumber_EventType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetAdActiveRes

@implementation PB3GetAdActiveRes


typedef struct PB3GetAdActiveRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAdActiveRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAdActiveRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAdActiveRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadClientLogReq

@implementation PB3UploadClientLogReq

@dynamic URL;
@dynamic text;
@dynamic clientInfo;
@dynamic playerId;
@dynamic appId;
@dynamic contactWay;
@dynamic version;
@dynamic operatorId;
@dynamic operatorName;
@dynamic reason;

typedef struct PB3UploadClientLogReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *text;
  NSString *clientInfo;
  NSString *contactWay;
  NSString *version;
  NSString *operatorName;
  NSString *reason;
  int64_t playerId;
  int64_t appId;
  int64_t operatorId;
} PB3UploadClientLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_ClientInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, clientInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_PlayerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "appId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_AppId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, appId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "contactWay",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_ContactWay,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, contactWay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_Version,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "operatorId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_OperatorId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, operatorId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "operatorName",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_OperatorName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, operatorName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_Reason,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadClientLogReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadClientLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadClientLogRes

@implementation PB3UploadClientLogRes


typedef struct PB3UploadClientLogRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UploadClientLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadClientLogRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UploadClientLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTimestampReq

@implementation PB3GetTimestampReq


typedef struct PB3GetTimestampReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetTimestampReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTimestampReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetTimestampReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTimestampRes

@implementation PB3GetTimestampRes

@dynamic current;
@dynamic currentTime;

typedef struct PB3GetTimestampRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *currentTime;
  int64_t current;
} PB3GetTimestampRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "current",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTimestampRes_FieldNumber_Current,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetTimestampRes__storage_, current),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "currentTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTimestampRes_FieldNumber_CurrentTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetTimestampRes__storage_, currentTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTimestampRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetTimestampRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HistoryWeekStarReq

@implementation PB3HistoryWeekStarReq

@dynamic page;
@dynamic pageSize;
@dynamic weekStarRankType;

typedef struct PB3HistoryWeekStarReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
  PB3WeekStarRankType weekStarRankType;
} PB3HistoryWeekStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weekStarRankType",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarRankType_EnumDescriptor,
        .number = PB3HistoryWeekStarReq_FieldNumber_WeekStarRankType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarReq__storage_, weekStarRankType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryWeekStarReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HistoryWeekStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3HistoryWeekStarReq_WeekStarRankType_RawValue(PB3HistoryWeekStarReq *message) {
  GPBDescriptor *descriptor = [PB3HistoryWeekStarReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HistoryWeekStarReq_FieldNumber_WeekStarRankType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HistoryWeekStarReq_WeekStarRankType_RawValue(PB3HistoryWeekStarReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HistoryWeekStarReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HistoryWeekStarReq_FieldNumber_WeekStarRankType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3HistoryWeekStarRes

@implementation PB3HistoryWeekStarRes

@dynamic weekStarsArray, weekStarsArray_Count;
@dynamic total;

typedef struct PB3HistoryWeekStarRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *weekStarsArray;
  int64_t total;
} PB3HistoryWeekStarRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "weekStarsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3OldWeekStar),
        .number = PB3HistoryWeekStarRes_FieldNumber_WeekStarsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarRes__storage_, weekStarsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryWeekStarRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HistoryWeekStarRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HistoryTopWeekStarReq

@implementation PB3HistoryTopWeekStarReq


typedef struct PB3HistoryTopWeekStarReq__storage_ {
  uint32_t _has_storage_[1];
} PB3HistoryTopWeekStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryTopWeekStarReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3HistoryTopWeekStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HistoryTopWeekStarRes

@implementation PB3HistoryTopWeekStarRes

@dynamic weekStarTopId;
@dynamic weekStarTopName;
@dynamic weekStarTopIcon;
@dynamic weekStarTopPlayerLevel;
@dynamic weekStarTopRankCharm;
@dynamic weekStarFansTopId;
@dynamic weekStarFansTopName;
@dynamic weekStarFansTopIcon;
@dynamic weekStarFansTopPlayerLevel;
@dynamic weekStarTopRankWealth;

typedef struct PB3HistoryTopWeekStarRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t weekStarTopPlayerLevel;
  int32_t weekStarFansTopPlayerLevel;
  NSString *weekStarTopName;
  NSString *weekStarTopIcon;
  NSString *weekStarFansTopName;
  NSString *weekStarFansTopIcon;
  int64_t weekStarTopId;
  int64_t weekStarTopRankCharm;
  int64_t weekStarFansTopId;
  int64_t weekStarTopRankWealth;
} PB3HistoryTopWeekStarRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "weekStarTopId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "weekStarTopName",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weekStarTopIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weekStarTopPlayerLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopPlayerLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopPlayerLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weekStarTopRankCharm",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopRankCharm,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopRankCharm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "weekStarFansTopId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarFansTopId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarFansTopId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "weekStarFansTopName",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarFansTopName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarFansTopName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weekStarFansTopIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarFansTopIcon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarFansTopIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weekStarFansTopPlayerLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarFansTopPlayerLevel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarFansTopPlayerLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weekStarTopRankWealth",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryTopWeekStarRes_FieldNumber_WeekStarTopRankWealth,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3HistoryTopWeekStarRes__storage_, weekStarTopRankWealth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryTopWeekStarRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HistoryTopWeekStarRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3OldWeekStar

@implementation PB3OldWeekStar

@dynamic phase;
@dynamic icon;
@dynamic name;
@dynamic starVal;
@dynamic clanName;
@dynamic id_p;
@dynamic sex;
@dynamic playerLevel;

typedef struct PB3OldWeekStar__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  int32_t playerLevel;
  NSString *icon;
  NSString *name;
  NSString *clanName;
  int64_t phase;
  int64_t starVal;
  int64_t id_p;
} PB3OldWeekStar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phase",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Phase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, phase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "starVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_StarVal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, starVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clanName",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_ClanName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, clanName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Id_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3OldWeekStar_FieldNumber_Sex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_PlayerLevel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, playerLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3OldWeekStar class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3OldWeekStar__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3OldWeekStar_Sex_RawValue(PB3OldWeekStar *message) {
  GPBDescriptor *descriptor = [PB3OldWeekStar descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3OldWeekStar_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3OldWeekStar_Sex_RawValue(PB3OldWeekStar *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3OldWeekStar descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3OldWeekStar_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetPcChargeIdReq

@implementation PB3GetPcChargeIdReq

@dynamic playerId;
@dynamic gold;
@dynamic timeStamp;
@dynamic channel;
@dynamic os;
@dynamic data_p;

typedef struct PB3GetPcChargeIdReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t channel;
  NSString *os;
  NSData *data_p;
  int64_t playerId;
  int64_t timeStamp;
} PB3GetPcChargeIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Gold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_TimeStamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "os",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Os,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, os),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Data_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeIdReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeIdRes

@implementation PB3GetPcChargeIdRes

@dynamic payId;
@dynamic timeOut;

typedef struct PB3GetPcChargeIdRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeOut;
  int64_t payId;
} PB3GetPcChargeIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdRes_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdRes__storage_, payId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeOut",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdRes_FieldNumber_TimeOut,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdRes__storage_, timeOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeIdRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeCheckReq

@implementation PB3GetPcChargeCheckReq

@dynamic payId;
@dynamic playerId;
@dynamic gold;
@dynamic timeStamp;
@dynamic channel;
@dynamic os;

typedef struct PB3GetPcChargeCheckReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t channel;
  NSString *os;
  int64_t payId;
  int64_t playerId;
  int64_t timeStamp;
} PB3GetPcChargeCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, payId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Gold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Channel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "os",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Os,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, os),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeCheckReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeCheckRes

@implementation PB3GetPcChargeCheckRes

@dynamic data_p;

typedef struct PB3GetPcChargeCheckRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} PB3GetPcChargeCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckRes_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckRes__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeCheckRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SensitiveCheckReq

@implementation PB3SensitiveCheckReq

@dynamic words;
@dynamic lib;

typedef struct PB3SensitiveCheckReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SensitiveWordLib lib;
  NSString *words;
} PB3SensitiveCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "words",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckReq_FieldNumber_Words,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckReq__storage_, words),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lib",
        .dataTypeSpecific.enumDescFunc = PB3SensitiveWordLib_EnumDescriptor,
        .number = PB3SensitiveCheckReq_FieldNumber_Lib,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckReq__storage_, lib),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SensitiveCheckReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SensitiveCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SensitiveCheckReq_Lib_RawValue(PB3SensitiveCheckReq *message) {
  GPBDescriptor *descriptor = [PB3SensitiveCheckReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SensitiveCheckReq_FieldNumber_Lib];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SensitiveCheckReq_Lib_RawValue(PB3SensitiveCheckReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SensitiveCheckReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SensitiveCheckReq_FieldNumber_Lib];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SensitiveCheckRes

@implementation PB3SensitiveCheckRes

@dynamic pass;
@dynamic toastText;
@dynamic checkedWords;

typedef struct PB3SensitiveCheckRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  NSString *checkedWords;
} PB3SensitiveCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_Pass,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_ToastText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckRes__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkedWords",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_CheckedWords,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckRes__storage_, checkedWords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SensitiveCheckRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SensitiveCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserActionLogReq

@implementation PB3UserActionLogReq

@dynamic clickRoom;
@dynamic clickHall;

typedef struct PB3UserActionLogReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t clickRoom;
  int64_t clickHall;
} PB3UserActionLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clickRoom",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserActionLogReq_FieldNumber_ClickRoom,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserActionLogReq__storage_, clickRoom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clickHall",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserActionLogReq_FieldNumber_ClickHall,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserActionLogReq__storage_, clickHall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserActionLogReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserActionLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserActionLogRes

@implementation PB3UserActionLogRes


typedef struct PB3UserActionLogRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UserActionLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserActionLogRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserActionLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FriendBackgroundConfigReq

@implementation PB3FriendBackgroundConfigReq


typedef struct PB3FriendBackgroundConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FriendBackgroundConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FriendBackgroundConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FriendBackgroundConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FriendBackgroundConfigRes

@implementation PB3FriendBackgroundConfigRes

@dynamic configs, configs_Count;

typedef struct PB3FriendBackgroundConfigRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *configs;
} PB3FriendBackgroundConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configs",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BackgroundConfig),
        .number = PB3FriendBackgroundConfigRes_FieldNumber_Configs,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FriendBackgroundConfigRes__storage_, configs),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FriendBackgroundConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FriendBackgroundConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BackgroundConfig

@implementation PB3BackgroundConfig

@dynamic backgroundId;
@dynamic backgroundName;
@dynamic backgroundImg;
@dynamic bgHeartImg;
@dynamic bgHeartShowImg;
@dynamic bgNameLeftImg;
@dynamic bgNameRightImg;
@dynamic bgStoreShowImg;
@dynamic bgShowMinImg;

typedef struct PB3BackgroundConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t backgroundId;
  NSString *backgroundName;
  NSString *backgroundImg;
  NSString *bgHeartImg;
  NSString *bgHeartShowImg;
  NSString *bgNameLeftImg;
  NSString *bgNameRightImg;
  NSString *bgStoreShowImg;
  NSString *bgShowMinImg;
} PB3BackgroundConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "backgroundId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backgroundName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgHeartImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgHeartImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgHeartImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgHeartShowImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgHeartShowImg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgHeartShowImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgNameLeftImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgNameLeftImg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgNameLeftImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgNameRightImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgNameRightImg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgNameRightImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgStoreShowImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgStoreShowImg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgStoreShowImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgShowMinImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgShowMinImg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgShowMinImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BackgroundConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BackgroundConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserReportReq

@implementation PB3UserReportReq

@dynamic targetId;
@dynamic typeArray, typeArray_Count;
@dynamic remark;
@dynamic picIdsArray, picIdsArray_Count;
@dynamic tipsText;
@dynamic reportFrom;

typedef struct PB3UserReportReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ReportFrom reportFrom;
  GPBEnumArray *typeArray;
  NSString *remark;
  NSMutableArray *picIdsArray;
  NSString *tipsText;
  int64_t targetId;
} PB3UserReportReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "typeArray",
        .dataTypeSpecific.enumDescFunc = PB3ReportType_EnumDescriptor,
        .number = PB3UserReportReq_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, typeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "picIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_PicIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, picIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tipsText",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_TipsText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, tipsText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reportFrom",
        .dataTypeSpecific.enumDescFunc = PB3ReportFrom_EnumDescriptor,
        .number = PB3UserReportReq_FieldNumber_ReportFrom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, reportFrom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserReportReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserReportReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserReportReq_ReportFrom_RawValue(PB3UserReportReq *message) {
  GPBDescriptor *descriptor = [PB3UserReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserReportReq_FieldNumber_ReportFrom];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserReportReq_ReportFrom_RawValue(PB3UserReportReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserReportReq_FieldNumber_ReportFrom];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserReportRes

@implementation PB3UserReportRes

@dynamic code;

typedef struct PB3UserReportRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} PB3UserReportRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserReportRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserReportRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserReportRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeStatusReq

@implementation PB3ExchangeCodeStatusReq


typedef struct PB3ExchangeCodeStatusReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ExchangeCodeStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeStatusReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ExchangeCodeStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeStatusRes

@implementation PB3ExchangeCodeStatusRes

@dynamic status;

typedef struct PB3ExchangeCodeStatusRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} PB3ExchangeCodeStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeStatusRes_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeStatusRes__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeStatusRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeReward

@implementation PB3ExchangeCodeReward

@dynamic rewardId;
@dynamic rewardNum;

typedef struct PB3ExchangeCodeReward__storage_ {
  uint32_t _has_storage_[1];
  int64_t rewardId;
  int64_t rewardNum;
} PB3ExchangeCodeReward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_RewardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_RewardNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeReward class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeReward__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeInfoReq

@implementation PB3ExchangeCodeInfoReq

@dynamic code;

typedef struct PB3ExchangeCodeInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} PB3ExchangeCodeInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeInfoRes

@implementation PB3ExchangeCodeInfoRes

@dynamic name;
@dynamic iconURL;
@dynamic desc;
@dynamic roomId;
@dynamic rewardsArray, rewardsArray_Count;

typedef struct PB3ExchangeCodeInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *iconURL;
  NSString *desc;
  NSMutableArray *rewardsArray;
  int64_t roomId;
} PB3ExchangeCodeInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_IconURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_RoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeCodeReward),
        .number = PB3ExchangeCodeInfoRes_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, rewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeRewardReq

@implementation PB3ExchangeCodeRewardReq

@dynamic code;

typedef struct PB3ExchangeCodeRewardReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} PB3ExchangeCodeRewardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeRewardReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeRewardReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeRewardReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeRewardReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeRewardRes

@implementation PB3ExchangeCodeRewardRes


typedef struct PB3ExchangeCodeRewardRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ExchangeCodeRewardRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeRewardRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ExchangeCodeRewardRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FocusBubbleConfReq

@implementation PB3FocusBubbleConfReq


typedef struct PB3FocusBubbleConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FocusBubbleConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FocusBubbleConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FocusBubbleConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FocusBubbleConfRes

@implementation PB3FocusBubbleConfRes

@dynamic firstPopTime;
@dynamic firstPopLastTime;
@dynamic secondPopTime;
@dynamic secondPopLastTime;
@dynamic popMsgArray, popMsgArray_Count;

typedef struct PB3FocusBubbleConfRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t firstPopTime;
  int32_t firstPopLastTime;
  int32_t secondPopTime;
  int32_t secondPopLastTime;
  NSMutableArray *popMsgArray;
} PB3FocusBubbleConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstPopTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_FirstPopTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, firstPopTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "firstPopLastTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_FirstPopLastTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, firstPopLastTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "secondPopTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_SecondPopTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, secondPopTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "secondPopLastTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_SecondPopLastTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, secondPopLastTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "popMsgArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_PopMsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, popMsgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FocusBubbleConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FocusBubbleConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSongInfoReq

@implementation PB3GetSongInfoReq

@dynamic songId;

typedef struct PB3GetSongInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t songId;
} PB3GetSongInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetSongInfoReq_FieldNumber_SongId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSongInfoReq__storage_, songId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSongInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSongInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSongInfoRes

@implementation PB3GetSongInfoRes

@dynamic hasSong, song;

typedef struct PB3GetSongInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3Song *song;
} PB3GetSongInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "song",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Song),
        .number = PB3GetSongInfoRes_FieldNumber_Song,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSongInfoRes__storage_, song),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSongInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSongInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifyConf

@implementation PB3WechatNotifyConf

@dynamic type;
@dynamic switch_p;

typedef struct PB3WechatNotifyConf__storage_ {
  uint32_t _has_storage_[1];
  PB3WechatNotifyType type;
  int32_t switch_p;
} PB3WechatNotifyConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WechatNotifyType_EnumDescriptor,
        .number = PB3WechatNotifyConf_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConf__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "switch_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatNotifyConf_FieldNumber_Switch_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConf__storage_, switch_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifyConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WechatNotifyConf_Type_RawValue(PB3WechatNotifyConf *message) {
  GPBDescriptor *descriptor = [PB3WechatNotifyConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifyConf_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WechatNotifyConf_Type_RawValue(PB3WechatNotifyConf *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WechatNotifyConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifyConf_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WechatNotifyConfReq

@implementation PB3WechatNotifyConfReq


typedef struct PB3WechatNotifyConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WechatNotifyConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WechatNotifyConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifyConfRes

@implementation PB3WechatNotifyConfRes

@dynamic configsArray, configsArray_Count;

typedef struct PB3WechatNotifyConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *configsArray;
} PB3WechatNotifyConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WechatNotifyConf),
        .number = PB3WechatNotifyConfRes_FieldNumber_ConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConfRes__storage_, configsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifyConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifySwitchReq

@implementation PB3WechatNotifySwitchReq

@dynamic type;
@dynamic switch_p;

typedef struct PB3WechatNotifySwitchReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WechatNotifyType type;
  int32_t switch_p;
} PB3WechatNotifySwitchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WechatNotifyType_EnumDescriptor,
        .number = PB3WechatNotifySwitchReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WechatNotifySwitchReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "switch_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatNotifySwitchReq_FieldNumber_Switch_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WechatNotifySwitchReq__storage_, switch_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifySwitchReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifySwitchReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WechatNotifySwitchReq_Type_RawValue(PB3WechatNotifySwitchReq *message) {
  GPBDescriptor *descriptor = [PB3WechatNotifySwitchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifySwitchReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WechatNotifySwitchReq_Type_RawValue(PB3WechatNotifySwitchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WechatNotifySwitchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifySwitchReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WechatNotifySwitchRes

@implementation PB3WechatNotifySwitchRes


typedef struct PB3WechatNotifySwitchRes__storage_ {
  uint32_t _has_storage_[1];
} PB3WechatNotifySwitchRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifySwitchRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WechatNotifySwitchRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TaxConfReq

@implementation PB3TaxConfReq

@dynamic type;

typedef struct PB3TaxConfReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TaxConfType type;
} PB3TaxConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TaxConfType_EnumDescriptor,
        .number = PB3TaxConfReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TaxConfReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TaxConfReq_Type_RawValue(PB3TaxConfReq *message) {
  GPBDescriptor *descriptor = [PB3TaxConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TaxConfReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TaxConfReq_Type_RawValue(PB3TaxConfReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TaxConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TaxConfReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TaxConf

@implementation PB3TaxConf

@dynamic minValue;
@dynamic maxValue;
@dynamic tax;

typedef struct PB3TaxConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t minValue;
  int32_t maxValue;
  int32_t tax;
} PB3TaxConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_MinValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, minValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "maxValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_MaxValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, maxValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "tax",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_Tax,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, tax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TaxConfRes

@implementation PB3TaxConfRes

@dynamic taxArray, taxArray_Count;

typedef struct PB3TaxConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *taxArray;
} PB3TaxConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "taxArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TaxConf),
        .number = PB3TaxConfRes_FieldNumber_TaxArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TaxConfRes__storage_, taxArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelLimitConfIOSRes

@implementation PB3LevelLimitConfIOSRes

@dynamic charmLevel;
@dynamic wealthLevel;
@dynamic openAndOr;

typedef struct PB3LevelLimitConfIOSRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  int32_t wealthLevel;
  int32_t openAndOr;
} PB3LevelLimitConfIOSRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_CharmLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_WealthLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "openAndOr",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_OpenAndOr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, openAndOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelLimitConfIOSRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LevelLimitConfIOSRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelLimitConfIOSReq

@implementation PB3LevelLimitConfIOSReq


typedef struct PB3LevelLimitConfIOSReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LevelLimitConfIOSReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelLimitConfIOSReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LevelLimitConfIOSReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AcGameConf

@implementation PB3AcGameConf

@dynamic gameId;
@dynamic gameType;
@dynamic gameName;
@dynamic gameIcon;
@dynamic gamePcIcon;
@dynamic sourceURL;
@dynamic gameVersion;
@dynamic minSdkVersion;
@dynamic weight;
@dynamic gameTypeInt;
@dynamic router;

typedef struct PB3AcGameConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t gameId;
  PB3IndexAcGameType gameType;
  int32_t weight;
  int32_t gameTypeInt;
  NSString *gameName;
  NSString *gameIcon;
  NSString *gamePcIcon;
  NSString *sourceURL;
  NSString *gameVersion;
  NSString *minSdkVersion;
  NSString *router;
} PB3AcGameConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameType",
        .dataTypeSpecific.enumDescFunc = PB3IndexAcGameType_EnumDescriptor,
        .number = PB3AcGameConf_FieldNumber_GameType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gamePcIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GamePcIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gamePcIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_SourceURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, sourceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameVersion",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minSdkVersion",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_MinSdkVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, minSdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_Weight,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameTypeInt",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameTypeInt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameTypeInt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_Router,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AcGameConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AcGameConf_GameType_RawValue(PB3AcGameConf *message) {
  GPBDescriptor *descriptor = [PB3AcGameConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AcGameConf_FieldNumber_GameType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AcGameConf_GameType_RawValue(PB3AcGameConf *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AcGameConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AcGameConf_FieldNumber_GameType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AcGameConfListReq

@implementation PB3AcGameConfListReq


typedef struct PB3AcGameConfListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AcGameConfListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConfListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AcGameConfListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AcGameConfListRes

@implementation PB3AcGameConfListRes

@dynamic confListArray, confListArray_Count;
@dynamic icon;
@dynamic pcIcon;
@dynamic pcIconFlow;
@dynamic pcIconClick;
@dynamic blackIcon;

typedef struct PB3AcGameConfListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confListArray;
  NSString *icon;
  NSString *pcIcon;
  NSString *pcIconFlow;
  NSString *pcIconClick;
  NSString *blackIcon;
} PB3AcGameConfListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AcGameConf),
        .number = PB3AcGameConfListRes_FieldNumber_ConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, confListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconFlow",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIconFlow,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIconFlow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconClick",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIconClick,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIconClick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_BlackIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, blackIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConfListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AcGameConfListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PendantConfig

@implementation PB3PendantConfig

@dynamic id_p;
@dynamic name;
@dynamic state;
@dynamic bgURL;
@dynamic btnURL;
@dynamic halfURL;
@dynamic pcBgURL;
@dynamic pcBtnURL;
@dynamic pcHalfURL;
@dynamic routerURL;
@dynamic routerTitle;
@dynamic thumbnailBtn;
@dynamic pdType;
@dynamic spinningSpeed;
@dynamic cpURL;
@dynamic endTime;

typedef struct PB3PendantConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3PendantState state;
  PB3PendantType pdType;
  int32_t spinningSpeed;
  NSString *name;
  NSString *bgURL;
  NSString *btnURL;
  NSString *halfURL;
  NSString *pcBgURL;
  NSString *pcBtnURL;
  NSString *pcHalfURL;
  NSString *routerURL;
  NSString *routerTitle;
  NSString *cpURL;
  int64_t endTime;
} PB3PendantConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3PendantState_EnumDescriptor,
        .number = PB3PendantConfig_FieldNumber_State,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_BgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, bgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "btnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_BtnURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, btnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "halfURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_HalfURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, halfURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcBgURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcBgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBtnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcBtnURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcBtnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcHalfURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcHalfURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcHalfURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_RouterURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_RouterTitle,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, routerTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnailBtn",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_ThumbnailBtn,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pdType",
        .dataTypeSpecific.enumDescFunc = PB3PendantType_EnumDescriptor,
        .number = PB3PendantConfig_FieldNumber_PdType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pdType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "spinningSpeed",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_SpinningSpeed,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, spinningSpeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_CpURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, cpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_EndTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PendantConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\004\002\241!!\000\005\003\241!!\000\006\004\241!!\000\007\002\242\241!!\000\010\002\243\241!!\000\t\002\244\241!!\000"
        "\n\006\241!!\000\017\002\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PendantConfig_State_RawValue(PB3PendantConfig *message) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PendantConfig_State_RawValue(PB3PendantConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PendantConfig_PdType_RawValue(PB3PendantConfig *message) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_PdType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PendantConfig_PdType_RawValue(PB3PendantConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_PdType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PendantConfigReq

@implementation PB3PendantConfigReq


typedef struct PB3PendantConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PendantConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PendantConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PendantConfigRes

@implementation PB3PendantConfigRes

@dynamic pendantConfListArray, pendantConfListArray_Count;
@dynamic pendantConfListSortArray, pendantConfListSortArray_Count;

typedef struct PB3PendantConfigRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pendantConfListArray;
  NSMutableArray *pendantConfListSortArray;
} PB3PendantConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pendantConfListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PendantConfig),
        .number = PB3PendantConfigRes_FieldNumber_PendantConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PendantConfigRes__storage_, pendantConfListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendantConfListSortArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PendantConfig),
        .number = PB3PendantConfigRes_FieldNumber_PendantConfListSortArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PendantConfigRes__storage_, pendantConfListSortArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PendantConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ThemeConfig

@implementation PB3ThemeConfig

@dynamic id_p;
@dynamic name;
@dynamic beginAt;
@dynamic endAt;
@dynamic state;
@dynamic contentURL;
@dynamic URL;
@dynamic btnURL;
@dynamic routerURL;
@dynamic flag;
@dynamic routerH5URL;
@dynamic h5HeadURL;
@dynamic h5HeadNilURL;
@dynamic routerDraw;
@dynamic pcBtnURL;
@dynamic showType;

typedef struct PB3ThemeConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3BannerState state;
  PB3BannerType showType;
  NSString *name;
  NSString *contentURL;
  NSString *URL;
  NSString *btnURL;
  NSString *routerURL;
  NSString *flag;
  NSString *routerH5URL;
  NSString *h5HeadURL;
  NSString *h5HeadNilURL;
  NSString *routerDraw;
  NSString *pcBtnURL;
  int64_t beginAt;
  int64_t endAt;
} PB3ThemeConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "beginAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_BeginAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, beginAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_EndAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, endAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3BannerState_EnumDescriptor,
        .number = PB3ThemeConfig_FieldNumber_State,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contentURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_ContentURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, contentURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "btnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_BtnURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, btnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Flag,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerH5URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterH5URL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerH5URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "h5HeadURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_H5HeadURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, h5HeadURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "h5HeadNilURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_H5HeadNilURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, h5HeadNilURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerDraw",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterDraw,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerDraw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBtnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_PcBtnURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, pcBtnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB3BannerType_EnumDescriptor,
        .number = PB3ThemeConfig_FieldNumber_ShowType,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ThemeConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\006\007\241!!\000\007!!!\000\010\003\241!!\000\t\006\241!!\000\013\006\242\241!!\000\014\002\244\241!!\000\r\002"
        "\244\243\241!!\000\017\002\243\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ThemeConfig_State_RawValue(PB3ThemeConfig *message) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ThemeConfig_State_RawValue(PB3ThemeConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3ThemeConfig_ShowType_RawValue(PB3ThemeConfig *message) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ThemeConfig_ShowType_RawValue(PB3ThemeConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ThemeConfigReq

@implementation PB3ThemeConfigReq


typedef struct PB3ThemeConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ThemeConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ThemeConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ThemeConfigRes

@implementation PB3ThemeConfigRes

@dynamic themeConfListArray, themeConfListArray_Count;

typedef struct PB3ThemeConfigRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *themeConfListArray;
} PB3ThemeConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "themeConfListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ThemeConfig),
        .number = PB3ThemeConfigRes_FieldNumber_ThemeConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ThemeConfigRes__storage_, themeConfListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ThemeConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CountDownConfReq

@implementation PB3CountDownConfReq


typedef struct PB3CountDownConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CountDownConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CountDownConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CountDownConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CountDownConfRes

@implementation PB3CountDownConfRes

@dynamic URL;
@dynamic startAt;
@dynamic isOpen;

typedef struct PB3CountDownConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  int64_t startAt;
} PB3CountDownConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CountDownConfRes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_StartAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CountDownConfRes__storage_, startAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_IsOpen,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CountDownConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CountDownConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EventTrackingArgs

@implementation PB3EventTrackingArgs

@dynamic key;
@dynamic value;
@dynamic argType;

typedef struct PB3EventTrackingArgs__storage_ {
  uint32_t _has_storage_[1];
  PB3EventTrackingArgType argType;
  NSString *key;
  NSString *value;
} PB3EventTrackingArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTrackingArgs_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTrackingArgs_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argType",
        .dataTypeSpecific.enumDescFunc = PB3EventTrackingArgType_EnumDescriptor,
        .number = PB3EventTrackingArgs_FieldNumber_ArgType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, argType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EventTrackingArgs class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EventTrackingArgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3EventTrackingArgs_ArgType_RawValue(PB3EventTrackingArgs *message) {
  GPBDescriptor *descriptor = [PB3EventTrackingArgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EventTrackingArgs_FieldNumber_ArgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EventTrackingArgs_ArgType_RawValue(PB3EventTrackingArgs *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EventTrackingArgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EventTrackingArgs_FieldNumber_ArgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3EventTracking

@implementation PB3EventTracking

@dynamic event;
@dynamic argsArray, argsArray_Count;

typedef struct PB3EventTracking__storage_ {
  uint32_t _has_storage_[1];
  NSString *event;
  NSMutableArray *argsArray;
} PB3EventTracking__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "event",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTracking_FieldNumber_Event,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EventTracking__storage_, event),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EventTrackingArgs),
        .number = PB3EventTracking_FieldNumber_ArgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EventTracking__storage_, argsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EventTracking class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EventTracking__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportEventTrackingReq

@implementation PB3ReportEventTrackingReq

@dynamic eventsArray, eventsArray_Count;

typedef struct PB3ReportEventTrackingReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
} PB3ReportEventTrackingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EventTracking),
        .number = PB3ReportEventTrackingReq_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ReportEventTrackingReq__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportEventTrackingReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportEventTrackingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportEventTrackingRes

@implementation PB3ReportEventTrackingRes


typedef struct PB3ReportEventTrackingRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportEventTrackingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportEventTrackingRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportEventTrackingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportLoginReq

@implementation PB3ReportLoginReq

@dynamic oaid;
@dynamic reyunDeviceId;
@dynamic deviceType;
@dynamic deviceId;
@dynamic uMengDeviceId;

typedef struct PB3ReportLoginReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *oaid;
  NSString *reyunDeviceId;
  NSString *deviceId;
  NSString *uMengDeviceId;
} PB3ReportLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_Oaid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, oaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reyunDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_ReyunDeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, reyunDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3ReportLoginReq_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uMengDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_UMengDeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, uMengDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportLoginReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReportLoginReq_DeviceType_RawValue(PB3ReportLoginReq *message) {
  GPBDescriptor *descriptor = [PB3ReportLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportLoginReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReportLoginReq_DeviceType_RawValue(PB3ReportLoginReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReportLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportLoginReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReportLoginRes

@implementation PB3ReportLoginRes


typedef struct PB3ReportLoginRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportLoginRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AppPushPopup

@implementation PB3AppPushPopup

@dynamic popupImg;
@dynamic butImg;
@dynamic touchArea;
@dynamic targetType;
@dynamic targetId;
@dynamic installInBegin;
@dynamic installInEnd;
@dynamic appearArea;
@dynamic jumpURL;
@dynamic expireTime;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic isAnd;
@dynamic msgId;

typedef struct PB3AppPushPopup__storage_ {
  uint32_t _has_storage_[1];
  PB3TouchAreaType touchArea;
  PB3TargetType targetType;
  PB3AppearArea appearArea;
  int32_t wealthLevel;
  int32_t charmLevel;
  NSString *popupImg;
  NSString *butImg;
  NSString *jumpURL;
  int64_t targetId;
  int64_t installInBegin;
  int64_t installInEnd;
  int64_t expireTime;
  int64_t msgId;
} PB3AppPushPopup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "popupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_PopupImg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, popupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "butImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_ButImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, butImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "touchArea",
        .dataTypeSpecific.enumDescFunc = PB3TouchAreaType_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_TouchArea,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, touchArea),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = PB3TargetType_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_TargetType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "installInBegin",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_InstallInBegin,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, installInBegin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "installInEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_InstallInEnd,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, installInEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "appearArea",
        .dataTypeSpecific.enumDescFunc = PB3AppearArea_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_AppearArea,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, appearArea),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_JumpURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_ExpireTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_WealthLevel,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_CharmLevel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAnd",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_IsAnd,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_MsgId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AppPushPopup class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AppPushPopup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AppPushPopup_TouchArea_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TouchArea];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_TouchArea_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TouchArea];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3AppPushPopup_TargetType_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TargetType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_TargetType_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TargetType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3AppPushPopup_AppearArea_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_AppearArea];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_AppearArea_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_AppearArea];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PullAppPushPopupReq

@implementation PB3PullAppPushPopupReq


typedef struct PB3PullAppPushPopupReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PullAppPushPopupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullAppPushPopupReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PullAppPushPopupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PullAppPushPopupRes

@implementation PB3PullAppPushPopupRes

@dynamic listArray, listArray_Count;

typedef struct PB3PullAppPushPopupRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3PullAppPushPopupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AppPushPopup),
        .number = PB3PullAppPushPopupRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PullAppPushPopupRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullAppPushPopupRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PullAppPushPopupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadExitSongReq

@implementation PB3UploadExitSongReq

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadExitSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadExitSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadExitSongReq_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadExitSongReq__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadExitSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadExitSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadExitSongRes

@implementation PB3UploadExitSongRes

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadExitSongRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadExitSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadExitSongRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadExitSongRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadExitSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadExitSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongReq

@implementation PB3UploadSongReq

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadSongReq_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadSongReq__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongRes

@implementation PB3UploadSongRes


typedef struct PB3UploadSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UploadSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UploadSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongInfo

@implementation PB3UploadSongInfo

@dynamic id_p;
@dynamic name;
@dynamic singerName;
@dynamic isRecommend;
@dynamic isExist;

typedef struct PB3UploadSongInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *singerName;
  int64_t id_p;
} PB3UploadSongInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "singerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_SingerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, singerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_IsRecommend,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isExist",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_IsExist,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadSongInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MySongListReq

@implementation PB3MySongListReq

@dynamic isTopRecommend;

typedef struct PB3MySongListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3MySongListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isTopRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3MySongListReq_FieldNumber_IsTopRecommend,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MySongListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MySongListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MySongListRes

@implementation PB3MySongListRes

@dynamic songListArray, songListArray_Count;

typedef struct PB3MySongListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3MySongListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3MySongListRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MySongListRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MySongListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MySongListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RemoveSongReq

@implementation PB3RemoveSongReq

@dynamic id_p;

typedef struct PB3RemoveSongReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3RemoveSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3RemoveSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RemoveSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RemoveSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RemoveSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RemoveSongRes

@implementation PB3RemoveSongRes


typedef struct PB3RemoveSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3RemoveSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RemoveSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3RemoveSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSongReq

@implementation PB3UpdateSongReq

@dynamic id_p;
@dynamic isRecommend;

typedef struct PB3UpdateSongReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3UpdateSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateSongReq_FieldNumber_IsRecommend,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSongRes

@implementation PB3UpdateSongRes


typedef struct PB3UpdateSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdateSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdateSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchSongReq

@implementation PB3SearchSongReq

@dynamic name;
@dynamic playerId;

typedef struct PB3SearchSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t playerId;
} PB3SearchSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchSongReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchSongReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchSongReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchSongReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchSongRes

@implementation PB3SearchSongRes

@dynamic songListArray, songListArray_Count;
@dynamic singerListArray, singerListArray_Count;

typedef struct PB3SearchSongRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
  NSMutableArray *singerListArray;
} PB3SearchSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3SearchSongRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchSongRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingerInfo),
        .number = PB3SearchSongRes_FieldNumber_SingerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchSongRes__storage_, singerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingerInfo

@implementation PB3SingerInfo

@dynamic playerId;
@dynamic roomId;
@dynamic chairId;
@dynamic isOnline;
@dynamic name;
@dynamic icon;
@dynamic sex;

typedef struct PB3SingerInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t chairId;
  PB3SexType sex;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t roomId;
} PB3SingerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chairId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_ChairId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, chairId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_IsOnline,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_Icon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3SingerInfo_FieldNumber_Sex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingerInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingerInfo_Sex_RawValue(PB3SingerInfo *message) {
  GPBDescriptor *descriptor = [PB3SingerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingerInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingerInfo_Sex_RawValue(PB3SingerInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingerInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CheckContentReq

@implementation PB3CheckContentReq

@dynamic content;

typedef struct PB3CheckContentReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} PB3CheckContentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckContentReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CheckContentReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckContentReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckContentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckContentRes

@implementation PB3CheckContentRes

@dynamic isPass;

typedef struct PB3CheckContentRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckContentRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPass",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckContentRes_FieldNumber_IsPass,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckContentRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckContentRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncPlayerOptReq

@implementation PB3SyncPlayerOptReq

@dynamic hasOpt, opt;

typedef struct PB3SyncPlayerOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SyncOpt *opt;
} PB3SyncPlayerOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SyncOpt),
        .number = PB3SyncPlayerOptReq_FieldNumber_Opt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SyncPlayerOptReq__storage_, opt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncPlayerOptReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SyncPlayerOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncPlayerOptRes

@implementation PB3SyncPlayerOptRes


typedef struct PB3SyncPlayerOptRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SyncPlayerOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncPlayerOptRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SyncPlayerOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftBaseCfgReq

@implementation PB3FirstPayGiftBaseCfgReq


typedef struct PB3FirstPayGiftBaseCfgReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftBaseCfgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftBaseCfgReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftBaseCfgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftBaseCfgRes

@implementation PB3FirstPayGiftBaseCfgRes

@dynamic mostValueDesc;
@dynamic mostValueURL;
@dynamic mostValueH5URL;

typedef struct PB3FirstPayGiftBaseCfgRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *mostValueDesc;
  NSString *mostValueURL;
  NSString *mostValueH5URL;
} PB3FirstPayGiftBaseCfgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mostValueDesc",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftBaseCfgRes_FieldNumber_MostValueDesc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftBaseCfgRes__storage_, mostValueDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mostValueURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftBaseCfgRes_FieldNumber_MostValueURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftBaseCfgRes__storage_, mostValueURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mostValueH5URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftBaseCfgRes_FieldNumber_MostValueH5URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftBaseCfgRes__storage_, mostValueH5URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftBaseCfgRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftBaseCfgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\004\245\241!!\000\003\004\245\242\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftRewardCfg

@implementation PB3FirstPayGiftRewardCfg

@dynamic id_p;
@dynamic rewardId;
@dynamic rewardType;
@dynamic expiredTime;
@dynamic limitType;
@dynamic limitNum;
@dynamic boxType;
@dynamic boxSort;
@dynamic worth;
@dynamic rewardName;
@dynamic rewardNum;
@dynamic rewardUnit;
@dynamic isWorth;

typedef struct PB3FirstPayGiftRewardCfg__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftRewardType rewardType;
  PB3FirstPayGiftRewardLimitType limitType;
  PB3FirstPayGiftBoxType boxType;
  int32_t boxSort;
  int32_t rewardNum;
  NSString *rewardName;
  NSString *rewardUnit;
  int64_t id_p;
  int64_t rewardId;
  int64_t expiredTime;
  int64_t limitNum;
  int64_t worth;
} PB3FirstPayGiftRewardCfg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_RewardId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftRewardType_EnumDescriptor,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_RewardType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, rewardType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_ExpiredTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, expiredTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limitType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftRewardLimitType_EnumDescriptor,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_LimitType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, limitType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "limitNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_LimitNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, limitNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "boxType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftBoxType_EnumDescriptor,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_BoxType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, boxType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "boxSort",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_BoxSort,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, boxSort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "worth",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_Worth,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, worth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_RewardName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, rewardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_RewardNum,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rewardUnit",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_RewardUnit,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfg__storage_, rewardUnit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isWorth",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftRewardCfg_FieldNumber_IsWorth,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftRewardCfg class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftRewardCfg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftRewardCfg_RewardType_RawValue(PB3FirstPayGiftRewardCfg *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_RewardType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftRewardCfg_RewardType_RawValue(PB3FirstPayGiftRewardCfg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_RewardType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3FirstPayGiftRewardCfg_LimitType_RawValue(PB3FirstPayGiftRewardCfg *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_LimitType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftRewardCfg_LimitType_RawValue(PB3FirstPayGiftRewardCfg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_LimitType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3FirstPayGiftRewardCfg_BoxType_RawValue(PB3FirstPayGiftRewardCfg *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_BoxType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftRewardCfg_BoxType_RawValue(PB3FirstPayGiftRewardCfg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftRewardCfg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftRewardCfg_FieldNumber_BoxType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftRewardCfgReq

@implementation PB3FirstPayGiftRewardCfgReq


typedef struct PB3FirstPayGiftRewardCfgReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftRewardCfgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftRewardCfgReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftRewardCfgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftRewardCfgRes

@implementation PB3FirstPayGiftRewardCfgRes

@dynamic cfgListArray, cfgListArray_Count;

typedef struct PB3FirstPayGiftRewardCfgRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cfgListArray;
} PB3FirstPayGiftRewardCfgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cfgListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3FirstPayGiftRewardCfg),
        .number = PB3FirstPayGiftRewardCfgRes_FieldNumber_CfgListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftRewardCfgRes__storage_, cfgListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftRewardCfgRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftRewardCfgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftInfoReq

@implementation PB3FirstPayGiftInfoReq


typedef struct PB3FirstPayGiftInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftInfoRes

@implementation PB3FirstPayGiftInfoRes

@dynamic boxType;
@dynamic boxStatus;
@dynamic isPayToday;

typedef struct PB3FirstPayGiftInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftBoxType boxType;
  PB3FirstPayGiftBoxStatus boxStatus;
} PB3FirstPayGiftInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boxType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftBoxType_EnumDescriptor,
        .number = PB3FirstPayGiftInfoRes_FieldNumber_BoxType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftInfoRes__storage_, boxType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "boxStatus",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftBoxStatus_EnumDescriptor,
        .number = PB3FirstPayGiftInfoRes_FieldNumber_BoxStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftInfoRes__storage_, boxStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isPayToday",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftInfoRes_FieldNumber_IsPayToday,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftInfoRes_BoxType_RawValue(PB3FirstPayGiftInfoRes *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftInfoRes_FieldNumber_BoxType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftInfoRes_BoxType_RawValue(PB3FirstPayGiftInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftInfoRes_FieldNumber_BoxType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3FirstPayGiftInfoRes_BoxStatus_RawValue(PB3FirstPayGiftInfoRes *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftInfoRes_FieldNumber_BoxStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftInfoRes_BoxStatus_RawValue(PB3FirstPayGiftInfoRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftInfoRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftInfoRes_FieldNumber_BoxStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftLucky

@implementation PB3FirstPayGiftLucky

@dynamic boxType;
@dynamic playerId;
@dynamic playerSid;
@dynamic nickName;
@dynamic icon;
@dynamic rewardType;
@dynamic rewardId;
@dynamic rewardNum;
@dynamic rewardName;

typedef struct PB3FirstPayGiftLucky__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftBoxType boxType;
  PB3FirstPayGiftRewardType rewardType;
  NSString *nickName;
  NSString *icon;
  NSString *rewardName;
  int64_t playerId;
  int64_t playerSid;
  int64_t rewardId;
  int64_t rewardNum;
} PB3FirstPayGiftLucky__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boxType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftBoxType_EnumDescriptor,
        .number = PB3FirstPayGiftLucky_FieldNumber_BoxType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, boxType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerSid",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_PlayerSid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, playerSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_NickName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftRewardType_EnumDescriptor,
        .number = PB3FirstPayGiftLucky_FieldNumber_RewardType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, rewardType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_RewardId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_RewardNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLucky_FieldNumber_RewardName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLucky__storage_, rewardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLucky class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftLucky__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftLucky_BoxType_RawValue(PB3FirstPayGiftLucky *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLucky descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLucky_FieldNumber_BoxType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftLucky_BoxType_RawValue(PB3FirstPayGiftLucky *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLucky descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLucky_FieldNumber_BoxType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3FirstPayGiftLucky_RewardType_RawValue(PB3FirstPayGiftLucky *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLucky descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLucky_FieldNumber_RewardType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftLucky_RewardType_RawValue(PB3FirstPayGiftLucky *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLucky descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLucky_FieldNumber_RewardType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftLuckyReq

@implementation PB3FirstPayGiftLuckyReq


typedef struct PB3FirstPayGiftLuckyReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftLuckyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLuckyReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftLuckyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftLuckyRes

@implementation PB3FirstPayGiftLuckyRes

@dynamic luckyDay;
@dynamic playerListArray, playerListArray_Count;

typedef struct PB3FirstPayGiftLuckyRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *luckyDay;
  NSMutableArray *playerListArray;
} PB3FirstPayGiftLuckyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "luckyDay",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLuckyRes_FieldNumber_LuckyDay,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLuckyRes__storage_, luckyDay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3FirstPayGiftLucky),
        .number = PB3FirstPayGiftLuckyRes_FieldNumber_PlayerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLuckyRes__storage_, playerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLuckyRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftLuckyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftLog

@implementation PB3FirstPayGiftLog

@dynamic logId;
@dynamic rewardType;
@dynamic rewardId;
@dynamic expiredTime;
@dynamic playerId;
@dynamic playerSid;
@dynamic nickName;
@dynamic icon;
@dynamic createdAt;
@dynamic rewardNum;
@dynamic rewardUnit;
@dynamic rewardName;

typedef struct PB3FirstPayGiftLog__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftRewardType rewardType;
  NSString *nickName;
  NSString *icon;
  NSString *createdAt;
  NSString *rewardUnit;
  NSString *rewardName;
  int64_t logId;
  int64_t rewardId;
  int64_t expiredTime;
  int64_t playerId;
  int64_t playerSid;
  int64_t rewardNum;
} PB3FirstPayGiftLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_LogId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, logId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftRewardType_EnumDescriptor,
        .number = PB3FirstPayGiftLog_FieldNumber_RewardType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, rewardType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_RewardId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_ExpiredTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, expiredTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_PlayerId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerSid",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_PlayerSid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, playerSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_NickName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_Icon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_CreatedAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_RewardNum,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardUnit",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_RewardUnit,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, rewardUnit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftLog_FieldNumber_RewardName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLog__storage_, rewardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLog class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftLog_RewardType_RawValue(PB3FirstPayGiftLog *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLog_FieldNumber_RewardType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftLog_RewardType_RawValue(PB3FirstPayGiftLog *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftLog descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftLog_FieldNumber_RewardType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftLogReq

@implementation PB3FirstPayGiftLogReq


typedef struct PB3FirstPayGiftLogReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLogReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftLogRes

@implementation PB3FirstPayGiftLogRes

@dynamic logListArray, logListArray_Count;

typedef struct PB3FirstPayGiftLogRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *logListArray;
} PB3FirstPayGiftLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3FirstPayGiftLog),
        .number = PB3FirstPayGiftLogRes_FieldNumber_LogListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftLogRes__storage_, logListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftLogRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftOpenBoxReq

@implementation PB3FirstPayGiftOpenBoxReq

@dynamic boxType;

typedef struct PB3FirstPayGiftOpenBoxReq__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftBoxType boxType;
} PB3FirstPayGiftOpenBoxReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boxType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftBoxType_EnumDescriptor,
        .number = PB3FirstPayGiftOpenBoxReq_FieldNumber_BoxType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxReq__storage_, boxType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftOpenBoxReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftOpenBoxReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftOpenBoxReq_BoxType_RawValue(PB3FirstPayGiftOpenBoxReq *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftOpenBoxReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftOpenBoxReq_FieldNumber_BoxType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftOpenBoxReq_BoxType_RawValue(PB3FirstPayGiftOpenBoxReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftOpenBoxReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftOpenBoxReq_FieldNumber_BoxType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftOpenBoxRes

@implementation PB3FirstPayGiftOpenBoxRes

@dynamic rewardType;
@dynamic rewardId;
@dynamic expiredTime;
@dynamic desc;
@dynamic rewardNum;
@dynamic rewardUnit;
@dynamic rewardName;

typedef struct PB3FirstPayGiftOpenBoxRes__storage_ {
  uint32_t _has_storage_[1];
  PB3FirstPayGiftRewardType rewardType;
  int32_t rewardNum;
  NSString *desc;
  NSString *rewardUnit;
  NSString *rewardName;
  int64_t rewardId;
  int64_t expiredTime;
} PB3FirstPayGiftOpenBoxRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardType",
        .dataTypeSpecific.enumDescFunc = PB3FirstPayGiftRewardType_EnumDescriptor,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, rewardType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_ExpiredTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, expiredTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rewardUnit",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardUnit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, rewardUnit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardName",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftOpenBoxRes__storage_, rewardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftOpenBoxRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftOpenBoxRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FirstPayGiftOpenBoxRes_RewardType_RawValue(PB3FirstPayGiftOpenBoxRes *message) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftOpenBoxRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FirstPayGiftOpenBoxRes_RewardType_RawValue(PB3FirstPayGiftOpenBoxRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FirstPayGiftOpenBoxRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FirstPayGiftOpenBoxRes_FieldNumber_RewardType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FirstPayGiftPopupRoomWindowReq

@implementation PB3FirstPayGiftPopupRoomWindowReq


typedef struct PB3FirstPayGiftPopupRoomWindowReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftPopupRoomWindowReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftPopupRoomWindowReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftPopupRoomWindowReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftPopupRoomWindowRes

@implementation PB3FirstPayGiftPopupRoomWindowRes

@dynamic isPopup;
@dynamic windowStay;
@dynamic windowJump;

typedef struct PB3FirstPayGiftPopupRoomWindowRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t windowStay;
  NSString *windowJump;
} PB3FirstPayGiftPopupRoomWindowRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPopup",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftPopupRoomWindowRes_FieldNumber_IsPopup,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "windowStay",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftPopupRoomWindowRes_FieldNumber_WindowStay,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftPopupRoomWindowRes__storage_, windowStay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "windowJump",
        .dataTypeSpecific.className = NULL,
        .number = PB3FirstPayGiftPopupRoomWindowRes_FieldNumber_WindowJump,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FirstPayGiftPopupRoomWindowRes__storage_, windowJump),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftPopupRoomWindowRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FirstPayGiftPopupRoomWindowRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftPopupRoomWindowTimesReq

@implementation PB3FirstPayGiftPopupRoomWindowTimesReq


typedef struct PB3FirstPayGiftPopupRoomWindowTimesReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftPopupRoomWindowTimesReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftPopupRoomWindowTimesReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftPopupRoomWindowTimesReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FirstPayGiftPopupRoomWindowTimesRes

@implementation PB3FirstPayGiftPopupRoomWindowTimesRes


typedef struct PB3FirstPayGiftPopupRoomWindowTimesRes__storage_ {
  uint32_t _has_storage_[1];
} PB3FirstPayGiftPopupRoomWindowTimesRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FirstPayGiftPopupRoomWindowTimesRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FirstPayGiftPopupRoomWindowTimesRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportUserBehaviorsReq

@implementation PB3ReportUserBehaviorsReq

@dynamic behaviorsType;
@dynamic timestamp;

typedef struct PB3ReportUserBehaviorsReq__storage_ {
  uint32_t _has_storage_[1];
  PB3UserBehaviorsType behaviorsType;
  int64_t timestamp;
} PB3ReportUserBehaviorsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "behaviorsType",
        .dataTypeSpecific.enumDescFunc = PB3UserBehaviorsType_EnumDescriptor,
        .number = PB3ReportUserBehaviorsReq_FieldNumber_BehaviorsType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportUserBehaviorsReq__storage_, behaviorsType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportUserBehaviorsReq_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReportUserBehaviorsReq__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportUserBehaviorsReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportUserBehaviorsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReportUserBehaviorsReq_BehaviorsType_RawValue(PB3ReportUserBehaviorsReq *message) {
  GPBDescriptor *descriptor = [PB3ReportUserBehaviorsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportUserBehaviorsReq_FieldNumber_BehaviorsType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReportUserBehaviorsReq_BehaviorsType_RawValue(PB3ReportUserBehaviorsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReportUserBehaviorsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportUserBehaviorsReq_FieldNumber_BehaviorsType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReportUserBehaviorsRes

@implementation PB3ReportUserBehaviorsRes


typedef struct PB3ReportUserBehaviorsRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportUserBehaviorsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportUserBehaviorsRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportUserBehaviorsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ViewChargePageReq

@implementation PB3ViewChargePageReq


typedef struct PB3ViewChargePageReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ViewChargePageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ViewChargePageReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ViewChargePageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ViewChargePageRes

@implementation PB3ViewChargePageRes


typedef struct PB3ViewChargePageRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ViewChargePageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ViewChargePageRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ViewChargePageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGenWechatJSSDKSignatureReq

@implementation PB3GetGenWechatJSSDKSignatureReq

@dynamic appId;
@dynamic URL;

typedef struct PB3GetGenWechatJSSDKSignatureReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
  NSString *URL;
} PB3GetGenWechatJSSDKSignatureReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGenWechatJSSDKSignatureReq_FieldNumber_AppId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGenWechatJSSDKSignatureReq__storage_, appId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGenWechatJSSDKSignatureReq_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetGenWechatJSSDKSignatureReq__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGenWechatJSSDKSignatureReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGenWechatJSSDKSignatureReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGenWechatJSSDKSignatureRes

@implementation PB3GetGenWechatJSSDKSignatureRes

@dynamic timestamp;
@dynamic nonceStr;
@dynamic signature;

typedef struct PB3GetGenWechatJSSDKSignatureRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *nonceStr;
  NSString *signature;
  int64_t timestamp;
} PB3GetGenWechatJSSDKSignatureRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGenWechatJSSDKSignatureRes_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGenWechatJSSDKSignatureRes__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nonceStr",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGenWechatJSSDKSignatureRes_FieldNumber_NonceStr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetGenWechatJSSDKSignatureRes__storage_, nonceStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGenWechatJSSDKSignatureRes_FieldNumber_Signature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetGenWechatJSSDKSignatureRes__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGenWechatJSSDKSignatureRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGenWechatJSSDKSignatureRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnomalyLoginSendCodeReq

@implementation PB3AnomalyLoginSendCodeReq

@dynamic userId;

typedef struct PB3AnomalyLoginSendCodeReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t userId;
} PB3AnomalyLoginSendCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginSendCodeReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginSendCodeReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnomalyLoginSendCodeReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AnomalyLoginSendCodeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnomalyLoginSendCodeRes

@implementation PB3AnomalyLoginSendCodeRes


typedef struct PB3AnomalyLoginSendCodeRes__storage_ {
  uint32_t _has_storage_[1];
} PB3AnomalyLoginSendCodeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnomalyLoginSendCodeRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AnomalyLoginSendCodeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnomalyLoginConfirmCodeReq

@implementation PB3AnomalyLoginConfirmCodeReq

@dynamic code;
@dynamic userId;

typedef struct PB3AnomalyLoginConfirmCodeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
  int64_t userId;
} PB3AnomalyLoginConfirmCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeReq_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnomalyLoginConfirmCodeReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AnomalyLoginConfirmCodeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AnomalyLoginConfirmCodeRes

@implementation PB3AnomalyLoginConfirmCodeRes

@dynamic loginToken;
@dynamic isNew;
@dynamic userId;
@dynamic extends, extends_Count;
@dynamic loginType;

typedef struct PB3AnomalyLoginConfirmCodeRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ClientLoginType loginType;
  NSString *loginToken;
  NSMutableDictionary *extends;
  int64_t userId;
} PB3AnomalyLoginConfirmCodeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loginToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeRes_FieldNumber_LoginToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeRes__storage_, loginToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isNew",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeRes_FieldNumber_IsNew,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeRes_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeRes__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "extends",
        .dataTypeSpecific.className = NULL,
        .number = PB3AnomalyLoginConfirmCodeRes_FieldNumber_Extends,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeRes__storage_, extends),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginType",
        .dataTypeSpecific.enumDescFunc = PB3ClientLoginType_EnumDescriptor,
        .number = PB3AnomalyLoginConfirmCodeRes_FieldNumber_LoginType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AnomalyLoginConfirmCodeRes__storage_, loginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AnomalyLoginConfirmCodeRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AnomalyLoginConfirmCodeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AnomalyLoginConfirmCodeRes_LoginType_RawValue(PB3AnomalyLoginConfirmCodeRes *message) {
  GPBDescriptor *descriptor = [PB3AnomalyLoginConfirmCodeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AnomalyLoginConfirmCodeRes_FieldNumber_LoginType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AnomalyLoginConfirmCodeRes_LoginType_RawValue(PB3AnomalyLoginConfirmCodeRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AnomalyLoginConfirmCodeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AnomalyLoginConfirmCodeRes_FieldNumber_LoginType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CompositeSearchReq

@implementation PB3CompositeSearchReq

@dynamic searchTypesArray, searchTypesArray_Count;
@dynamic name;
@dynamic page;

typedef struct PB3CompositeSearchReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  GPBEnumArray *searchTypesArray;
  NSString *name;
} PB3CompositeSearchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchTypesArray",
        .dataTypeSpecific.enumDescFunc = PB3CompositeSearchType_EnumDescriptor,
        .number = PB3CompositeSearchReq_FieldNumber_SearchTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CompositeSearchReq__storage_, searchTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CompositeSearchReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CompositeSearchReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3CompositeSearchReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CompositeSearchReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CompositeSearchReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CompositeSearchReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CompositeSearchRes

@implementation PB3CompositeSearchRes

@dynamic roomListArray, roomListArray_Count;
@dynamic playerListArray, playerListArray_Count;

typedef struct PB3CompositeSearchRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *roomListArray;
  NSMutableArray *playerListArray;
} PB3CompositeSearchRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3CompositeSearchRes_FieldNumber_RoomListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CompositeSearchRes__storage_, roomListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SearchPlayerEntry),
        .number = PB3CompositeSearchRes_FieldNumber_PlayerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CompositeSearchRes__storage_, playerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CompositeSearchRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CompositeSearchRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProxyInvokeIntServerFuncReq

@implementation PB3ProxyInvokeIntServerFuncReq

@dynamic objName;
@dynamic funcName;
@dynamic reqData;

typedef struct PB3ProxyInvokeIntServerFuncReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *objName;
  NSString *funcName;
  NSData *reqData;
} PB3ProxyInvokeIntServerFuncReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "objName",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProxyInvokeIntServerFuncReq_FieldNumber_ObjName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProxyInvokeIntServerFuncReq__storage_, objName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "funcName",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProxyInvokeIntServerFuncReq_FieldNumber_FuncName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ProxyInvokeIntServerFuncReq__storage_, funcName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reqData",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProxyInvokeIntServerFuncReq_FieldNumber_ReqData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ProxyInvokeIntServerFuncReq__storage_, reqData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProxyInvokeIntServerFuncReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProxyInvokeIntServerFuncReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProxyInvokeIntServerFuncRes

@implementation PB3ProxyInvokeIntServerFuncRes


typedef struct PB3ProxyInvokeIntServerFuncRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ProxyInvokeIntServerFuncRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProxyInvokeIntServerFuncRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ProxyInvokeIntServerFuncRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSysConfUrlReq

@implementation PB3GetSysConfUrlReq

@dynamic sysType;

typedef struct PB3GetSysConfUrlReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SysConfType sysType;
} PB3GetSysConfUrlReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sysType",
        .dataTypeSpecific.enumDescFunc = PB3SysConfType_EnumDescriptor,
        .number = PB3GetSysConfUrlReq_FieldNumber_SysType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSysConfUrlReq__storage_, sysType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSysConfUrlReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSysConfUrlReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetSysConfUrlReq_SysType_RawValue(PB3GetSysConfUrlReq *message) {
  GPBDescriptor *descriptor = [PB3GetSysConfUrlReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetSysConfUrlReq_FieldNumber_SysType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetSysConfUrlReq_SysType_RawValue(PB3GetSysConfUrlReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetSysConfUrlReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetSysConfUrlReq_FieldNumber_SysType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetSysConfUrlRes

@implementation PB3GetSysConfUrlRes

@dynamic URL;

typedef struct PB3GetSysConfUrlRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} PB3GetSysConfUrlRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetSysConfUrlRes_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSysConfUrlRes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSysConfUrlRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSysConfUrlRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RankShowCfgReq

@implementation PB3RankShowCfgReq


typedef struct PB3RankShowCfgReq__storage_ {
  uint32_t _has_storage_[1];
} PB3RankShowCfgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RankShowCfgReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3RankShowCfgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CustomerTypeReq

@implementation PB3CustomerTypeReq

@dynamic customerType;

typedef struct PB3CustomerTypeReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ReqCustomerType customerType;
} PB3CustomerTypeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "customerType",
        .dataTypeSpecific.enumDescFunc = PB3ReqCustomerType_EnumDescriptor,
        .number = PB3CustomerTypeReq_FieldNumber_CustomerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CustomerTypeReq__storage_, customerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CustomerTypeReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CustomerTypeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CustomerTypeReq_CustomerType_RawValue(PB3CustomerTypeReq *message) {
  GPBDescriptor *descriptor = [PB3CustomerTypeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CustomerTypeReq_FieldNumber_CustomerType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CustomerTypeReq_CustomerType_RawValue(PB3CustomerTypeReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CustomerTypeReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CustomerTypeReq_FieldNumber_CustomerType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CustomerTypeRes

@implementation PB3CustomerTypeRes

@dynamic customerType;
@dynamic hasCustomerState, customerState;

typedef struct PB3CustomerTypeRes__storage_ {
  uint32_t _has_storage_[1];
  PB3ReqCustomerType customerType;
  PB3CustomerState *customerState;
} PB3CustomerTypeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "customerType",
        .dataTypeSpecific.enumDescFunc = PB3ReqCustomerType_EnumDescriptor,
        .number = PB3CustomerTypeRes_FieldNumber_CustomerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CustomerTypeRes__storage_, customerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "customerState",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CustomerState),
        .number = PB3CustomerTypeRes_FieldNumber_CustomerState,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CustomerTypeRes__storage_, customerState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CustomerTypeRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CustomerTypeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CustomerTypeRes_CustomerType_RawValue(PB3CustomerTypeRes *message) {
  GPBDescriptor *descriptor = [PB3CustomerTypeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CustomerTypeRes_FieldNumber_CustomerType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CustomerTypeRes_CustomerType_RawValue(PB3CustomerTypeRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CustomerTypeRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CustomerTypeRes_FieldNumber_CustomerType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CustomerState

@implementation PB3CustomerState

@dynamic businessState;
@dynamic promptsText;
@dynamic userCopyText;

typedef struct PB3CustomerState__storage_ {
  uint32_t _has_storage_[1];
  NSString *promptsText;
  NSString *userCopyText;
} PB3CustomerState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "businessState",
        .dataTypeSpecific.className = NULL,
        .number = PB3CustomerState_FieldNumber_BusinessState,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "promptsText",
        .dataTypeSpecific.className = NULL,
        .number = PB3CustomerState_FieldNumber_PromptsText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CustomerState__storage_, promptsText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userCopyText",
        .dataTypeSpecific.className = NULL,
        .number = PB3CustomerState_FieldNumber_UserCopyText,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CustomerState__storage_, userCopyText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CustomerState class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CustomerState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BlackWhaleCustomerCfgData

@implementation PB3BlackWhaleCustomerCfgData

@dynamic monday;
@dynamic tuesday;
@dynamic wednesday;
@dynamic thursday;
@dynamic friday;
@dynamic saturday;
@dynamic sunday;
@dynamic promptsText;
@dynamic userCopyText;

typedef struct PB3BlackWhaleCustomerCfgData__storage_ {
  uint32_t _has_storage_[1];
  NSString *monday;
  NSString *tuesday;
  NSString *wednesday;
  NSString *thursday;
  NSString *friday;
  NSString *saturday;
  NSString *sunday;
  NSString *promptsText;
  NSString *userCopyText;
} PB3BlackWhaleCustomerCfgData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "monday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Monday,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, monday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tuesday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Tuesday,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, tuesday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wednesday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Wednesday,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, wednesday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thursday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Thursday,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, thursday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Friday,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, friday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "saturday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Saturday,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, saturday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sunday",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_Sunday,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, sunday),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "promptsText",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_PromptsText,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, promptsText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userCopyText",
        .dataTypeSpecific.className = NULL,
        .number = PB3BlackWhaleCustomerCfgData_FieldNumber_UserCopyText,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BlackWhaleCustomerCfgData__storage_, userCopyText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BlackWhaleCustomerCfgData class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BlackWhaleCustomerCfgData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRealmNameConfReq

@implementation PB3GetRealmNameConfReq


typedef struct PB3GetRealmNameConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetRealmNameConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRealmNameConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetRealmNameConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRealmNameConfRes

@implementation PB3GetRealmNameConfRes

@dynamic version;
@dynamic realmNameListArray, realmNameListArray_Count;

typedef struct PB3GetRealmNameConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSMutableArray *realmNameListArray;
} PB3GetRealmNameConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRealmNameConfRes_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetRealmNameConfRes__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realmNameListArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRealmNameConfRes_FieldNumber_RealmNameListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetRealmNameConfRes__storage_, realmNameListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRealmNameConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRealmNameConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PullOxygenCarGiftReq

@implementation PB3PullOxygenCarGiftReq


typedef struct PB3PullOxygenCarGiftReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PullOxygenCarGiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullOxygenCarGiftReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PullOxygenCarGiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PullOxygenCarGiftRes

@implementation PB3PullOxygenCarGiftRes

@dynamic hasCfg, cfg;

typedef struct PB3PullOxygenCarGiftRes__storage_ {
  uint32_t _has_storage_[1];
  PB3XcmOxygenCarGiftCfgData *cfg;
} PB3PullOxygenCarGiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cfg",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3XcmOxygenCarGiftCfgData),
        .number = PB3PullOxygenCarGiftRes_FieldNumber_Cfg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PullOxygenCarGiftRes__storage_, cfg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullOxygenCarGiftRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PullOxygenCarGiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ActSubInfo

@implementation PB3ActSubInfo

@dynamic id_p;
@dynamic name;
@dynamic routerURL;
@dynamic startTime;
@dynamic endTime;
@dynamic bgURL;
@dynamic pcBgURL;
@dynamic showPattern, showPattern_Count;
@dynamic isShow;
@dynamic icon;
@dynamic pcIcon;

typedef struct PB3ActSubInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *routerURL;
  NSString *bgURL;
  NSString *pcBgURL;
  GPBInt32BoolDictionary *showPattern;
  NSString *icon;
  NSString *pcIcon;
  int64_t id_p;
  int64_t startTime;
  int64_t endTime;
} PB3ActSubInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_RouterURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_EndTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "bgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_BgURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, bgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_PcBgURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, pcBgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showPattern",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_ShowPattern,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, showPattern),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_IsShow,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_Icon,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfo_FieldNumber_PcIcon,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3ActSubInfo__storage_, pcIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ActSubInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ActSubInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\006\241!!\000\006\002\241!!\000\007\002\242\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListActSubInfoReq

@implementation PB3ListActSubInfoReq

@dynamic roomId;
@dynamic reqFromType;

typedef struct PB3ListActSubInfoReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ReqFromType reqFromType;
  int64_t roomId;
} PB3ListActSubInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListActSubInfoReq_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ListActSubInfoReq__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reqFromType",
        .dataTypeSpecific.enumDescFunc = PB3ReqFromType_EnumDescriptor,
        .number = PB3ListActSubInfoReq_FieldNumber_ReqFromType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ListActSubInfoReq__storage_, reqFromType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListActSubInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListActSubInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ListActSubInfoReq_ReqFromType_RawValue(PB3ListActSubInfoReq *message) {
  GPBDescriptor *descriptor = [PB3ListActSubInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ListActSubInfoReq_FieldNumber_ReqFromType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ListActSubInfoReq_ReqFromType_RawValue(PB3ListActSubInfoReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ListActSubInfoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ListActSubInfoReq_FieldNumber_ReqFromType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ListActSubInfoRes

@implementation PB3ListActSubInfoRes

@dynamic isClick;
@dynamic listArray, listArray_Count;

typedef struct PB3ListActSubInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListActSubInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isClick",
        .dataTypeSpecific.className = NULL,
        .number = PB3ListActSubInfoRes_FieldNumber_IsClick,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ActSubInfo),
        .number = PB3ListActSubInfoRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListActSubInfoRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListActSubInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListActSubInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ActSubInfoPush

@implementation PB3ActSubInfoPush

@dynamic roomId;
@dynamic hasInfo, info;

typedef struct PB3ActSubInfoPush__storage_ {
  uint32_t _has_storage_[1];
  PB3ListActSubInfoRes *info;
  int64_t roomId;
} PB3ActSubInfoPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActSubInfoPush_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ActSubInfoPush__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ListActSubInfoRes),
        .number = PB3ActSubInfoPush_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ActSubInfoPush__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ActSubInfoPush class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ActSubInfoPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClickActSubInfoReq

@implementation PB3ClickActSubInfoReq

@dynamic id_p;

typedef struct PB3ClickActSubInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3ClickActSubInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickActSubInfoReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClickActSubInfoReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickActSubInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClickActSubInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClickActSubInfoRes

@implementation PB3ClickActSubInfoRes


typedef struct PB3ClickActSubInfoRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClickActSubInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickActSubInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClickActSubInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CallbackAdminHandleYoungModelReq

@implementation PB3CallbackAdminHandleYoungModelReq


typedef struct PB3CallbackAdminHandleYoungModelReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CallbackAdminHandleYoungModelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CallbackAdminHandleYoungModelReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CallbackAdminHandleYoungModelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CallbackAdminHandleYoungModelRes

@implementation PB3CallbackAdminHandleYoungModelRes


typedef struct PB3CallbackAdminHandleYoungModelRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CallbackAdminHandleYoungModelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CallbackAdminHandleYoungModelRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CallbackAdminHandleYoungModelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
