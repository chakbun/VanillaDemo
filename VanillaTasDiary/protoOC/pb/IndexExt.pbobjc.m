// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/index.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "pb/IndexExt.pbobjc.h"
#import "pb/CommonExt.pbobjc.h"
#import "pb/PlayExt.pbobjc.h"
#import "pb/ShowExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3IndexExtRoot

@implementation PB3IndexExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3IndexExtRoot_FileDescriptor

static GPBFileDescriptor *PB3IndexExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3IndexErr

GPBEnumDescriptor *PB3IndexErr_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ErrIndexZero\000";
    static const int32_t values[] = {
        PB3IndexErr_ErrIndexZero,
    };
    static const char *extraTextFormatInfo = "\001\000\010\344\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexErr)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexErr_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexErr_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexErr_ErrIndexZero:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexCmdId

GPBEnumDescriptor *PB3IndexCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcIndexZero\000IcActivityRoom\000IcSearchRoom\000"
        "IcYoungModel\000IcExchangeCode\000IcAcGameConf"
        "\000IcThemeConfig\000IcPendantConfig\000IcHomePus"
        "hApppopUp\000IcProtocolConfInfo\000";
    static const int32_t values[] = {
        PB3IndexCmdId_IcIndexZero,
        PB3IndexCmdId_IcActivityRoom,
        PB3IndexCmdId_IcSearchRoom,
        PB3IndexCmdId_IcYoungModel,
        PB3IndexCmdId_IcExchangeCode,
        PB3IndexCmdId_IcAcGameConf,
        PB3IndexCmdId_IcThemeConfig,
        PB3IndexCmdId_IcPendantConfig,
        PB3IndexCmdId_IcHomePushApppopUp,
        PB3IndexCmdId_IcProtocolConfInfo,
    };
    static const char *extraTextFormatInfo = "\n\000b\211\000\001b\214\000\002b\212\000\003b\212\000\004b\214\000\005b\212\000\006b\213\000\007b\215\000\010b\211c\003A\000\tb\220\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexCmdId_IcIndexZero:
    case PB3IndexCmdId_IcActivityRoom:
    case PB3IndexCmdId_IcSearchRoom:
    case PB3IndexCmdId_IcYoungModel:
    case PB3IndexCmdId_IcExchangeCode:
    case PB3IndexCmdId_IcAcGameConf:
    case PB3IndexCmdId_IcThemeConfig:
    case PB3IndexCmdId_IcPendantConfig:
    case PB3IndexCmdId_IcHomePushApppopUp:
    case PB3IndexCmdId_IcProtocolConfInfo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexTab

GPBEnumDescriptor *PB3IndexTab_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TabZore\000TabNew\000TabHot\000TabRecommend\000TabKe"
        "yWord\000TabCall\000TabSupperMan\000TabMoreHot\000Ta"
        "bUserDefine\000TabTjKeyWord\000TabRecommendV2\000";
    static const int32_t values[] = {
        PB3IndexTab_TabZore,
        PB3IndexTab_TabNew,
        PB3IndexTab_TabHot,
        PB3IndexTab_TabRecommend,
        PB3IndexTab_TabKeyWord,
        PB3IndexTab_TabCall,
        PB3IndexTab_TabSupperMan,
        PB3IndexTab_TabMoreHot,
        PB3IndexTab_TabUserDefine,
        PB3IndexTab_TabTjKeyWord,
        PB3IndexTab_TabRecommendV2,
    };
    static const char *extraTextFormatInfo = "\013\000c\204\000\001c\203\000\002c\203\000\003c\211\000\004c\207\000\005c\204\000\006c\211\000\007c\207\000\010c\212\000\tc\342\207\000\nc\211\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexTab)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexTab_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexTab_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexTab_TabZore:
    case PB3IndexTab_TabNew:
    case PB3IndexTab_TabHot:
    case PB3IndexTab_TabRecommend:
    case PB3IndexTab_TabKeyWord:
    case PB3IndexTab_TabCall:
    case PB3IndexTab_TabSupperMan:
    case PB3IndexTab_TabMoreHot:
    case PB3IndexTab_TabUserDefine:
    case PB3IndexTab_TabTjKeyWord:
    case PB3IndexTab_TabRecommendV2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexConfType

GPBEnumDescriptor *PB3IndexConfType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ConfZore\000ConfSubscript\000ConfAcGameLimit\000";
    static const int32_t values[] = {
        PB3IndexConfType_ConfZore,
        PB3IndexConfType_ConfSubscript,
        PB3IndexConfType_ConfAcGameLimit,
    };
    static const char *extraTextFormatInfo = "\003\000\004\204\000\001\004\211\000\002\004\202\204\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexConfType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexConfType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexConfType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexConfType_ConfZore:
    case PB3IndexConfType_ConfSubscript:
    case PB3IndexConfType_ConfAcGameLimit:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3GameRankType

GPBEnumDescriptor *PB3GameRankType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GrtZero\000GrtAll\000";
    static const int32_t values[] = {
        PB3GameRankType_GrtZero,
        PB3GameRankType_GrtAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3GameRankType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3GameRankType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3GameRankType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3GameRankType_GrtZero:
    case PB3GameRankType_GrtAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3GameRankScoreStyle

GPBEnumDescriptor *PB3GameRankScoreStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GrssZero\000GrssScore\000GrssMoney\000";
    static const int32_t values[] = {
        PB3GameRankScoreStyle_GrssZero,
        PB3GameRankScoreStyle_GrssScore,
        PB3GameRankScoreStyle_GrssMoney,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3GameRankScoreStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3GameRankScoreStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3GameRankScoreStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3GameRankScoreStyle_GrssZero:
    case PB3GameRankScoreStyle_GrssScore:
    case PB3GameRankScoreStyle_GrssMoney:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ActivityPicJumpType

GPBEnumDescriptor *PB3ActivityPicJumpType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "JumpZero\000JumpInterface\000JumpURL\000JumpGame\000";
    static const int32_t values[] = {
        PB3ActivityPicJumpType_JumpZero,
        PB3ActivityPicJumpType_JumpInterface,
        PB3ActivityPicJumpType_JumpURL,
        PB3ActivityPicJumpType_JumpGame,
    };
    static const char *extraTextFormatInfo = "\001\002d\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ActivityPicJumpType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ActivityPicJumpType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ActivityPicJumpType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ActivityPicJumpType_JumpZero:
    case PB3ActivityPicJumpType_JumpInterface:
    case PB3ActivityPicJumpType_JumpURL:
    case PB3ActivityPicJumpType_JumpGame:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3JumpInterfaceType

GPBEnumDescriptor *PB3JumpInterfaceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "JumpInterfaceZero\000JumpInterfaceIndex\000Jum"
        "pInterfaceFind\000JumpInterfaceSquare\000";
    static const int32_t values[] = {
        PB3JumpInterfaceType_JumpInterfaceZero,
        PB3JumpInterfaceType_JumpInterfaceIndex,
        PB3JumpInterfaceType_JumpInterfaceFind,
        PB3JumpInterfaceType_JumpInterfaceSquare,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3JumpInterfaceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3JumpInterfaceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3JumpInterfaceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3JumpInterfaceType_JumpInterfaceZero:
    case PB3JumpInterfaceType_JumpInterfaceIndex:
    case PB3JumpInterfaceType_JumpInterfaceFind:
    case PB3JumpInterfaceType_JumpInterfaceSquare:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ActivityPicReportType

GPBEnumDescriptor *PB3ActivityPicReportType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PicReportZero\000PicReportExposure\000PicRepor"
        "tClick\000";
    static const int32_t values[] = {
        PB3ActivityPicReportType_PicReportZero,
        PB3ActivityPicReportType_PicReportExposure,
        PB3ActivityPicReportType_PicReportClick,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ActivityPicReportType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ActivityPicReportType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ActivityPicReportType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ActivityPicReportType_PicReportZero:
    case PB3ActivityPicReportType_PicReportExposure:
    case PB3ActivityPicReportType_PicReportClick:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ClickType

GPBEnumDescriptor *PB3ClickType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClickBroadFriend\000ClickRecommend\000ClickPer"
        "sonal\000ClIckRecommendV2\000";
    static const int32_t values[] = {
        PB3ClickType_ClickBroadFriend,
        PB3ClickType_ClickRecommend,
        PB3ClickType_ClickPersonal,
        PB3ClickType_ClIckRecommendV2,
    };
    static const char *extraTextFormatInfo = "\001\003\003b\351\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClickType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClickType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClickType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClickType_ClickBroadFriend:
    case PB3ClickType_ClickRecommend:
    case PB3ClickType_ClickPersonal:
    case PB3ClickType_ClIckRecommendV2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPwdType

GPBEnumDescriptor *PB3YoungModelPwdType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPwdTypeZero\000YoungModelPwdTypeS"
        "et\000YoungModelPwdTypeOpen\000YoungModelPwdTy"
        "peClosed\000YoungModelPwdTypeModify\000YoungMo"
        "delPwdTypeForget\000YoungModelPwdTypeOrigin"
        "\000YoungModelPwdTypeRenewal\000";
    static const int32_t values[] = {
        PB3YoungModelPwdType_YoungModelPwdTypeZero,
        PB3YoungModelPwdType_YoungModelPwdTypeSet,
        PB3YoungModelPwdType_YoungModelPwdTypeOpen,
        PB3YoungModelPwdType_YoungModelPwdTypeClosed,
        PB3YoungModelPwdType_YoungModelPwdTypeModify,
        PB3YoungModelPwdType_YoungModelPwdTypeForget,
        PB3YoungModelPwdType_YoungModelPwdTypeOrigin,
        PB3YoungModelPwdType_YoungModelPwdTypeRenewal,
    };
    static const char *extraTextFormatInfo = "\010\000\021\204\000\001\021\203\000\002\021\204\000\003\021\206\000\004\021\206\000\005\021\206\000\006\021\206\000\007\021\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPwdType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPwdType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPwdType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPwdType_YoungModelPwdTypeZero:
    case PB3YoungModelPwdType_YoungModelPwdTypeSet:
    case PB3YoungModelPwdType_YoungModelPwdTypeOpen:
    case PB3YoungModelPwdType_YoungModelPwdTypeClosed:
    case PB3YoungModelPwdType_YoungModelPwdTypeModify:
    case PB3YoungModelPwdType_YoungModelPwdTypeForget:
    case PB3YoungModelPwdType_YoungModelPwdTypeOrigin:
    case PB3YoungModelPwdType_YoungModelPwdTypeRenewal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPhoneType

GPBEnumDescriptor *PB3YoungModelPhoneType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPhoneTypeZero\000YoungModelPhoneT"
        "ypeGet\000YoungModelPwdTypeSendCode\000YoungMo"
        "delPwdTypeConfirmCode\000";
    static const int32_t values[] = {
        PB3YoungModelPhoneType_YoungModelPhoneTypeZero,
        PB3YoungModelPhoneType_YoungModelPhoneTypeGet,
        PB3YoungModelPhoneType_YoungModelPwdTypeSendCode,
        PB3YoungModelPhoneType_YoungModelPwdTypeConfirmCode,
    };
    static const char *extraTextFormatInfo = "\004\000\023\204\000\001\023\203\000\002\021\210\000\003\021\213\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPhoneType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPhoneType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPhoneType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPhoneType_YoungModelPhoneTypeZero:
    case PB3YoungModelPhoneType_YoungModelPhoneTypeGet:
    case PB3YoungModelPhoneType_YoungModelPwdTypeSendCode:
    case PB3YoungModelPhoneType_YoungModelPwdTypeConfirmCode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3YoungModelPageType

GPBEnumDescriptor *PB3YoungModelPageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "YoungModelPageTypeZero\000YoungModelPageTyp"
        "eTimeout\000YoungModelPageTypeBanNight\000";
    static const int32_t values[] = {
        PB3YoungModelPageType_YoungModelPageTypeZero,
        PB3YoungModelPageType_YoungModelPageTypeTimeout,
        PB3YoungModelPageType_YoungModelPageTypeBanNight,
    };
    static const char *extraTextFormatInfo = "\003\000\022\204\000\001\022\207\000\002\022\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3YoungModelPageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3YoungModelPageType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3YoungModelPageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3YoungModelPageType_YoungModelPageTypeZero:
    case PB3YoungModelPageType_YoungModelPageTypeTimeout:
    case PB3YoungModelPageType_YoungModelPageTypeBanNight:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WeekStarType

GPBEnumDescriptor *PB3WeekStarType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ThisWeek\000LastWeek\000";
    static const int32_t values[] = {
        PB3WeekStarType_ThisWeek,
        PB3WeekStarType_LastWeek,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WeekStarType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WeekStarType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WeekStarType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WeekStarType_ThisWeek:
    case PB3WeekStarType_LastWeek:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AdEventType

GPBEnumDescriptor *PB3AdEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Activate\000Register\000Recharge\000";
    static const int32_t values[] = {
        PB3AdEventType_Activate,
        PB3AdEventType_Register,
        PB3AdEventType_Recharge,
    };
    static const char *extraTextFormatInfo = "\003\000\010\000\001\010\000\002\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AdEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AdEventType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AdEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AdEventType_Activate:
    case PB3AdEventType_Register:
    case PB3AdEventType_Recharge:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3SensitiveWordLib

GPBEnumDescriptor *PB3SensitiveWordLib_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SensitiveWordLibNone\000SensitiveWordLibNam"
        "e\000";
    static const int32_t values[] = {
        PB3SensitiveWordLib_SensitiveWordLibNone,
        PB3SensitiveWordLib_SensitiveWordLibName,
    };
    static const char *extraTextFormatInfo = "\002\000\020\204\000\001\020\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3SensitiveWordLib)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3SensitiveWordLib_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3SensitiveWordLib_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3SensitiveWordLib_SensitiveWordLibNone:
    case PB3SensitiveWordLib_SensitiveWordLibName:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ReportType

GPBEnumDescriptor *PB3ReportType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Politics\000Sexy\000Advert\000Other\000Child\000Protect"
        "ion\000Song\000History\000Violence\000PersonalAbues\000"
        "Spam\000";
    static const int32_t values[] = {
        PB3ReportType_Politics,
        PB3ReportType_Sexy,
        PB3ReportType_Advert,
        PB3ReportType_Other,
        PB3ReportType_Child,
        PB3ReportType_Protection,
        PB3ReportType_Song,
        PB3ReportType_History,
        PB3ReportType_Violence,
        PB3ReportType_PersonalAbues,
        PB3ReportType_Spam,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ReportType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ReportType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ReportType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ReportType_Politics:
    case PB3ReportType_Sexy:
    case PB3ReportType_Advert:
    case PB3ReportType_Other:
    case PB3ReportType_Child:
    case PB3ReportType_Protection:
    case PB3ReportType_Song:
    case PB3ReportType_History:
    case PB3ReportType_Violence:
    case PB3ReportType_PersonalAbues:
    case PB3ReportType_Spam:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ReportSceneType

GPBEnumDescriptor *PB3ReportSceneType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RepstNone\000RepstTrend\000RepstUser\000RepstIm\000R"
        "epstRoom\000";
    static const int32_t values[] = {
        PB3ReportSceneType_RepstNone,
        PB3ReportSceneType_RepstTrend,
        PB3ReportSceneType_RepstUser,
        PB3ReportSceneType_RepstIm,
        PB3ReportSceneType_RepstRoom,
    };
    static const char *extraTextFormatInfo = "\004\000e\204\000\001e\205\000\002e\204\000\004e\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ReportSceneType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ReportSceneType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ReportSceneType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ReportSceneType_RepstNone:
    case PB3ReportSceneType_RepstTrend:
    case PB3ReportSceneType_RepstUser:
    case PB3ReportSceneType_RepstIm:
    case PB3ReportSceneType_RepstRoom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3WechatNotifyType

GPBEnumDescriptor *PB3WechatNotifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WntNone\000WntVisit\000WntOrder\000WntMsg\000WntBill"
        "\000";
    static const int32_t values[] = {
        PB3WechatNotifyType_WntNone,
        PB3WechatNotifyType_WntVisit,
        PB3WechatNotifyType_WntOrder,
        PB3WechatNotifyType_WntMsg,
        PB3WechatNotifyType_WntBill,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3WechatNotifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3WechatNotifyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3WechatNotifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3WechatNotifyType_WntNone:
    case PB3WechatNotifyType_WntVisit:
    case PB3WechatNotifyType_WntOrder:
    case PB3WechatNotifyType_WntMsg:
    case PB3WechatNotifyType_WntBill:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TaxConfType

GPBEnumDescriptor *PB3TaxConfType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TaxConfTypeNone\000TaxConfTypeWhiteList\000";
    static const int32_t values[] = {
        PB3TaxConfType_TaxConfTypeNone,
        PB3TaxConfType_TaxConfTypeWhiteList,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TaxConfType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TaxConfType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TaxConfType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TaxConfType_TaxConfTypeNone:
    case PB3TaxConfType_TaxConfTypeWhiteList:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3IndexAcGameType

GPBEnumDescriptor *PB3IndexAcGameType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IagtNone\000IagtClimbingTower\000IagtUfo\000IagtH"
        "5All\000IagtH5Half\000";
    static const int32_t values[] = {
        PB3IndexAcGameType_IagtNone,
        PB3IndexAcGameType_IagtClimbingTower,
        PB3IndexAcGameType_IagtUfo,
        PB3IndexAcGameType_IagtH5All,
        PB3IndexAcGameType_IagtH5Half,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3IndexAcGameType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3IndexAcGameType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3IndexAcGameType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3IndexAcGameType_IagtNone:
    case PB3IndexAcGameType_IagtClimbingTower:
    case PB3IndexAcGameType_IagtUfo:
    case PB3IndexAcGameType_IagtH5All:
    case PB3IndexAcGameType_IagtH5Half:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PendantState

GPBEnumDescriptor *PB3PendantState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PendantDefault\000PendantStatic\000PendantMove"
        "\000";
    static const int32_t values[] = {
        PB3PendantState_PendantDefault,
        PB3PendantState_PendantStatic,
        PB3PendantState_PendantMove,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PendantState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PendantState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PendantState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PendantState_PendantDefault:
    case PB3PendantState_PendantStatic:
    case PB3PendantState_PendantMove:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PendantType

GPBEnumDescriptor *PB3PendantType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PtZero\000PtMusic\000PtH5\000PtShengdian\000PtOrder\000"
        "PtChatCp\000";
    static const int32_t values[] = {
        PB3PendantType_PtZero,
        PB3PendantType_PtMusic,
        PB3PendantType_PtH5,
        PB3PendantType_PtShengdian,
        PB3PendantType_PtOrder,
        PB3PendantType_PtChatCp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PendantType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PendantType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PendantType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PendantType_PtZero:
    case PB3PendantType_PtMusic:
    case PB3PendantType_PtH5:
    case PB3PendantType_PtShengdian:
    case PB3PendantType_PtOrder:
    case PB3PendantType_PtChatCp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3BannerState

GPBEnumDescriptor *PB3BannerState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BannerDefault\000BannerOpen\000BannerHide\000";
    static const int32_t values[] = {
        PB3BannerState_BannerDefault,
        PB3BannerState_BannerOpen,
        PB3BannerState_BannerHide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3BannerState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3BannerState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3BannerState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3BannerState_BannerDefault:
    case PB3BannerState_BannerOpen:
    case PB3BannerState_BannerHide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3EventTrackingArgType

GPBEnumDescriptor *PB3EventTrackingArgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EtatUnknow\000EtatInt\000EtatStr\000EtatFloat\000";
    static const int32_t values[] = {
        PB3EventTrackingArgType_EtatUnknow,
        PB3EventTrackingArgType_EtatInt,
        PB3EventTrackingArgType_EtatStr,
        PB3EventTrackingArgType_EtatFloat,
    };
    static const char *extraTextFormatInfo = "\004\000d\206\000\001d\203\000\002d\203\000\003d\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3EventTrackingArgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3EventTrackingArgType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3EventTrackingArgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3EventTrackingArgType_EtatUnknow:
    case PB3EventTrackingArgType_EtatInt:
    case PB3EventTrackingArgType_EtatStr:
    case PB3EventTrackingArgType_EtatFloat:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TouchAreaType

GPBEnumDescriptor *PB3TouchAreaType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TatNone\000TatButton\000TatPicture\000TatAll\000";
    static const int32_t values[] = {
        PB3TouchAreaType_TatNone,
        PB3TouchAreaType_TatButton,
        PB3TouchAreaType_TatPicture,
        PB3TouchAreaType_TatAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TouchAreaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TouchAreaType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TouchAreaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TouchAreaType_TatNone:
    case PB3TouchAreaType_TatButton:
    case PB3TouchAreaType_TatPicture:
    case PB3TouchAreaType_TatAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TargetType

GPBEnumDescriptor *PB3TargetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TtNone\000TtCustomizeId\000TtOnline\000TtInstallI"
        "n\000TtCharge\000";
    static const int32_t values[] = {
        PB3TargetType_TtNone,
        PB3TargetType_TtCustomizeId,
        PB3TargetType_TtOnline,
        PB3TargetType_TtInstallIn,
        PB3TargetType_TtCharge,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TargetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TargetType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TargetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TargetType_TtNone:
    case PB3TargetType_TtCustomizeId:
    case PB3TargetType_TtOnline:
    case PB3TargetType_TtInstallIn:
    case PB3TargetType_TtCharge:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AppearArea

GPBEnumDescriptor *PB3AppearArea_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AaNone\000AaAllArea\000AaRoomArea\000AaIndexArea\000";
    static const int32_t values[] = {
        PB3AppearArea_AaNone,
        PB3AppearArea_AaAllArea,
        PB3AppearArea_AaRoomArea,
        PB3AppearArea_AaIndexArea,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AppearArea)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AppearArea_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AppearArea_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AppearArea_AaNone:
    case PB3AppearArea_AaAllArea:
    case PB3AppearArea_AaRoomArea:
    case PB3AppearArea_AaIndexArea:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3GetIndexTabReq

@implementation PB3GetIndexTabReq


typedef struct PB3GetIndexTabReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetIndexTabReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetIndexTabReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetIndexTabReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetIndexTabRes

@implementation PB3GetIndexTabRes

@dynamic tabsArray, tabsArray_Count;

typedef struct PB3GetIndexTabRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabsArray;
} PB3GetIndexTabRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetIndexTabRes_FieldNumber_TabsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetIndexTabRes__storage_, tabsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetIndexTabRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetIndexTabRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetHotSearchWordReq

@implementation PB3GetHotSearchWordReq


typedef struct PB3GetHotSearchWordReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetHotSearchWordReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetHotSearchWordReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetHotSearchWordReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetHotSearchWordRes

@implementation PB3GetHotSearchWordRes

@dynamic hotSearchWordArray, hotSearchWordArray_Count;

typedef struct PB3GetHotSearchWordRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hotSearchWordArray;
} PB3GetHotSearchWordRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotSearchWordArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetHotSearchWordRes_FieldNumber_HotSearchWordArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetHotSearchWordRes__storage_, hotSearchWordArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetHotSearchWordRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetHotSearchWordRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TabListReq

@implementation PB3TabListReq

@dynamic tab;
@dynamic position;
@dynamic keyWord;
@dynamic sex;
@dynamic page;
@dynamic pageSize;
@dynamic mid;

typedef struct PB3TabListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3IndexTab tab;
  int32_t position;
  int32_t sex;
  int32_t page;
  int32_t pageSize;
  int32_t mid;
  NSString *keyWord;
} PB3TabListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3TabListReq_FieldNumber_Tab,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_KeyWord,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, keyWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Page,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_PageSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListReq_FieldNumber_Mid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3TabListReq__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TabListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TabListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TabListReq_Tab_RawValue(PB3TabListReq *message) {
  GPBDescriptor *descriptor = [PB3TabListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListReq_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TabListReq_Tab_RawValue(PB3TabListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TabListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListReq_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TabListRes

@implementation PB3TabListRes

@dynamic listArray, listArray_Count;
@dynamic mid;
@dynamic name;
@dynamic page;
@dynamic position;
@dynamic tab;
@dynamic sex;

typedef struct PB3TabListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t page;
  int32_t position;
  PB3IndexTab tab;
  int32_t sex;
  NSMutableArray *listArray;
  NSString *name;
} PB3TabListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3TabListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Position,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3TabListRes_FieldNumber_Tab,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3TabListRes_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TabListRes__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TabListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TabListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TabListRes_Tab_RawValue(PB3TabListRes *message) {
  GPBDescriptor *descriptor = [PB3TabListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListRes_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TabListRes_Tab_RawValue(PB3TabListRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TabListRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TabListRes_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3Recommend

@implementation PB3Recommend

@dynamic mid;
@dynamic sex;

typedef struct PB3Recommend__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t sex;
} PB3Recommend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3Recommend_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Recommend__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3Recommend_FieldNumber_Sex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Recommend__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Recommend class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Recommend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserDefineReq

@implementation PB3UserDefineReq

@dynamic tab;
@dynamic recommendsArray, recommendsArray_Count;

typedef struct PB3UserDefineReq__storage_ {
  uint32_t _has_storage_[1];
  PB3IndexTab tab;
  NSMutableArray *recommendsArray;
} PB3UserDefineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tab",
        .dataTypeSpecific.enumDescFunc = PB3IndexTab_EnumDescriptor,
        .number = PB3UserDefineReq_FieldNumber_Tab,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDefineReq__storage_, tab),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recommendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Recommend),
        .number = PB3UserDefineReq_FieldNumber_RecommendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefineReq__storage_, recommendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefineReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserDefineReq_Tab_RawValue(PB3UserDefineReq *message) {
  GPBDescriptor *descriptor = [PB3UserDefineReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDefineReq_FieldNumber_Tab];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserDefineReq_Tab_RawValue(PB3UserDefineReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserDefineReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserDefineReq_FieldNumber_Tab];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserDefineRes

@implementation PB3UserDefineRes

@dynamic userDefineArray, userDefineArray_Count;

typedef struct PB3UserDefineRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userDefineArray;
} PB3UserDefineRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userDefineArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UserDefined),
        .number = PB3UserDefineRes_FieldNumber_UserDefineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefineRes__storage_, userDefineArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefineRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefineRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserDefined

@implementation PB3UserDefined

@dynamic mid;
@dynamic name;
@dynamic listArray, listArray_Count;
@dynamic sex;

typedef struct PB3UserDefined__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t sex;
  NSString *name;
  NSMutableArray *listArray;
} PB3UserDefined__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3UserDefined_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserDefined_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserDefined__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserDefined class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserDefined__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAppAdConfigReq

@implementation PB3GetAppAdConfigReq


typedef struct PB3GetAppAdConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAppAdConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAppAdConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAppAdConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AppAdConfigInfo

@implementation PB3AppAdConfigInfo

@dynamic name;
@dynamic duration;
@dynamic URL;
@dynamic image;
@dynamic title;
@dynamic soundURL;

typedef struct PB3AppAdConfigInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  NSString *name;
  NSString *URL;
  NSString *image;
  NSString *title;
  NSString *soundURL;
} PB3AppAdConfigInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "soundURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppAdConfigInfo_FieldNumber_SoundURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AppAdConfigInfo__storage_, soundURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AppAdConfigInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AppAdConfigInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003!!!\000\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAppAdConfigRes

@implementation PB3GetAppAdConfigRes

@dynamic listArray, listArray_Count;

typedef struct PB3GetAppAdConfigRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3GetAppAdConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AppAdConfigInfo),
        .number = PB3GetAppAdConfigRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetAppAdConfigRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAppAdConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAppAdConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBannerReq

@implementation PB3IndexBannerReq

@dynamic language;

typedef struct PB3IndexBannerReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t language;
} PB3IndexBannerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerReq_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBannerReq__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBannerReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBannerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBanner

@implementation PB3IndexBanner

@dynamic name;
@dynamic bannerURL;
@dynamic tranType;
@dynamic tranURL;
@dynamic shareType;
@dynamic shareTitle;
@dynamic shareContent;
@dynamic shareImg;

typedef struct PB3IndexBanner__storage_ {
  uint32_t _has_storage_[1];
  int32_t tranType;
  int32_t shareType;
  NSString *name;
  NSString *bannerURL;
  NSString *tranURL;
  NSString *shareTitle;
  NSString *shareContent;
  NSString *shareImg;
} PB3IndexBanner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bannerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_BannerURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, bannerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tranType",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_TranType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, tranType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tranURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_TranURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, tranURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareType",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shareTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareTitle,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBanner_FieldNumber_ShareImg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3IndexBanner__storage_, shareImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBanner class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBanner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\006\241!!\000\004\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3IndexBannerRes

@implementation PB3IndexBannerRes

@dynamic flag;
@dynamic language;
@dynamic listArray, listArray_Count;

typedef struct PB3IndexBannerRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t flag;
  int32_t language;
  NSMutableArray *listArray;
} PB3IndexBannerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = PB3IndexBannerRes_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexBanner),
        .number = PB3IndexBannerRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3IndexBannerRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3IndexBannerRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3IndexBannerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClickCountReq

@implementation PB3ClickCountReq

@dynamic clickType;
@dynamic deviceId;
@dynamic mid;

typedef struct PB3ClickCountReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ClickType clickType;
  int32_t mid;
  NSString *deviceId;
} PB3ClickCountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clickType",
        .dataTypeSpecific.enumDescFunc = PB3ClickType_EnumDescriptor,
        .number = PB3ClickCountReq_FieldNumber_ClickType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, clickType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickCountReq_FieldNumber_DeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickCountReq_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ClickCountReq__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickCountReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClickCountReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClickCountReq_ClickType_RawValue(PB3ClickCountReq *message) {
  GPBDescriptor *descriptor = [PB3ClickCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickCountReq_FieldNumber_ClickType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClickCountReq_ClickType_RawValue(PB3ClickCountReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClickCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickCountReq_FieldNumber_ClickType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClickCountRes

@implementation PB3ClickCountRes


typedef struct PB3ClickCountRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClickCountRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickCountRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClickCountRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoomReq

@implementation PB3SearchRoomReq

@dynamic name;
@dynamic page;

typedef struct PB3SearchRoomReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *name;
} PB3SearchRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoomReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchRoomReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoomReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchRoomReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoomReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoomRes

@implementation PB3SearchRoomRes

@dynamic listArray, listArray_Count;

typedef struct PB3SearchRoomRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3SearchRoomRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3SearchRoomRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchRoomRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoomRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoomRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchRoom

@implementation PB3SearchRoom

@dynamic name;
@dynamic page;
@dynamic listArray, listArray_Count;

typedef struct PB3SearchRoom__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  NSString *name;
  NSMutableArray *listArray;
} PB3SearchRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoom_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchRoom_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3IndexEntry),
        .number = PB3SearchRoom_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchRoom__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchRoom class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckMaintainReq

@implementation PB3CheckMaintainReq


typedef struct PB3CheckMaintainReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckMaintainReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckMaintainReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckMaintainReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckMaintainRes

@implementation PB3CheckMaintainRes


typedef struct PB3CheckMaintainRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckMaintainRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckMaintainRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckMaintainRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetActivityRoomReq

@implementation PB3GetActivityRoomReq


typedef struct PB3GetActivityRoomReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetActivityRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityRoomReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetActivityRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetActivityRoomRes

@implementation PB3GetActivityRoomRes

@dynamic roomIdArray, roomIdArray_Count;
@dynamic chatInterval;

typedef struct PB3GetActivityRoomRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t chatInterval;
  GPBInt64Array *roomIdArray;
} PB3GetActivityRoomRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetActivityRoomRes_FieldNumber_RoomIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetActivityRoomRes__storage_, roomIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chatInterval",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetActivityRoomRes_FieldNumber_ChatInterval,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetActivityRoomRes__storage_, chatInterval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityRoomRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetActivityRoomRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BroadcastActivityRoom

@implementation PB3BroadcastActivityRoom

@dynamic hasInfo, info;

typedef struct PB3BroadcastActivityRoom__storage_ {
  uint32_t _has_storage_[1];
  PB3GetActivityRoomRes *info;
} PB3BroadcastActivityRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GetActivityRoomRes),
        .number = PB3BroadcastActivityRoom_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BroadcastActivityRoom__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BroadcastActivityRoom class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BroadcastActivityRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RankDetail

@implementation PB3RankDetail

@dynamic rankArray, rankArray_Count;
@dynamic hasMy, my;

typedef struct PB3RankDetail__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rankArray;
  PB3Rank *my;
} PB3RankDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Rank),
        .number = PB3RankDetail_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3RankDetail__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "my",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Rank),
        .number = PB3RankDetail_FieldNumber_My,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RankDetail__storage_, my),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RankDetail class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RankDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRankReq

@implementation PB3GetRankReq

@dynamic type;
@dynamic playerId;
@dynamic sex;

typedef struct PB3GetRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3RankType type;
  PB3SexType sex;
  int64_t playerId;
} PB3GetRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3RankType_EnumDescriptor,
        .number = PB3GetRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3GetRankReq_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetRankReq__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetRankReq_Type_RawValue(PB3GetRankReq *message) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetRankReq_Type_RawValue(PB3GetRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3GetRankReq_Sex_RawValue(PB3GetRankReq *message) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetRankReq_Sex_RawValue(PB3GetRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetRankReq_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetRankRes

@implementation PB3GetRankRes

@dynamic rankType;
@dynamic hasDay, day;
@dynamic hasWeek, week;
@dynamic hasTotal, total;
@dynamic hasManHour, manHour;
@dynamic hasGirlHour, girlHour;
@dynamic reloadTime;
@dynamic hasMonth, month;
@dynamic hasYear, year;

typedef struct PB3GetRankRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t rankType;
  PB3RankDetail *day;
  PB3RankDetail *week;
  PB3RankDetail *total;
  PB3RankDetail *manHour;
  PB3RankDetail *girlHour;
  PB3RankDetail *month;
  PB3RankDetail *year;
  int64_t reloadTime;
} PB3GetRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankRes_FieldNumber_RankType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, rankType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Day,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, day),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "week",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Week,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, week),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Total,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "manHour",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_ManHour,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, manHour),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "girlHour",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_GirlHour,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, girlHour),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reloadTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetRankRes_FieldNumber_ReloadTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, reloadTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "month",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Month,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, month),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "year",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetRankRes_FieldNumber_Year,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetRankRes__storage_, year),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGiftRankReq

@implementation PB3GetGiftRankReq

@dynamic giftId;
@dynamic playerId;

typedef struct PB3GetGiftRankReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t giftId;
  int64_t playerId;
} PB3GetGiftRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGiftRankReq_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGiftRankReq__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetGiftRankReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetGiftRankReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGiftRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGiftRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetGiftRankRes

@implementation PB3GetGiftRankRes

@dynamic hasGiftRank, giftRank;

typedef struct PB3GetGiftRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3RankDetail *giftRank;
} PB3GetGiftRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftRank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankDetail),
        .number = PB3GetGiftRankRes_FieldNumber_GiftRank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetGiftRankRes__storage_, giftRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetGiftRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetGiftRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LoadClickRep

@implementation PB3LoadClickRep

@dynamic type;
@dynamic isLoad;

typedef struct PB3LoadClickRep__storage_ {
  uint32_t _has_storage_[1];
  PB3LoadClickType type;
} PB3LoadClickRep__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3LoadClickType_EnumDescriptor,
        .number = PB3LoadClickRep_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LoadClickRep__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isLoad",
        .dataTypeSpecific.className = NULL,
        .number = PB3LoadClickRep_FieldNumber_IsLoad,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoadClickRep class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LoadClickRep__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3LoadClickRep_Type_RawValue(PB3LoadClickRep *message) {
  GPBDescriptor *descriptor = [PB3LoadClickRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoadClickRep_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3LoadClickRep_Type_RawValue(PB3LoadClickRep *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3LoadClickRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3LoadClickRep_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3LoadClickRes

@implementation PB3LoadClickRes


typedef struct PB3LoadClickRes__storage_ {
  uint32_t _has_storage_[1];
} PB3LoadClickRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LoadClickRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LoadClickRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetYoungModelReq

@implementation PB3GetYoungModelReq

@dynamic playerId;

typedef struct PB3GetYoungModelReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3GetYoungModelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetYoungModelReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetYoungModelReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetYoungModelReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetYoungModelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelReq

@implementation PB3YoungModelReq

@dynamic playerId;

typedef struct PB3YoungModelReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3YoungModelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModel

@implementation PB3YoungModel

@dynamic msg;
@dynamic isPwd;
@dynamic isOpen;
@dynamic onlineTime;
@dynamic dayMaxTime;
@dynamic startTime;
@dynamic endTime;
@dynamic isLimitTime;

typedef struct PB3YoungModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t onlineTime;
  int32_t dayMaxTime;
  NSString *msg;
  NSString *startTime;
  NSString *endTime;
} PB3YoungModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsPwd,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsOpen,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "onlineTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_OnlineTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, onlineTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dayMaxTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_DayMaxTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, dayMaxTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_StartTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_EndTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3YoungModel__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isLimitTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModel_FieldNumber_IsLimitTime,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModel class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelRes

@implementation PB3YoungModelRes

@dynamic hasModel, model;

typedef struct PB3YoungModelRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModel *model;
} PB3YoungModelRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "model",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3YoungModel),
        .number = PB3YoungModelRes_FieldNumber_Model,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelRes__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelPwdReq

@implementation PB3YoungModelPwdReq

@dynamic type;
@dynamic pwd;
@dynamic originalPwd;

typedef struct PB3YoungModelPwdReq__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPwdType type;
  NSString *pwd;
  NSString *originalPwd;
} PB3YoungModelPwdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPwdType_EnumDescriptor,
        .number = PB3YoungModelPwdReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPwdReq_FieldNumber_Pwd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalPwd",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPwdReq_FieldNumber_OriginalPwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdReq__storage_, originalPwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPwdReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPwdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPwdReq_Type_RawValue(PB3YoungModelPwdReq *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPwdReq_Type_RawValue(PB3YoungModelPwdReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPwdRes

@implementation PB3YoungModelPwdRes

@dynamic type;

typedef struct PB3YoungModelPwdRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPwdType type;
} PB3YoungModelPwdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPwdType_EnumDescriptor,
        .number = PB3YoungModelPwdRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPwdRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPwdRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPwdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPwdRes_Type_RawValue(PB3YoungModelPwdRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPwdRes_Type_RawValue(PB3YoungModelPwdRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPwdRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPwdRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPhoneReq

@implementation PB3YoungModelPhoneReq

@dynamic type;
@dynamic code;

typedef struct PB3YoungModelPhoneReq__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPhoneType type;
  NSString *code;
} PB3YoungModelPhoneReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPhoneType_EnumDescriptor,
        .number = PB3YoungModelPhoneReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPhoneReq_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPhoneReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPhoneReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPhoneReq_Type_RawValue(PB3YoungModelPhoneReq *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPhoneReq_Type_RawValue(PB3YoungModelPhoneReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelPhoneRes

@implementation PB3YoungModelPhoneRes

@dynamic type;
@dynamic phone;

typedef struct PB3YoungModelPhoneRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPhoneType type;
  NSString *phone;
} PB3YoungModelPhoneRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPhoneType_EnumDescriptor,
        .number = PB3YoungModelPhoneRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = PB3YoungModelPhoneRes_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3YoungModelPhoneRes__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelPhoneRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelPhoneRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelPhoneRes_Type_RawValue(PB3YoungModelPhoneRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelPhoneRes_Type_RawValue(PB3YoungModelPhoneRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelPhoneRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelPhoneRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3YoungModelStatusReq

@implementation PB3YoungModelStatusReq


typedef struct PB3YoungModelStatusReq__storage_ {
  uint32_t _has_storage_[1];
} PB3YoungModelStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelStatusReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3YoungModelStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3YoungModelStatusRes

@implementation PB3YoungModelStatusRes

@dynamic type;

typedef struct PB3YoungModelStatusRes__storage_ {
  uint32_t _has_storage_[1];
  PB3YoungModelPageType type;
} PB3YoungModelStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3YoungModelPageType_EnumDescriptor,
        .number = PB3YoungModelStatusRes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3YoungModelStatusRes__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3YoungModelStatusRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3YoungModelStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3YoungModelStatusRes_Type_RawValue(PB3YoungModelStatusRes *message) {
  GPBDescriptor *descriptor = [PB3YoungModelStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelStatusRes_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3YoungModelStatusRes_Type_RawValue(PB3YoungModelStatusRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3YoungModelStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3YoungModelStatusRes_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarChampion

@implementation PB3WeekStarChampion

@dynamic id_p;
@dynamic id2;
@dynamic name;
@dynamic charm;
@dynamic icon;
@dynamic remark;

typedef struct PB3WeekStarChampion__storage_ {
  uint32_t _has_storage_[1];
  uint32_t charm;
  NSString *name;
  NSString *icon;
  NSString *remark;
  int64_t id_p;
  int64_t id2;
} PB3WeekStarChampion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Charm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarChampion_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WeekStarChampion__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarChampion class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarChampion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarData

@implementation PB3WeekStarData

@dynamic id_p;
@dynamic id2;
@dynamic name;
@dynamic charm;
@dynamic icon;
@dynamic remark;
@dynamic sex;

typedef struct PB3WeekStarData__storage_ {
  uint32_t _has_storage_[1];
  PB3SexType sex;
  NSString *name;
  NSString *icon;
  NSString *remark;
  int64_t id_p;
  int64_t id2;
  int64_t charm;
} PB3WeekStarData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charm",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Charm,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, charm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarData_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3WeekStarData_FieldNumber_Sex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3WeekStarData__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarData class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarData_Sex_RawValue(PB3WeekStarData *message) {
  GPBDescriptor *descriptor = [PB3WeekStarData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarData_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarData_Sex_RawValue(PB3WeekStarData *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarData_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3StarRank

@implementation PB3StarRank

@dynamic type;
@dynamic rankArray, rankArray_Count;
@dynamic id_p;
@dynamic myVal;
@dynamic myRank;
@dynamic icon;
@dynamic name;

typedef struct PB3StarRank__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
  int32_t myRank;
  NSMutableArray *rankArray;
  NSString *icon;
  NSString *name;
  int64_t id_p;
  int64_t myVal;
} PB3StarRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3StarRank_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarData),
        .number = PB3StarRank_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "myVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_MyVal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, myVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "myRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_MyRank,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, myRank),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3StarRank_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3StarRank__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3StarRank class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3StarRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\005\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3StarRank_Type_RawValue(PB3StarRank *message) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3StarRank_Type_RawValue(PB3StarRank *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3StarRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3StarRank_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekNum

@implementation PB3WeekNum

@dynamic num;

typedef struct PB3WeekNum__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB3WeekNum__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekNum_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekNum__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNum class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekNum__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarSpecialGift

@implementation PB3WeekStarSpecialGift

@dynamic giftId;
@dynamic giftName;
@dynamic giftPrice;
@dynamic giftIcon;

typedef struct PB3WeekStarSpecialGift__storage_ {
  uint32_t _has_storage_[1];
  int32_t giftId;
  int32_t giftPrice;
  NSString *giftName;
  NSString *giftIcon;
} PB3WeekStarSpecialGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftName",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftPrice",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "giftIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekStarSpecialGift_FieldNumber_GiftIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3WeekStarSpecialGift__storage_, giftIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarSpecialGift class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarSpecialGift__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRankReq

@implementation PB3WeekStarRankReq

@dynamic type;

typedef struct PB3WeekStarRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarRankReq_Type_RawValue(PB3WeekStarRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarRankReq_Type_RawValue(PB3WeekStarRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarRankRes

@implementation PB3WeekStarRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarFansRankReq

@implementation PB3WeekStarFansRankReq

@dynamic type;

typedef struct PB3WeekStarFansRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarFansRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarFansRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarFansRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarFansRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarFansRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarFansRankReq_Type_RawValue(PB3WeekStarFansRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarFansRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarFansRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarFansRankReq_Type_RawValue(PB3WeekStarFansRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarFansRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarFansRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarFansRankRes

@implementation PB3WeekStarFansRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarFansRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarFansRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarFansRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarFansRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarFansRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarFansRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRoomRankReq

@implementation PB3WeekStarRoomRankReq

@dynamic type;

typedef struct PB3WeekStarRoomRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekStarRoomRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekStarRoomRankReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRoomRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRoomRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRoomRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekStarRoomRankReq_Type_RawValue(PB3WeekStarRoomRankReq *message) {
  GPBDescriptor *descriptor = [PB3WeekStarRoomRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRoomRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekStarRoomRankReq_Type_RawValue(PB3WeekStarRoomRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekStarRoomRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekStarRoomRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekStarRoomRankRes

@implementation PB3WeekStarRoomRankRes

@dynamic hasRank, rank;

typedef struct PB3WeekStarRoomRankRes__storage_ {
  uint32_t _has_storage_[1];
  PB3StarRank *rank;
} PB3WeekStarRoomRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3StarRank),
        .number = PB3WeekStarRoomRankRes_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRoomRankRes__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRoomRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRoomRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarReq

@implementation PB3WeekStarReq


typedef struct PB3WeekStarReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WeekStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WeekStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekStarRes

@implementation PB3WeekStarRes

@dynamic hasStar, star;

typedef struct PB3WeekStarRes__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarData *star;
} PB3WeekStarRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "star",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarData),
        .number = PB3WeekStarRes_FieldNumber_Star,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekStarRes__storage_, star),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekStarRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekStarRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekGiftReq

@implementation PB3WeekGiftReq

@dynamic type;

typedef struct PB3WeekGiftReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WeekStarType type;
} PB3WeekGiftReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WeekStarType_EnumDescriptor,
        .number = PB3WeekGiftReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekGiftReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekGiftReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekGiftReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WeekGiftReq_Type_RawValue(PB3WeekGiftReq *message) {
  GPBDescriptor *descriptor = [PB3WeekGiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekGiftReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WeekGiftReq_Type_RawValue(PB3WeekGiftReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WeekGiftReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WeekGiftReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WeekGiftRes

@implementation PB3WeekGiftRes

@dynamic giftArray, giftArray_Count;
@dynamic specialGiftsArray, specialGiftsArray_Count;

typedef struct PB3WeekGiftRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *giftArray;
  NSMutableArray *specialGiftsArray;
} PB3WeekGiftRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekGiftRes_FieldNumber_GiftArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeekGiftRes__storage_, giftArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "specialGiftsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WeekStarSpecialGift),
        .number = PB3WeekGiftRes_FieldNumber_SpecialGiftsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WeekGiftRes__storage_, specialGiftsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekGiftRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekGiftRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekNumReq

@implementation PB3WeekNumReq


typedef struct PB3WeekNumReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WeekNumReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNumReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WeekNumReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WeekNumRes

@implementation PB3WeekNumRes

@dynamic num;

typedef struct PB3WeekNumRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB3WeekNumRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3WeekNumRes_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WeekNumRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WeekNumRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WeekNumRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SubInfo

@implementation PB3SubInfo

@dynamic name;
@dynamic URL;
@dynamic location;
@dynamic backgroundImg;
@dynamic pcBackgroundImg;
@dynamic weight;
@dynamic startTime;
@dynamic endTime;
@dynamic roomsubinfoShow;
@dynamic playerPageURL;
@dynamic slipFrequency;
@dynamic actId;
@dynamic androidVerMin;
@dynamic androidVerMax;
@dynamic iosVerMax;
@dynamic iosVerMin;
@dynamic pcVerMin;
@dynamic pcVerMax;
@dynamic wealthLevelMin;
@dynamic wealthLevelMax;
@dynamic charmLevelMin;
@dynamic charmLevelMax;
@dynamic andOr;
@dynamic blacklist;
@dynamic registerTimeLimit;

typedef struct PB3SubInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t location;
  int32_t weight;
  int32_t roomsubinfoShow;
  int32_t slipFrequency;
  int32_t actId;
  int32_t wealthLevelMin;
  int32_t wealthLevelMax;
  int32_t charmLevelMin;
  int32_t charmLevelMax;
  int32_t andOr;
  NSString *name;
  NSString *URL;
  NSString *backgroundImg;
  NSString *pcBackgroundImg;
  NSString *playerPageURL;
  NSString *androidVerMin;
  NSString *androidVerMax;
  NSString *iosVerMax;
  NSString *iosVerMin;
  NSString *pcVerMin;
  NSString *pcVerMax;
  NSString *blacklist;
  NSString *registerTimeLimit;
  int64_t startTime;
  int64_t endTime;
} PB3SubInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Location,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_BackgroundImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, backgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBackgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcBackgroundImg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcBackgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Weight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_StartTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_EndTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomsubinfoShow",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RoomsubinfoShow,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, roomsubinfoShow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerPageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PlayerPageURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, playerPageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slipFrequency",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_SlipFrequency,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, slipFrequency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_ActId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, actId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "androidVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndroidVerMin,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, androidVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndroidVerMax,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, androidVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_IosVerMax,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, iosVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iosVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_IosVerMin,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, iosVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcVerMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcVerMin,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcVerMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcVerMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_PcVerMax,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, pcVerMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wealthLevelMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_WealthLevelMin,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, wealthLevelMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLevelMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_WealthLevelMax,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, wealthLevelMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevelMin",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_CharmLevelMin,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, charmLevelMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevelMax",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_CharmLevelMax,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, charmLevelMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "andOr",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_AndOr,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, andOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_Blacklist,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, blacklist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "registerTimeLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3SubInfo_FieldNumber_RegisterTimeLimit,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB3SubInfo__storage_, registerTimeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SubInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SubInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002!!!\000\n\006\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListSubInfoReq

@implementation PB3ListSubInfoReq


typedef struct PB3ListSubInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ListSubInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListSubInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ListSubInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ListSubInfoRes

@implementation PB3ListSubInfoRes

@dynamic listArray, listArray_Count;

typedef struct PB3ListSubInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3ListSubInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SubInfo),
        .number = PB3ListSubInfoRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ListSubInfoRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ListSubInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ListSubInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAdActiveReq

@implementation PB3GetAdActiveReq

@dynamic adChannel;
@dynamic adType;
@dynamic idfa;
@dynamic androidId;
@dynamic imei;
@dynamic mac;
@dynamic eventType;
@dynamic deviceId;
@dynamic oaid;
@dynamic adToken;
@dynamic extends, extends_Count;

typedef struct PB3GetAdActiveReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t adChannel;
  int32_t adType;
  PB3AdEventType eventType;
  NSString *idfa;
  NSString *androidId;
  NSString *imei;
  NSString *mac;
  NSString *deviceId;
  NSString *oaid;
  NSString *adToken;
  NSMutableDictionary *extends;
} PB3GetAdActiveReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "adChannel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdChannel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adType",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idfa",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Idfa,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, idfa),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AndroidId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, androidId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Imei,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, imei),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mac",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Mac,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, mac),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventType",
        .dataTypeSpecific.enumDescFunc = PB3AdEventType_EnumDescriptor,
        .number = PB3GetAdActiveReq_FieldNumber_EventType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_DeviceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Oaid,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, oaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adToken",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_AdToken,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, adToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extends",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAdActiveReq_FieldNumber_Extends,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetAdActiveReq__storage_, extends),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAdActiveReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAdActiveReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GetAdActiveReq_EventType_RawValue(PB3GetAdActiveReq *message) {
  GPBDescriptor *descriptor = [PB3GetAdActiveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetAdActiveReq_FieldNumber_EventType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GetAdActiveReq_EventType_RawValue(PB3GetAdActiveReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GetAdActiveReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GetAdActiveReq_FieldNumber_EventType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetAdActiveRes

@implementation PB3GetAdActiveRes


typedef struct PB3GetAdActiveRes__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAdActiveRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAdActiveRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAdActiveRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadClientLogReq

@implementation PB3UploadClientLogReq

@dynamic URL;
@dynamic text;
@dynamic clientInfo;

typedef struct PB3UploadClientLogReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *text;
  NSString *clientInfo;
} PB3UploadClientLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadClientLogReq_FieldNumber_ClientInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UploadClientLogReq__storage_, clientInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadClientLogReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadClientLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadClientLogRes

@implementation PB3UploadClientLogRes


typedef struct PB3UploadClientLogRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UploadClientLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadClientLogRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UploadClientLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTimestampReq

@implementation PB3GetTimestampReq


typedef struct PB3GetTimestampReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetTimestampReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTimestampReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetTimestampReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetTimestampRes

@implementation PB3GetTimestampRes

@dynamic current;
@dynamic currentTime;

typedef struct PB3GetTimestampRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *currentTime;
  int64_t current;
} PB3GetTimestampRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "current",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTimestampRes_FieldNumber_Current,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetTimestampRes__storage_, current),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "currentTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetTimestampRes_FieldNumber_CurrentTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetTimestampRes__storage_, currentTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetTimestampRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetTimestampRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HistoryWeekStarReq

@implementation PB3HistoryWeekStarReq

@dynamic page;
@dynamic pageSize;

typedef struct PB3HistoryWeekStarReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
  int32_t pageSize;
} PB3HistoryWeekStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarReq_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarReq__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryWeekStarReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HistoryWeekStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HistoryWeekStarRes

@implementation PB3HistoryWeekStarRes

@dynamic weekStarsArray, weekStarsArray_Count;
@dynamic total;

typedef struct PB3HistoryWeekStarRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *weekStarsArray;
  int64_t total;
} PB3HistoryWeekStarRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "weekStarsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3OldWeekStar),
        .number = PB3HistoryWeekStarRes_FieldNumber_WeekStarsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarRes__storage_, weekStarsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB3HistoryWeekStarRes_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HistoryWeekStarRes__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HistoryWeekStarRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HistoryWeekStarRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3OldWeekStar

@implementation PB3OldWeekStar

@dynamic phase;
@dynamic icon;
@dynamic name;
@dynamic starVal;
@dynamic clanName;
@dynamic id_p;

typedef struct PB3OldWeekStar__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  NSString *name;
  NSString *clanName;
  int64_t phase;
  int64_t starVal;
  int64_t id_p;
} PB3OldWeekStar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phase",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Phase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, phase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "starVal",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_StarVal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, starVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clanName",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_ClanName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, clanName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3OldWeekStar_FieldNumber_Id_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3OldWeekStar__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3OldWeekStar class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3OldWeekStar__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeIdReq

@implementation PB3GetPcChargeIdReq

@dynamic playerId;
@dynamic gold;
@dynamic timeStamp;
@dynamic channel;
@dynamic os;
@dynamic data_p;

typedef struct PB3GetPcChargeIdReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t channel;
  NSString *os;
  NSData *data_p;
  int64_t playerId;
  int64_t timeStamp;
} PB3GetPcChargeIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Gold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_TimeStamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "os",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Os,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, os),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdReq_FieldNumber_Data_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdReq__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeIdReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeIdRes

@implementation PB3GetPcChargeIdRes

@dynamic payId;
@dynamic timeOut;

typedef struct PB3GetPcChargeIdRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeOut;
  int64_t payId;
} PB3GetPcChargeIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdRes_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdRes__storage_, payId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeOut",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeIdRes_FieldNumber_TimeOut,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeIdRes__storage_, timeOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeIdRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeCheckReq

@implementation PB3GetPcChargeCheckReq

@dynamic payId;
@dynamic playerId;
@dynamic gold;
@dynamic timeStamp;
@dynamic channel;
@dynamic os;

typedef struct PB3GetPcChargeCheckReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t channel;
  NSString *os;
  int64_t payId;
  int64_t playerId;
  int64_t timeStamp;
} PB3GetPcChargeCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_PayId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, payId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Gold,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Channel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "os",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckReq_FieldNumber_Os,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckReq__storage_, os),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeCheckReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetPcChargeCheckRes

@implementation PB3GetPcChargeCheckRes

@dynamic data_p;

typedef struct PB3GetPcChargeCheckRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} PB3GetPcChargeCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetPcChargeCheckRes_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetPcChargeCheckRes__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetPcChargeCheckRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetPcChargeCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SensitiveCheckReq

@implementation PB3SensitiveCheckReq

@dynamic words;
@dynamic lib;

typedef struct PB3SensitiveCheckReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SensitiveWordLib lib;
  NSString *words;
} PB3SensitiveCheckReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "words",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckReq_FieldNumber_Words,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckReq__storage_, words),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lib",
        .dataTypeSpecific.enumDescFunc = PB3SensitiveWordLib_EnumDescriptor,
        .number = PB3SensitiveCheckReq_FieldNumber_Lib,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckReq__storage_, lib),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SensitiveCheckReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SensitiveCheckReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SensitiveCheckReq_Lib_RawValue(PB3SensitiveCheckReq *message) {
  GPBDescriptor *descriptor = [PB3SensitiveCheckReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SensitiveCheckReq_FieldNumber_Lib];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SensitiveCheckReq_Lib_RawValue(PB3SensitiveCheckReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SensitiveCheckReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SensitiveCheckReq_FieldNumber_Lib];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3SensitiveCheckRes

@implementation PB3SensitiveCheckRes

@dynamic pass;
@dynamic toastText;
@dynamic checkedWords;

typedef struct PB3SensitiveCheckRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  NSString *checkedWords;
} PB3SensitiveCheckRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_Pass,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_ToastText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckRes__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkedWords",
        .dataTypeSpecific.className = NULL,
        .number = PB3SensitiveCheckRes_FieldNumber_CheckedWords,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3SensitiveCheckRes__storage_, checkedWords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SensitiveCheckRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SensitiveCheckRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserActionLogReq

@implementation PB3UserActionLogReq

@dynamic clickRoom;
@dynamic clickHall;

typedef struct PB3UserActionLogReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t clickRoom;
  int64_t clickHall;
} PB3UserActionLogReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clickRoom",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserActionLogReq_FieldNumber_ClickRoom,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserActionLogReq__storage_, clickRoom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clickHall",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserActionLogReq_FieldNumber_ClickHall,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserActionLogReq__storage_, clickHall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserActionLogReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserActionLogReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserActionLogRes

@implementation PB3UserActionLogRes


typedef struct PB3UserActionLogRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UserActionLogRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserActionLogRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UserActionLogRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FriendBackgroundConfigReq

@implementation PB3FriendBackgroundConfigReq


typedef struct PB3FriendBackgroundConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FriendBackgroundConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FriendBackgroundConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FriendBackgroundConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FriendBackgroundConfigRes

@implementation PB3FriendBackgroundConfigRes

@dynamic configs, configs_Count;

typedef struct PB3FriendBackgroundConfigRes__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32ObjectDictionary *configs;
} PB3FriendBackgroundConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configs",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3BackgroundConfig),
        .number = PB3FriendBackgroundConfigRes_FieldNumber_Configs,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FriendBackgroundConfigRes__storage_, configs),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FriendBackgroundConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FriendBackgroundConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3BackgroundConfig

@implementation PB3BackgroundConfig

@dynamic backgroundId;
@dynamic backgroundName;
@dynamic backgroundImg;
@dynamic bgHeartImg;
@dynamic bgHeartShowImg;
@dynamic bgNameLeftImg;
@dynamic bgNameRightImg;
@dynamic bgStoreShowImg;
@dynamic bgShowMinImg;

typedef struct PB3BackgroundConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t backgroundId;
  NSString *backgroundName;
  NSString *backgroundImg;
  NSString *bgHeartImg;
  NSString *bgHeartShowImg;
  NSString *bgNameLeftImg;
  NSString *bgNameRightImg;
  NSString *bgStoreShowImg;
  NSString *bgShowMinImg;
} PB3BackgroundConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "backgroundId",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backgroundName",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BackgroundImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, backgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgHeartImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgHeartImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgHeartImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgHeartShowImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgHeartShowImg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgHeartShowImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgNameLeftImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgNameLeftImg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgNameLeftImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgNameRightImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgNameRightImg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgNameRightImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgStoreShowImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgStoreShowImg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgStoreShowImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgShowMinImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3BackgroundConfig_FieldNumber_BgShowMinImg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3BackgroundConfig__storage_, bgShowMinImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3BackgroundConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3BackgroundConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UserReportReq

@implementation PB3UserReportReq

@dynamic targetId;
@dynamic typeArray, typeArray_Count;
@dynamic remark;
@dynamic picIdsArray, picIdsArray_Count;
@dynamic sceneType;
@dynamic sceneContentId;

typedef struct PB3UserReportReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ReportSceneType sceneType;
  GPBEnumArray *typeArray;
  NSString *remark;
  NSMutableArray *picIdsArray;
  int64_t targetId;
  int64_t sceneContentId;
} PB3UserReportReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "typeArray",
        .dataTypeSpecific.enumDescFunc = PB3ReportType_EnumDescriptor,
        .number = PB3UserReportReq_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, typeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "picIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_PicIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, picIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sceneType",
        .dataTypeSpecific.enumDescFunc = PB3ReportSceneType_EnumDescriptor,
        .number = PB3UserReportReq_FieldNumber_SceneType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, sceneType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sceneContentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportReq_FieldNumber_SceneContentId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3UserReportReq__storage_, sceneContentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserReportReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserReportReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3UserReportReq_SceneType_RawValue(PB3UserReportReq *message) {
  GPBDescriptor *descriptor = [PB3UserReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserReportReq_FieldNumber_SceneType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3UserReportReq_SceneType_RawValue(PB3UserReportReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3UserReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3UserReportReq_FieldNumber_SceneType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3UserReportRes

@implementation PB3UserReportRes

@dynamic code;

typedef struct PB3UserReportRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} PB3UserReportRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3UserReportRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UserReportRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UserReportRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UserReportRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeStatusReq

@implementation PB3ExchangeCodeStatusReq


typedef struct PB3ExchangeCodeStatusReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ExchangeCodeStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeStatusReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ExchangeCodeStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeStatusRes

@implementation PB3ExchangeCodeStatusRes

@dynamic status;

typedef struct PB3ExchangeCodeStatusRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} PB3ExchangeCodeStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeStatusRes_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeStatusRes__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeStatusRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeReward

@implementation PB3ExchangeCodeReward

@dynamic rewardId;
@dynamic rewardNum;
@dynamic name;
@dynamic icon;

typedef struct PB3ExchangeCodeReward__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *icon;
  int64_t rewardId;
  int64_t rewardNum;
} PB3ExchangeCodeReward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_RewardId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_RewardNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, rewardNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeReward_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeReward__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeReward class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeReward__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeInfoReq

@implementation PB3ExchangeCodeInfoReq

@dynamic code;

typedef struct PB3ExchangeCodeInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} PB3ExchangeCodeInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeInfoRes

@implementation PB3ExchangeCodeInfoRes

@dynamic name;
@dynamic iconURL;
@dynamic desc;
@dynamic roomId;
@dynamic rewardsArray, rewardsArray_Count;

typedef struct PB3ExchangeCodeInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *iconURL;
  NSString *desc;
  NSMutableArray *rewardsArray;
  int64_t roomId;
} PB3ExchangeCodeInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_IconURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeInfoRes_FieldNumber_RoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rewardsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeCodeReward),
        .number = PB3ExchangeCodeInfoRes_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeInfoRes__storage_, rewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeRewardReq

@implementation PB3ExchangeCodeRewardReq

@dynamic code;

typedef struct PB3ExchangeCodeRewardReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} PB3ExchangeCodeRewardReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExchangeCodeRewardReq_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeRewardReq__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeRewardReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeRewardReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExchangeCodeRewardRes

@implementation PB3ExchangeCodeRewardRes

@dynamic rewardsArray, rewardsArray_Count;

typedef struct PB3ExchangeCodeRewardRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rewardsArray;
} PB3ExchangeCodeRewardRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ExchangeCodeReward),
        .number = PB3ExchangeCodeRewardRes_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ExchangeCodeRewardRes__storage_, rewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExchangeCodeRewardRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExchangeCodeRewardRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FocusBubbleConfReq

@implementation PB3FocusBubbleConfReq


typedef struct PB3FocusBubbleConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FocusBubbleConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FocusBubbleConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FocusBubbleConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FocusBubbleConfRes

@implementation PB3FocusBubbleConfRes

@dynamic firstPopTime;
@dynamic firstPopLastTime;
@dynamic secondPopTime;
@dynamic secondPopLastTime;
@dynamic popMsgArray, popMsgArray_Count;

typedef struct PB3FocusBubbleConfRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t firstPopTime;
  int32_t firstPopLastTime;
  int32_t secondPopTime;
  int32_t secondPopLastTime;
  NSMutableArray *popMsgArray;
} PB3FocusBubbleConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstPopTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_FirstPopTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, firstPopTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "firstPopLastTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_FirstPopLastTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, firstPopLastTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "secondPopTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_SecondPopTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, secondPopTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "secondPopLastTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_SecondPopLastTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, secondPopLastTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "popMsgArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3FocusBubbleConfRes_FieldNumber_PopMsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FocusBubbleConfRes__storage_, popMsgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FocusBubbleConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FocusBubbleConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSongInfoReq

@implementation PB3GetSongInfoReq

@dynamic songId;

typedef struct PB3GetSongInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t songId;
} PB3GetSongInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetSongInfoReq_FieldNumber_SongId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSongInfoReq__storage_, songId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSongInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSongInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetSongInfoRes

@implementation PB3GetSongInfoRes

@dynamic hasSong, song;

typedef struct PB3GetSongInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3Song *song;
} PB3GetSongInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "song",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Song),
        .number = PB3GetSongInfoRes_FieldNumber_Song,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetSongInfoRes__storage_, song),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetSongInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetSongInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifyConf

@implementation PB3WechatNotifyConf

@dynamic type;
@dynamic switch_p;

typedef struct PB3WechatNotifyConf__storage_ {
  uint32_t _has_storage_[1];
  PB3WechatNotifyType type;
  int32_t switch_p;
} PB3WechatNotifyConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WechatNotifyType_EnumDescriptor,
        .number = PB3WechatNotifyConf_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConf__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "switch_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatNotifyConf_FieldNumber_Switch_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConf__storage_, switch_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifyConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WechatNotifyConf_Type_RawValue(PB3WechatNotifyConf *message) {
  GPBDescriptor *descriptor = [PB3WechatNotifyConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifyConf_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WechatNotifyConf_Type_RawValue(PB3WechatNotifyConf *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WechatNotifyConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifyConf_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WechatNotifyConfReq

@implementation PB3WechatNotifyConfReq


typedef struct PB3WechatNotifyConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3WechatNotifyConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WechatNotifyConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifyConfRes

@implementation PB3WechatNotifyConfRes

@dynamic configsArray, configsArray_Count;

typedef struct PB3WechatNotifyConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *configsArray;
} PB3WechatNotifyConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3WechatNotifyConf),
        .number = PB3WechatNotifyConfRes_FieldNumber_ConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3WechatNotifyConfRes__storage_, configsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifyConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifyConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3WechatNotifySwitchReq

@implementation PB3WechatNotifySwitchReq

@dynamic type;
@dynamic switch_p;

typedef struct PB3WechatNotifySwitchReq__storage_ {
  uint32_t _has_storage_[1];
  PB3WechatNotifyType type;
  int32_t switch_p;
} PB3WechatNotifySwitchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3WechatNotifyType_EnumDescriptor,
        .number = PB3WechatNotifySwitchReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3WechatNotifySwitchReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "switch_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3WechatNotifySwitchReq_FieldNumber_Switch_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3WechatNotifySwitchReq__storage_, switch_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifySwitchReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3WechatNotifySwitchReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3WechatNotifySwitchReq_Type_RawValue(PB3WechatNotifySwitchReq *message) {
  GPBDescriptor *descriptor = [PB3WechatNotifySwitchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifySwitchReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3WechatNotifySwitchReq_Type_RawValue(PB3WechatNotifySwitchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3WechatNotifySwitchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3WechatNotifySwitchReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3WechatNotifySwitchRes

@implementation PB3WechatNotifySwitchRes


typedef struct PB3WechatNotifySwitchRes__storage_ {
  uint32_t _has_storage_[1];
} PB3WechatNotifySwitchRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3WechatNotifySwitchRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3WechatNotifySwitchRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TaxConfReq

@implementation PB3TaxConfReq

@dynamic type;

typedef struct PB3TaxConfReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TaxConfType type;
} PB3TaxConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3TaxConfType_EnumDescriptor,
        .number = PB3TaxConfReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TaxConfReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TaxConfReq_Type_RawValue(PB3TaxConfReq *message) {
  GPBDescriptor *descriptor = [PB3TaxConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TaxConfReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TaxConfReq_Type_RawValue(PB3TaxConfReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TaxConfReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TaxConfReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TaxConf

@implementation PB3TaxConf

@dynamic minValue;
@dynamic maxValue;
@dynamic tax;

typedef struct PB3TaxConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t minValue;
  int32_t maxValue;
  int32_t tax;
} PB3TaxConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_MinValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, minValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "maxValue",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_MaxValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, maxValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "tax",
        .dataTypeSpecific.className = NULL,
        .number = PB3TaxConf_FieldNumber_Tax,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TaxConf__storage_, tax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TaxConfRes

@implementation PB3TaxConfRes

@dynamic taxArray, taxArray_Count;

typedef struct PB3TaxConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *taxArray;
} PB3TaxConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "taxArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TaxConf),
        .number = PB3TaxConfRes_FieldNumber_TaxArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TaxConfRes__storage_, taxArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TaxConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TaxConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelLimitConfIOSRes

@implementation PB3LevelLimitConfIOSRes

@dynamic charmLevel;
@dynamic wealthLevel;
@dynamic openAndOr;

typedef struct PB3LevelLimitConfIOSRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  int32_t wealthLevel;
  int32_t openAndOr;
} PB3LevelLimitConfIOSRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_CharmLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_WealthLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "openAndOr",
        .dataTypeSpecific.className = NULL,
        .number = PB3LevelLimitConfIOSRes_FieldNumber_OpenAndOr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3LevelLimitConfIOSRes__storage_, openAndOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelLimitConfIOSRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3LevelLimitConfIOSRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3LevelLimitConfIOSReq

@implementation PB3LevelLimitConfIOSReq


typedef struct PB3LevelLimitConfIOSReq__storage_ {
  uint32_t _has_storage_[1];
} PB3LevelLimitConfIOSReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3LevelLimitConfIOSReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3LevelLimitConfIOSReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AcGameConf

@implementation PB3AcGameConf

@dynamic gameId;
@dynamic gameType;
@dynamic gameName;
@dynamic gameIcon;
@dynamic gamePcIcon;
@dynamic sourceURL;
@dynamic gameVersion;
@dynamic minSdkVersion;
@dynamic weight;
@dynamic gameTypeInt;
@dynamic router;

typedef struct PB3AcGameConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t gameId;
  PB3IndexAcGameType gameType;
  int32_t weight;
  int32_t gameTypeInt;
  NSString *gameName;
  NSString *gameIcon;
  NSString *gamePcIcon;
  NSString *sourceURL;
  NSString *gameVersion;
  NSString *minSdkVersion;
  NSString *router;
} PB3AcGameConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameType",
        .dataTypeSpecific.enumDescFunc = PB3IndexAcGameType_EnumDescriptor,
        .number = PB3AcGameConf_FieldNumber_GameType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gamePcIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GamePcIcon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gamePcIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_SourceURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, sourceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameVersion",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minSdkVersion",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_MinSdkVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, minSdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_Weight,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameTypeInt",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_GameTypeInt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, gameTypeInt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConf_FieldNumber_Router,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3AcGameConf__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConf class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AcGameConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AcGameConf_GameType_RawValue(PB3AcGameConf *message) {
  GPBDescriptor *descriptor = [PB3AcGameConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AcGameConf_FieldNumber_GameType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AcGameConf_GameType_RawValue(PB3AcGameConf *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AcGameConf descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AcGameConf_FieldNumber_GameType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AcGameConfListReq

@implementation PB3AcGameConfListReq


typedef struct PB3AcGameConfListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3AcGameConfListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConfListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3AcGameConfListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AcGameConfListRes

@implementation PB3AcGameConfListRes

@dynamic confListArray, confListArray_Count;
@dynamic icon;
@dynamic pcIcon;
@dynamic pcIconFlow;
@dynamic pcIconClick;

typedef struct PB3AcGameConfListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confListArray;
  NSString *icon;
  NSString *pcIcon;
  NSString *pcIconFlow;
  NSString *pcIconClick;
} PB3AcGameConfListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AcGameConf),
        .number = PB3AcGameConfListRes_FieldNumber_ConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, confListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconFlow",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIconFlow,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIconFlow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcIconClick",
        .dataTypeSpecific.className = NULL,
        .number = PB3AcGameConfListRes_FieldNumber_PcIconClick,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AcGameConfListRes__storage_, pcIconClick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AcGameConfListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AcGameConfListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PendantConfig

@implementation PB3PendantConfig

@dynamic id_p;
@dynamic name;
@dynamic state;
@dynamic bgURL;
@dynamic btnURL;
@dynamic halfURL;
@dynamic pcBgURL;
@dynamic pcBtnURL;
@dynamic pcHalfURL;
@dynamic routerURL;
@dynamic routerTitle;
@dynamic thumbnailBtn;
@dynamic pdType;
@dynamic spinningSpeed;
@dynamic cpURL;
@dynamic endTime;

typedef struct PB3PendantConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3PendantState state;
  PB3PendantType pdType;
  int32_t spinningSpeed;
  NSString *name;
  NSString *bgURL;
  NSString *btnURL;
  NSString *halfURL;
  NSString *pcBgURL;
  NSString *pcBtnURL;
  NSString *pcHalfURL;
  NSString *routerURL;
  NSString *routerTitle;
  NSString *cpURL;
  int64_t endTime;
} PB3PendantConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3PendantState_EnumDescriptor,
        .number = PB3PendantConfig_FieldNumber_State,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_BgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, bgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "btnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_BtnURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, btnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "halfURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_HalfURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, halfURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcBgURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcBgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBtnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcBtnURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcBtnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcHalfURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_PcHalfURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pcHalfURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_RouterURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_RouterTitle,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, routerTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnailBtn",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_ThumbnailBtn,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pdType",
        .dataTypeSpecific.enumDescFunc = PB3PendantType_EnumDescriptor,
        .number = PB3PendantConfig_FieldNumber_PdType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, pdType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "spinningSpeed",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_SpinningSpeed,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, spinningSpeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_CpURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, cpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PendantConfig_FieldNumber_EndTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3PendantConfig__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PendantConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\004\002\241!!\000\005\003\241!!\000\006\004\241!!\000\007\002\242\241!!\000\010\002\243\241!!\000\t\002\244\241!!\000"
        "\n\006\241!!\000\017\002\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PendantConfig_State_RawValue(PB3PendantConfig *message) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PendantConfig_State_RawValue(PB3PendantConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3PendantConfig_PdType_RawValue(PB3PendantConfig *message) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_PdType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PendantConfig_PdType_RawValue(PB3PendantConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PendantConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PendantConfig_FieldNumber_PdType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PendantConfigReq

@implementation PB3PendantConfigReq


typedef struct PB3PendantConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PendantConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PendantConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PendantConfigRes

@implementation PB3PendantConfigRes

@dynamic pendantConfListArray, pendantConfListArray_Count;
@dynamic pendantConfListSortArray, pendantConfListSortArray_Count;

typedef struct PB3PendantConfigRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pendantConfListArray;
  NSMutableArray *pendantConfListSortArray;
} PB3PendantConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pendantConfListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PendantConfig),
        .number = PB3PendantConfigRes_FieldNumber_PendantConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PendantConfigRes__storage_, pendantConfListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendantConfListSortArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PendantConfig),
        .number = PB3PendantConfigRes_FieldNumber_PendantConfListSortArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PendantConfigRes__storage_, pendantConfListSortArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PendantConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PendantConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ThemeConfig

@implementation PB3ThemeConfig

@dynamic id_p;
@dynamic name;
@dynamic beginAt;
@dynamic endAt;
@dynamic state;
@dynamic contentURL;
@dynamic URL;
@dynamic btnURL;
@dynamic routerURL;
@dynamic flag;
@dynamic routerH5URL;
@dynamic h5HeadURL;
@dynamic h5HeadNilURL;
@dynamic routerDraw;
@dynamic pcBtnURL;

typedef struct PB3ThemeConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB3BannerState state;
  NSString *name;
  NSString *contentURL;
  NSString *URL;
  NSString *btnURL;
  NSString *routerURL;
  NSString *flag;
  NSString *routerH5URL;
  NSString *h5HeadURL;
  NSString *h5HeadNilURL;
  NSString *routerDraw;
  NSString *pcBtnURL;
  int64_t beginAt;
  int64_t endAt;
} PB3ThemeConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "beginAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_BeginAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, beginAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_EndAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, endAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PB3BannerState_EnumDescriptor,
        .number = PB3ThemeConfig_FieldNumber_State,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contentURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_ContentURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, contentURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "btnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_BtnURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, btnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_Flag,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerH5URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterH5URL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerH5URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "h5HeadURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_H5HeadURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, h5HeadURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "h5HeadNilURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_H5HeadNilURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, h5HeadNilURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routerDraw",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_RouterDraw,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, routerDraw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcBtnURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ThemeConfig_FieldNumber_PcBtnURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3ThemeConfig__storage_, pcBtnURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfig class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ThemeConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\006\007\241!!\000\007!!!\000\010\003\241!!\000\t\006\241!!\000\013\006\242\241!!\000\014\002\244\241!!\000\r\002"
        "\244\243\241!!\000\017\002\243\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ThemeConfig_State_RawValue(PB3ThemeConfig *message) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ThemeConfig_State_RawValue(PB3ThemeConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ThemeConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ThemeConfig_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ThemeConfigReq

@implementation PB3ThemeConfigReq


typedef struct PB3ThemeConfigReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ThemeConfigReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfigReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ThemeConfigReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ThemeConfigRes

@implementation PB3ThemeConfigRes

@dynamic themeConfListArray, themeConfListArray_Count;

typedef struct PB3ThemeConfigRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *themeConfListArray;
} PB3ThemeConfigRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "themeConfListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ThemeConfig),
        .number = PB3ThemeConfigRes_FieldNumber_ThemeConfListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ThemeConfigRes__storage_, themeConfListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ThemeConfigRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ThemeConfigRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CountDownConfReq

@implementation PB3CountDownConfReq


typedef struct PB3CountDownConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CountDownConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CountDownConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CountDownConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CountDownConfRes

@implementation PB3CountDownConfRes

@dynamic URL;
@dynamic startAt;
@dynamic isOpen;

typedef struct PB3CountDownConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  int64_t startAt;
} PB3CountDownConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CountDownConfRes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_StartAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CountDownConfRes__storage_, startAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isOpen",
        .dataTypeSpecific.className = NULL,
        .number = PB3CountDownConfRes_FieldNumber_IsOpen,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CountDownConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CountDownConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3EventTrackingArgs

@implementation PB3EventTrackingArgs

@dynamic key;
@dynamic value;
@dynamic argType;

typedef struct PB3EventTrackingArgs__storage_ {
  uint32_t _has_storage_[1];
  PB3EventTrackingArgType argType;
  NSString *key;
  NSString *value;
} PB3EventTrackingArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTrackingArgs_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTrackingArgs_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argType",
        .dataTypeSpecific.enumDescFunc = PB3EventTrackingArgType_EnumDescriptor,
        .number = PB3EventTrackingArgs_FieldNumber_ArgType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3EventTrackingArgs__storage_, argType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EventTrackingArgs class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EventTrackingArgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3EventTrackingArgs_ArgType_RawValue(PB3EventTrackingArgs *message) {
  GPBDescriptor *descriptor = [PB3EventTrackingArgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EventTrackingArgs_FieldNumber_ArgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3EventTrackingArgs_ArgType_RawValue(PB3EventTrackingArgs *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3EventTrackingArgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3EventTrackingArgs_FieldNumber_ArgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3EventTracking

@implementation PB3EventTracking

@dynamic event;
@dynamic argsArray, argsArray_Count;

typedef struct PB3EventTracking__storage_ {
  uint32_t _has_storage_[1];
  NSString *event;
  NSMutableArray *argsArray;
} PB3EventTracking__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "event",
        .dataTypeSpecific.className = NULL,
        .number = PB3EventTracking_FieldNumber_Event,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3EventTracking__storage_, event),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EventTrackingArgs),
        .number = PB3EventTracking_FieldNumber_ArgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3EventTracking__storage_, argsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3EventTracking class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3EventTracking__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportEventTrackingReq

@implementation PB3ReportEventTrackingReq

@dynamic eventsArray, eventsArray_Count;

typedef struct PB3ReportEventTrackingReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
} PB3ReportEventTrackingReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3EventTracking),
        .number = PB3ReportEventTrackingReq_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ReportEventTrackingReq__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportEventTrackingReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportEventTrackingReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportEventTrackingRes

@implementation PB3ReportEventTrackingRes


typedef struct PB3ReportEventTrackingRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportEventTrackingRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportEventTrackingRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportEventTrackingRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportLoginReq

@implementation PB3ReportLoginReq

@dynamic oaid;
@dynamic reyunDeviceId;
@dynamic deviceType;
@dynamic deviceId;
@dynamic uMengDeviceId;

typedef struct PB3ReportLoginReq__storage_ {
  uint32_t _has_storage_[1];
  PB3DeviceType deviceType;
  NSString *oaid;
  NSString *reyunDeviceId;
  NSString *deviceId;
  NSString *uMengDeviceId;
} PB3ReportLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_Oaid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, oaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reyunDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_ReyunDeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, reyunDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = PB3DeviceType_EnumDescriptor,
        .number = PB3ReportLoginReq_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uMengDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportLoginReq_FieldNumber_UMengDeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ReportLoginReq__storage_, uMengDeviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportLoginReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ReportLoginReq_DeviceType_RawValue(PB3ReportLoginReq *message) {
  GPBDescriptor *descriptor = [PB3ReportLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportLoginReq_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ReportLoginReq_DeviceType_RawValue(PB3ReportLoginReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ReportLoginReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ReportLoginReq_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ReportLoginRes

@implementation PB3ReportLoginRes


typedef struct PB3ReportLoginRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportLoginRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3AppPushPopup

@implementation PB3AppPushPopup

@dynamic popupImg;
@dynamic butImg;
@dynamic touchArea;
@dynamic targetType;
@dynamic targetId;
@dynamic installInBegin;
@dynamic installInEnd;
@dynamic appearArea;
@dynamic jumpURL;
@dynamic expireTime;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic isAnd;
@dynamic msgId;

typedef struct PB3AppPushPopup__storage_ {
  uint32_t _has_storage_[1];
  PB3TouchAreaType touchArea;
  PB3TargetType targetType;
  PB3AppearArea appearArea;
  int32_t wealthLevel;
  int32_t charmLevel;
  NSString *popupImg;
  NSString *butImg;
  NSString *jumpURL;
  int64_t targetId;
  int64_t installInBegin;
  int64_t installInEnd;
  int64_t expireTime;
  int64_t msgId;
} PB3AppPushPopup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "popupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_PopupImg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, popupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "butImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_ButImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, butImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "touchArea",
        .dataTypeSpecific.enumDescFunc = PB3TouchAreaType_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_TouchArea,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, touchArea),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = PB3TargetType_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_TargetType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "installInBegin",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_InstallInBegin,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, installInBegin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "installInEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_InstallInEnd,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, installInEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "appearArea",
        .dataTypeSpecific.enumDescFunc = PB3AppearArea_EnumDescriptor,
        .number = PB3AppPushPopup_FieldNumber_AppearArea,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, appearArea),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_JumpURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_ExpireTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_WealthLevel,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_CharmLevel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAnd",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_IsAnd,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = PB3AppPushPopup_FieldNumber_MsgId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3AppPushPopup__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AppPushPopup class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AppPushPopup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3AppPushPopup_TouchArea_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TouchArea];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_TouchArea_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TouchArea];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3AppPushPopup_TargetType_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TargetType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_TargetType_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_TargetType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3AppPushPopup_AppearArea_RawValue(PB3AppPushPopup *message) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_AppearArea];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3AppPushPopup_AppearArea_RawValue(PB3AppPushPopup *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3AppPushPopup descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3AppPushPopup_FieldNumber_AppearArea];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3PullAppPushPopupReq

@implementation PB3PullAppPushPopupReq


typedef struct PB3PullAppPushPopupReq__storage_ {
  uint32_t _has_storage_[1];
} PB3PullAppPushPopupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullAppPushPopupReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3PullAppPushPopupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PullAppPushPopupRes

@implementation PB3PullAppPushPopupRes

@dynamic listArray, listArray_Count;

typedef struct PB3PullAppPushPopupRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3PullAppPushPopupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AppPushPopup),
        .number = PB3PullAppPushPopupRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PullAppPushPopupRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PullAppPushPopupRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PullAppPushPopupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadExitSongReq

@implementation PB3UploadExitSongReq

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadExitSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadExitSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadExitSongReq_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadExitSongReq__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadExitSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadExitSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadExitSongRes

@implementation PB3UploadExitSongRes

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadExitSongRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadExitSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadExitSongRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadExitSongRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadExitSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadExitSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongReq

@implementation PB3UploadSongReq

@dynamic songListArray, songListArray_Count;

typedef struct PB3UploadSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3UploadSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3UploadSongReq_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3UploadSongReq__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongRes

@implementation PB3UploadSongRes


typedef struct PB3UploadSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UploadSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UploadSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UploadSongInfo

@implementation PB3UploadSongInfo

@dynamic id_p;
@dynamic name;
@dynamic singerName;
@dynamic isRecommend;
@dynamic isExist;

typedef struct PB3UploadSongInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *singerName;
  int64_t id_p;
} PB3UploadSongInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "singerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_SingerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UploadSongInfo__storage_, singerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_IsRecommend,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isExist",
        .dataTypeSpecific.className = NULL,
        .number = PB3UploadSongInfo_FieldNumber_IsExist,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UploadSongInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UploadSongInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MySongListReq

@implementation PB3MySongListReq

@dynamic isTopRecommend;

typedef struct PB3MySongListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3MySongListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isTopRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3MySongListReq_FieldNumber_IsTopRecommend,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MySongListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MySongListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MySongListRes

@implementation PB3MySongListRes

@dynamic songListArray, songListArray_Count;

typedef struct PB3MySongListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
} PB3MySongListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3MySongListRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3MySongListRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MySongListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MySongListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RemoveSongReq

@implementation PB3RemoveSongReq

@dynamic id_p;

typedef struct PB3RemoveSongReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3RemoveSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3RemoveSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RemoveSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RemoveSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RemoveSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RemoveSongRes

@implementation PB3RemoveSongRes


typedef struct PB3RemoveSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3RemoveSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RemoveSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3RemoveSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSongReq

@implementation PB3UpdateSongReq

@dynamic id_p;
@dynamic isRecommend;

typedef struct PB3UpdateSongReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3UpdateSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateSongReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3UpdateSongReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isRecommend",
        .dataTypeSpecific.className = NULL,
        .number = PB3UpdateSongReq_FieldNumber_IsRecommend,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UpdateSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UpdateSongRes

@implementation PB3UpdateSongRes


typedef struct PB3UpdateSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB3UpdateSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UpdateSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UpdateSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchSongReq

@implementation PB3SearchSongReq

@dynamic name;
@dynamic playerId;

typedef struct PB3SearchSongReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t playerId;
} PB3SearchSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchSongReq_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SearchSongReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SearchSongReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SearchSongReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchSongReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SearchSongRes

@implementation PB3SearchSongRes

@dynamic songListArray, songListArray_Count;
@dynamic singerListArray, singerListArray_Count;

typedef struct PB3SearchSongRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *songListArray;
  NSMutableArray *singerListArray;
} PB3SearchSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "songListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3UploadSongInfo),
        .number = PB3SearchSongRes_FieldNumber_SongListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchSongRes__storage_, songListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SingerInfo),
        .number = PB3SearchSongRes_FieldNumber_SingerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SearchSongRes__storage_, singerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SearchSongRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SearchSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SingerInfo

@implementation PB3SingerInfo

@dynamic playerId;
@dynamic roomId;
@dynamic chairId;
@dynamic isOnline;
@dynamic name;
@dynamic icon;
@dynamic sex;

typedef struct PB3SingerInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t chairId;
  PB3SexType sex;
  NSString *name;
  NSString *icon;
  int64_t playerId;
  int64_t roomId;
} PB3SingerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chairId",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_ChairId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, chairId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_IsOnline,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3SingerInfo_FieldNumber_Icon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3SexType_EnumDescriptor,
        .number = PB3SingerInfo_FieldNumber_Sex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3SingerInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SingerInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SingerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3SingerInfo_Sex_RawValue(PB3SingerInfo *message) {
  GPBDescriptor *descriptor = [PB3SingerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingerInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3SingerInfo_Sex_RawValue(PB3SingerInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3SingerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3SingerInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CheckContentReq

@implementation PB3CheckContentReq

@dynamic content;

typedef struct PB3CheckContentReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} PB3CheckContentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckContentReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CheckContentReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckContentReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckContentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckContentRes

@implementation PB3CheckContentRes

@dynamic isPass;

typedef struct PB3CheckContentRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckContentRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPass",
        .dataTypeSpecific.className = NULL,
        .number = PB3CheckContentRes_FieldNumber_IsPass,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckContentRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CheckContentRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncPlayerOptReq

@implementation PB3SyncPlayerOptReq

@dynamic hasOpt, opt;

typedef struct PB3SyncPlayerOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SyncOpt *opt;
} PB3SyncPlayerOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SyncOpt),
        .number = PB3SyncPlayerOptReq_FieldNumber_Opt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3SyncPlayerOptReq__storage_, opt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncPlayerOptReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SyncPlayerOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SyncPlayerOptRes

@implementation PB3SyncPlayerOptRes


typedef struct PB3SyncPlayerOptRes__storage_ {
  uint32_t _has_storage_[1];
} PB3SyncPlayerOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SyncPlayerOptRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SyncPlayerOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetQuestionListReq

@implementation PB3GetQuestionListReq

@dynamic hasOpt, opt;

typedef struct PB3GetQuestionListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3SyncOpt *opt;
} PB3GetQuestionListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opt",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3SyncOpt),
        .number = PB3GetQuestionListReq_FieldNumber_Opt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetQuestionListReq__storage_, opt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetQuestionListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetQuestionListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetQuestionListRes

@implementation PB3GetQuestionListRes

@dynamic itemsArray, itemsArray_Count;

typedef struct PB3GetQuestionListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} PB3GetQuestionListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommQuestionListItem),
        .number = PB3GetQuestionListRes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetQuestionListRes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetQuestionListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetQuestionListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommQuestionTitleItem

@implementation PB3GameCommQuestionTitleItem

@dynamic id_p;
@dynamic title;

typedef struct PB3GameCommQuestionTitleItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  int64_t id_p;
} PB3GameCommQuestionTitleItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommQuestionTitleItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommQuestionTitleItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommQuestionTitleItem_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommQuestionTitleItem__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommQuestionTitleItem class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommQuestionTitleItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GameCommQuestionListItem

@implementation PB3GameCommQuestionListItem

@dynamic topicId;
@dynamic topicName;
@dynamic itemsArray, itemsArray_Count;

typedef struct PB3GameCommQuestionListItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *topicName;
  NSMutableArray *itemsArray;
  int64_t topicId;
} PB3GameCommQuestionListItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topicId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommQuestionListItem_FieldNumber_TopicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GameCommQuestionListItem__storage_, topicId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "topicName",
        .dataTypeSpecific.className = NULL,
        .number = PB3GameCommQuestionListItem_FieldNumber_TopicName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GameCommQuestionListItem__storage_, topicName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GameCommQuestionTitleItem),
        .number = PB3GameCommQuestionListItem_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GameCommQuestionListItem__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GameCommQuestionListItem class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GameCommQuestionListItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetQuestionDetailReq

@implementation PB3GetQuestionDetailReq

@dynamic id_p;

typedef struct PB3GetQuestionDetailReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3GetQuestionDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetQuestionDetailReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetQuestionDetailReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetQuestionDetailReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetQuestionDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetQuestionDetailRes

@implementation PB3GetQuestionDetailRes

@dynamic id_p;
@dynamic title;
@dynamic content;
@dynamic imagesArray, imagesArray_Count;

typedef struct PB3GetQuestionDetailRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *content;
  NSMutableArray *imagesArray;
  int64_t id_p;
} PB3GetQuestionDetailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetQuestionDetailRes_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetQuestionDetailRes__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetQuestionDetailRes_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetQuestionDetailRes__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetQuestionDetailRes_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetQuestionDetailRes__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetQuestionDetailRes_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetQuestionDetailRes__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetQuestionDetailRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetQuestionDetailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerGameRankInfo

@implementation PB3PlayerGameRankInfo

@dynamic rank;
@dynamic playerId;
@dynamic playerName;
@dynamic playerAvatar;
@dynamic score;
@dynamic style;

typedef struct PB3PlayerGameRankInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t rank;
  PB3GameRankScoreStyle style;
  NSString *playerName;
  NSString *playerAvatar;
  NSString *score;
  int64_t playerId;
} PB3PlayerGameRankInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerGameRankInfo_FieldNumber_Rank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerGameRankInfo_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerName",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerGameRankInfo_FieldNumber_PlayerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, playerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerAvatar",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerGameRankInfo_FieldNumber_PlayerAvatar,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, playerAvatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = PB3PlayerGameRankInfo_FieldNumber_Score,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB3GameRankScoreStyle_EnumDescriptor,
        .number = PB3PlayerGameRankInfo_FieldNumber_Style,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3PlayerGameRankInfo__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerGameRankInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerGameRankInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PlayerGameRankInfo_Style_RawValue(PB3PlayerGameRankInfo *message) {
  GPBDescriptor *descriptor = [PB3PlayerGameRankInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerGameRankInfo_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PlayerGameRankInfo_Style_RawValue(PB3PlayerGameRankInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PlayerGameRankInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PlayerGameRankInfo_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FetchGameRankReq

@implementation PB3FetchGameRankReq

@dynamic gameId;
@dynamic type;
@dynamic index;

typedef struct PB3FetchGameRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3GameRankType type;
  int32_t index;
  int64_t gameId;
} PB3FetchGameRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchGameRankReq_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchGameRankReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3GameRankType_EnumDescriptor,
        .number = PB3FetchGameRankReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FetchGameRankReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchGameRankReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FetchGameRankReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchGameRankReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchGameRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3FetchGameRankReq_Type_RawValue(PB3FetchGameRankReq *message) {
  GPBDescriptor *descriptor = [PB3FetchGameRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FetchGameRankReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3FetchGameRankReq_Type_RawValue(PB3FetchGameRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3FetchGameRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3FetchGameRankReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3FetchGameRankRes

@implementation PB3FetchGameRankRes

@dynamic rankPlayerArray, rankPlayerArray_Count;
@dynamic hasSelf_p, self_p;
@dynamic index;

typedef struct PB3FetchGameRankRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  NSMutableArray *rankPlayerArray;
  PB3PlayerGameRankInfo *self_p;
} PB3FetchGameRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerGameRankInfo),
        .number = PB3FetchGameRankRes_FieldNumber_RankPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3FetchGameRankRes__storage_, rankPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "self_p",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PlayerGameRankInfo),
        .number = PB3FetchGameRankRes_FieldNumber_Self_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchGameRankRes__storage_, self_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchGameRankRes_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FetchGameRankRes__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchGameRankRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchGameRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3RankGameInfo

@implementation PB3RankGameInfo

@dynamic gameId;
@dynamic name;
@dynamic icon;

typedef struct PB3RankGameInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *icon;
  int64_t gameId;
} PB3RankGameInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB3RankGameInfo_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3RankGameInfo__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3RankGameInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3RankGameInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3RankGameInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3RankGameInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3RankGameInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3RankGameInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRankGameListReq

@implementation PB3GetRankGameListReq


typedef struct PB3GetRankGameListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetRankGameListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankGameListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetRankGameListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetRankGameListRes

@implementation PB3GetRankGameListRes

@dynamic gamesArray, gamesArray_Count;

typedef struct PB3GetRankGameListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *gamesArray;
} PB3GetRankGameListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3RankGameInfo),
        .number = PB3GetRankGameListRes_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetRankGameListRes__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetRankGameListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetRankGameListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProvideMillionaireSubjectReq

@implementation PB3ProvideMillionaireSubjectReq

@dynamic detail;
@dynamic answerArray, answerArray_Count;
@dynamic rightIndex;

typedef struct PB3ProvideMillionaireSubjectReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t rightIndex;
  NSString *detail;
  NSMutableArray *answerArray;
} PB3ProvideMillionaireSubjectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProvideMillionaireSubjectReq_FieldNumber_Detail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ProvideMillionaireSubjectReq__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "answerArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProvideMillionaireSubjectReq_FieldNumber_AnswerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ProvideMillionaireSubjectReq__storage_, answerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rightIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProvideMillionaireSubjectReq_FieldNumber_RightIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ProvideMillionaireSubjectReq__storage_, rightIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProvideMillionaireSubjectReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProvideMillionaireSubjectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProvideMillionaireSubjectRes

@implementation PB3ProvideMillionaireSubjectRes


typedef struct PB3ProvideMillionaireSubjectRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ProvideMillionaireSubjectRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProvideMillionaireSubjectRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ProvideMillionaireSubjectRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ActivityPicInfo

@implementation PB3ActivityPicInfo

@dynamic activityId;
@dynamic picURL;
@dynamic jumpType;
@dynamic jumpURL;
@dynamic jumpGame;
@dynamic jumpInterface;
@dynamic activityName;

typedef struct PB3ActivityPicInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3ActivityPicJumpType jumpType;
  PB3JumpInterfaceType jumpInterface;
  NSString *picURL;
  NSString *jumpURL;
  NSString *activityName;
  int64_t activityId;
  int64_t jumpGame;
} PB3ActivityPicInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activityId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivityPicInfo_FieldNumber_ActivityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, activityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "picURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivityPicInfo_FieldNumber_PicURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, picURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jumpType",
        .dataTypeSpecific.enumDescFunc = PB3ActivityPicJumpType_EnumDescriptor,
        .number = PB3ActivityPicInfo_FieldNumber_JumpType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, jumpType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivityPicInfo_FieldNumber_JumpURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jumpGame",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivityPicInfo_FieldNumber_JumpGame,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, jumpGame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "jumpInterface",
        .dataTypeSpecific.enumDescFunc = PB3JumpInterfaceType_EnumDescriptor,
        .number = PB3ActivityPicInfo_FieldNumber_JumpInterface,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, jumpInterface),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "activityName",
        .dataTypeSpecific.className = NULL,
        .number = PB3ActivityPicInfo_FieldNumber_ActivityName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3ActivityPicInfo__storage_, activityName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ActivityPicInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ActivityPicInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\003\241!!\000\004\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ActivityPicInfo_JumpType_RawValue(PB3ActivityPicInfo *message) {
  GPBDescriptor *descriptor = [PB3ActivityPicInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ActivityPicInfo_FieldNumber_JumpType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ActivityPicInfo_JumpType_RawValue(PB3ActivityPicInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ActivityPicInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ActivityPicInfo_FieldNumber_JumpType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3ActivityPicInfo_JumpInterface_RawValue(PB3ActivityPicInfo *message) {
  GPBDescriptor *descriptor = [PB3ActivityPicInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ActivityPicInfo_FieldNumber_JumpInterface];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ActivityPicInfo_JumpInterface_RawValue(PB3ActivityPicInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ActivityPicInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ActivityPicInfo_FieldNumber_JumpInterface];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3GetActivityPicConfReq

@implementation PB3GetActivityPicConfReq


typedef struct PB3GetActivityPicConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetActivityPicConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityPicConfReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetActivityPicConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetActivityPicConfRes

@implementation PB3GetActivityPicConfRes

@dynamic activityPicsArray, activityPicsArray_Count;

typedef struct PB3GetActivityPicConfRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *activityPicsArray;
} PB3GetActivityPicConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activityPicsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ActivityPicInfo),
        .number = PB3GetActivityPicConfRes_FieldNumber_ActivityPicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetActivityPicConfRes__storage_, activityPicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetActivityPicConfRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetActivityPicConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClickActivityPicCountReq

@implementation PB3ClickActivityPicCountReq

@dynamic activityId;
@dynamic reportType;

typedef struct PB3ClickActivityPicCountReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ActivityPicReportType reportType;
  int64_t activityId;
} PB3ClickActivityPicCountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activityId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ClickActivityPicCountReq_FieldNumber_ActivityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ClickActivityPicCountReq__storage_, activityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reportType",
        .dataTypeSpecific.enumDescFunc = PB3ActivityPicReportType_EnumDescriptor,
        .number = PB3ClickActivityPicCountReq_FieldNumber_ReportType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ClickActivityPicCountReq__storage_, reportType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickActivityPicCountReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ClickActivityPicCountReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3ClickActivityPicCountReq_ReportType_RawValue(PB3ClickActivityPicCountReq *message) {
  GPBDescriptor *descriptor = [PB3ClickActivityPicCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickActivityPicCountReq_FieldNumber_ReportType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3ClickActivityPicCountReq_ReportType_RawValue(PB3ClickActivityPicCountReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3ClickActivityPicCountReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3ClickActivityPicCountReq_FieldNumber_ReportType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3ClickActivityPicCountRes

@implementation PB3ClickActivityPicCountRes


typedef struct PB3ClickActivityPicCountRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClickActivityPicCountRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClickActivityPicCountRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClickActivityPicCountRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ProtocolConfInfo

@implementation PB3ProtocolConfInfo

@dynamic userAgreement;
@dynamic userAgreementUpdateAt;
@dynamic privacyPolicy;
@dynamic privacyPolicyUpdateAt;

typedef struct PB3ProtocolConfInfo__storage_ {
  uint32_t _has_storage_[1];
  int64_t userAgreementUpdateAt;
  int64_t privacyPolicyUpdateAt;
} PB3ProtocolConfInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userAgreement",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtocolConfInfo_FieldNumber_UserAgreement,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userAgreementUpdateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtocolConfInfo_FieldNumber_UserAgreementUpdateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ProtocolConfInfo__storage_, userAgreementUpdateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "privacyPolicy",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtocolConfInfo_FieldNumber_PrivacyPolicy,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "privacyPolicyUpdateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3ProtocolConfInfo_FieldNumber_PrivacyPolicyUpdateAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3ProtocolConfInfo__storage_, privacyPolicyUpdateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ProtocolConfInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ProtocolConfInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAgreementAndPolicyReq

@implementation PB3GetAgreementAndPolicyReq


typedef struct PB3GetAgreementAndPolicyReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetAgreementAndPolicyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAgreementAndPolicyReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetAgreementAndPolicyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetAgreementAndPolicyRes

@implementation PB3GetAgreementAndPolicyRes

@dynamic userAgreementURL;
@dynamic userAgreementUpdateAt;
@dynamic privacyPolicyURL;
@dynamic privacyPolicyUpdateAt;

typedef struct PB3GetAgreementAndPolicyRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *userAgreementURL;
  NSString *privacyPolicyURL;
  int64_t userAgreementUpdateAt;
  int64_t privacyPolicyUpdateAt;
} PB3GetAgreementAndPolicyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userAgreementURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAgreementAndPolicyRes_FieldNumber_UserAgreementURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GetAgreementAndPolicyRes__storage_, userAgreementURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAgreementUpdateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAgreementAndPolicyRes_FieldNumber_UserAgreementUpdateAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GetAgreementAndPolicyRes__storage_, userAgreementUpdateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "privacyPolicyURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAgreementAndPolicyRes_FieldNumber_PrivacyPolicyURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GetAgreementAndPolicyRes__storage_, privacyPolicyURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "privacyPolicyUpdateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3GetAgreementAndPolicyRes_FieldNumber_PrivacyPolicyUpdateAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GetAgreementAndPolicyRes__storage_, privacyPolicyUpdateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetAgreementAndPolicyRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetAgreementAndPolicyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\004\251\241!!\000\003\007\246\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetServerConfListReq

@implementation PB3GetServerConfListReq


typedef struct PB3GetServerConfListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3GetServerConfListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetServerConfListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3GetServerConfListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GetServerConfListRes

@implementation PB3GetServerConfListRes

@dynamic confArray, confArray_Count;

typedef struct PB3GetServerConfListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confArray;
} PB3GetServerConfListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ServerInfo),
        .number = PB3GetServerConfListRes_FieldNumber_ConfArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3GetServerConfListRes__storage_, confArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GetServerConfListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GetServerConfListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ServerInfo

@implementation PB3ServerInfo

@dynamic region;
@dynamic longURL;
@dynamic longPort;
@dynamic shortURL;
@dynamic shortPort;

typedef struct PB3ServerInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t longPort;
  int32_t shortPort;
  NSString *region;
  NSString *longURL;
  NSString *shortURL;
} PB3ServerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "region",
        .dataTypeSpecific.className = NULL,
        .number = PB3ServerInfo_FieldNumber_Region,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ServerInfo__storage_, region),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "longURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ServerInfo_FieldNumber_LongURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ServerInfo__storage_, longURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "longPort",
        .dataTypeSpecific.className = NULL,
        .number = PB3ServerInfo_FieldNumber_LongPort,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ServerInfo__storage_, longPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shortURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ServerInfo_FieldNumber_ShortURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3ServerInfo__storage_, shortURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shortPort",
        .dataTypeSpecific.className = NULL,
        .number = PB3ServerInfo_FieldNumber_ShortPort,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3ServerInfo__storage_, shortPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ServerInfo class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ServerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\004\241!!\000\004\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExtByIpGetInfoReq

@implementation PB3ExtByIpGetInfoReq


typedef struct PB3ExtByIpGetInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ExtByIpGetInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExtByIpGetInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ExtByIpGetInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ExtByIpGetInfoRes

@implementation PB3ExtByIpGetInfoRes

@dynamic ip;
@dynamic isoCountryCode;
@dynamic country;

typedef struct PB3ExtByIpGetInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  NSString *isoCountryCode;
  NSString *country;
} PB3ExtByIpGetInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExtByIpGetInfoRes_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ExtByIpGetInfoRes__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isoCountryCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExtByIpGetInfoRes_FieldNumber_IsoCountryCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ExtByIpGetInfoRes__storage_, isoCountryCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3ExtByIpGetInfoRes_FieldNumber_Country,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3ExtByIpGetInfoRes__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ExtByIpGetInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ExtByIpGetInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportActivateAppInfoReq

@implementation PB3ReportActivateAppInfoReq

@dynamic ip;
@dynamic action;

typedef struct PB3ReportActivateAppInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  NSString *action;
} PB3ReportActivateAppInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportActivateAppInfoReq_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ReportActivateAppInfoReq__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = PB3ReportActivateAppInfoReq_FieldNumber_Action,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ReportActivateAppInfoReq__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportActivateAppInfoReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ReportActivateAppInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ReportActivateAppInfoRes

@implementation PB3ReportActivateAppInfoRes


typedef struct PB3ReportActivateAppInfoRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ReportActivateAppInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ReportActivateAppInfoRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ReportActivateAppInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FetchPoPoRoomListReq

@implementation PB3FetchPoPoRoomListReq


typedef struct PB3FetchPoPoRoomListReq__storage_ {
  uint32_t _has_storage_[1];
} PB3FetchPoPoRoomListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchPoPoRoomListReq class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3FetchPoPoRoomListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3FetchPoPoRoomListRes

@implementation PB3FetchPoPoRoomListRes

@dynamic ip;
@dynamic isoCountryCode;
@dynamic country;

typedef struct PB3FetchPoPoRoomListRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  NSString *isoCountryCode;
  NSString *country;
} PB3FetchPoPoRoomListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchPoPoRoomListRes_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3FetchPoPoRoomListRes__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isoCountryCode",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchPoPoRoomListRes_FieldNumber_IsoCountryCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3FetchPoPoRoomListRes__storage_, isoCountryCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = PB3FetchPoPoRoomListRes_FieldNumber_Country,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3FetchPoPoRoomListRes__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3FetchPoPoRoomListRes class]
                                     rootClass:[PB3IndexExtRoot class]
                                          file:PB3IndexExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3FetchPoPoRoomListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
