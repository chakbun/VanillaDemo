// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: clan_pb/clan_cli.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "clan_pb/ClanCliExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3ClanCliExtRoot

@implementation PB3ClanCliExtRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PB3ClanCliExtRoot_FileDescriptor

static GPBFileDescriptor *PB3ClanCliExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"clan_pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3ClanCmdId

GPBEnumDescriptor *PB3ClanCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CcZero\000CcRemoveMasterHall\000CcUnReadAnnoun"
        "cementMsg\000";
    static const int32_t values[] = {
        PB3ClanCmdId_CcZero,
        PB3ClanCmdId_CcRemoveMasterHall,
        PB3ClanCmdId_CcUnReadAnnouncementMsg,
    };
    static const char *extraTextFormatInfo = "\003\000b\204\000\001b\220\000\002b\225\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ClanCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ClanCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ClanCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ClanCmdId_CcZero:
    case PB3ClanCmdId_CcRemoveMasterHall:
    case PB3ClanCmdId_CcUnReadAnnouncementMsg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3HourRankTime

GPBEnumDescriptor *PB3HourRankTime_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ThisHour\000LastHour\000";
    static const int32_t values[] = {
        PB3HourRankTime_ThisHour,
        PB3HourRankTime_LastHour,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3HourRankTime)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3HourRankTime_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3HourRankTime_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3HourRankTime_ThisHour:
    case PB3HourRankTime_LastHour:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3HourRankTypeReq

@implementation PB3HourRankTypeReq


typedef struct PB3HourRankTypeReq__storage_ {
  uint32_t _has_storage_[1];
} PB3HourRankTypeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRankTypeReq class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3HourRankTypeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HourRankTypeRes

@implementation PB3HourRankTypeRes

@dynamic rankTypeArray, rankTypeArray_Count;

typedef struct PB3HourRankTypeRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rankTypeArray;
} PB3HourRankTypeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankTypeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3HourRankType),
        .number = PB3HourRankTypeRes_FieldNumber_RankTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HourRankTypeRes__storage_, rankTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRankTypeRes class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HourRankTypeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HourRankType

@implementation PB3HourRankType

@dynamic rankType;
@dynamic rankName;
@dynamic theme;

typedef struct PB3HourRankType__storage_ {
  uint32_t _has_storage_[1];
  NSString *rankName;
  NSString *theme;
  int64_t rankType;
} PB3HourRankType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankType",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankType_FieldNumber_RankType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HourRankType__storage_, rankType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rankName",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankType_FieldNumber_RankName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HourRankType__storage_, rankName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "theme",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankType_FieldNumber_Theme,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HourRankType__storage_, theme),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRankType class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HourRankType__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HourRankReq

@implementation PB3HourRankReq

@dynamic roomId;
@dynamic rankType;
@dynamic hourTime;

typedef struct PB3HourRankReq__storage_ {
  uint32_t _has_storage_[1];
  PB3HourRankTime hourTime;
  int64_t roomId;
  int64_t rankType;
} PB3HourRankReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankReq_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HourRankReq__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rankType",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankReq_FieldNumber_RankType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HourRankReq__storage_, rankType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hourTime",
        .dataTypeSpecific.enumDescFunc = PB3HourRankTime_EnumDescriptor,
        .number = PB3HourRankReq_FieldNumber_HourTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HourRankReq__storage_, hourTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRankReq class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HourRankReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3HourRankReq_HourTime_RawValue(PB3HourRankReq *message) {
  GPBDescriptor *descriptor = [PB3HourRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HourRankReq_FieldNumber_HourTime];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HourRankReq_HourTime_RawValue(PB3HourRankReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HourRankReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HourRankReq_FieldNumber_HourTime];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3HourRankRes

@implementation PB3HourRankRes

@dynamic hourRankArray, hourRankArray_Count;
@dynamic hasCurrentRank, currentRank;
@dynamic currentDate;
@dynamic balanceDate;

typedef struct PB3HourRankRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hourRankArray;
  PB3HourRank *currentRank;
  int64_t currentDate;
  int64_t balanceDate;
} PB3HourRankRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hourRankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3HourRank),
        .number = PB3HourRankRes_FieldNumber_HourRankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HourRankRes__storage_, hourRankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentRank",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3HourRank),
        .number = PB3HourRankRes_FieldNumber_CurrentRank,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HourRankRes__storage_, currentRank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentDate",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankRes_FieldNumber_CurrentDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HourRankRes__storage_, currentDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "balanceDate",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRankRes_FieldNumber_BalanceDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HourRankRes__storage_, balanceDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRankRes class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HourRankRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HourRank

@implementation PB3HourRank

@dynamic rankNum;
@dynamic roomId;
@dynamic roomName;
@dynamic roomImage;
@dynamic firstGapText;

typedef struct PB3HourRank__storage_ {
  uint32_t _has_storage_[1];
  NSString *roomName;
  NSString *roomImage;
  NSString *firstGapText;
  int64_t rankNum;
  int64_t roomId;
} PB3HourRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRank_FieldNumber_RankNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HourRank__storage_, rankNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRank_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HourRank__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomName",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRank_FieldNumber_RoomName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HourRank__storage_, roomName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomImage",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRank_FieldNumber_RoomImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3HourRank__storage_, roomImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstGapText",
        .dataTypeSpecific.className = NULL,
        .number = PB3HourRank_FieldNumber_FirstGapText,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3HourRank__storage_, firstGapText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HourRank class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HourRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UnReadAnnouncementMsgReq

@implementation PB3UnReadAnnouncementMsgReq


typedef struct PB3UnReadAnnouncementMsgReq__storage_ {
  uint32_t _has_storage_[1];
} PB3UnReadAnnouncementMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UnReadAnnouncementMsgReq class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3UnReadAnnouncementMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3UnReadAnnouncementMsgRes

@implementation PB3UnReadAnnouncementMsgRes

@dynamic has;
@dynamic msgCount;

typedef struct PB3UnReadAnnouncementMsgRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t msgCount;
} PB3UnReadAnnouncementMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "has",
        .dataTypeSpecific.className = NULL,
        .number = PB3UnReadAnnouncementMsgRes_FieldNumber_Has,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "msgCount",
        .dataTypeSpecific.className = NULL,
        .number = PB3UnReadAnnouncementMsgRes_FieldNumber_MsgCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3UnReadAnnouncementMsgRes__storage_, msgCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3UnReadAnnouncementMsgRes class]
                                     rootClass:[PB3ClanCliExtRoot class]
                                          file:PB3ClanCliExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3UnReadAnnouncementMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
