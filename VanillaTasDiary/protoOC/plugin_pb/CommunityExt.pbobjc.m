// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plugin_pb/community.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "plugin_pb/CommunityExt.pbobjc.h"
#import "plugin_pb/PluginExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB3CommunityExtRoot

@implementation PB3CommunityExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB3CommunityExtRoot_FileDescriptor

static GPBFileDescriptor *PB3CommunityExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"plugin_pb"
                                                 objcPrefix:@"PB3"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB3CommunityCmdId

GPBEnumDescriptor *PB3CommunityCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcCommunityZero\000IcCommunity\000IcCommunityG"
        "roupLimit\000IcPlayerGroupList\000IcGroupApply"
        "\000IcTrendsCheckNoPass\000IcTrendsCheckResult"
        "\000IcTrendsCommentCheckResult\000IcHotReplyCh"
        "eckNoPass\000IcHotReplyCheckResult\000";
    static const int32_t values[] = {
        PB3CommunityCmdId_IcCommunityZero,
        PB3CommunityCmdId_IcCommunity,
        PB3CommunityCmdId_IcCommunityGroupLimit,
        PB3CommunityCmdId_IcPlayerGroupList,
        PB3CommunityCmdId_IcGroupApply,
        PB3CommunityCmdId_IcTrendsCheckNoPass,
        PB3CommunityCmdId_IcTrendsCheckResult,
        PB3CommunityCmdId_IcTrendsCommentCheckResult,
        PB3CommunityCmdId_IcHotReplyCheckNoPass,
        PB3CommunityCmdId_IcHotReplyCheckResult,
    };
    static const char *extraTextFormatInfo = "\n\000b\215\000\001b\211\000\002b\223\000\003b\217\000\004b\212\000\005b\221\000\006b\221\000\007b\230\000\010b\223\000\tb\223\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityCmdId_IcCommunityZero:
    case PB3CommunityCmdId_IcCommunity:
    case PB3CommunityCmdId_IcCommunityGroupLimit:
    case PB3CommunityCmdId_IcPlayerGroupList:
    case PB3CommunityCmdId_IcGroupApply:
    case PB3CommunityCmdId_IcTrendsCheckNoPass:
    case PB3CommunityCmdId_IcTrendsCheckResult:
    case PB3CommunityCmdId_IcTrendsCommentCheckResult:
    case PB3CommunityCmdId_IcHotReplyCheckNoPass:
    case PB3CommunityCmdId_IcHotReplyCheckResult:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityNavStyle

GPBEnumDescriptor *PB3CommunityNavStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CnsNone\000";
    static const int32_t values[] = {
        PB3CommunityNavStyle_CnsNone,
    };
    static const char *extraTextFormatInfo = "\001\000c\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityNavStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityNavStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityNavStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityNavStyle_CnsNone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityModuleType

GPBEnumDescriptor *PB3CommunityModuleType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmtNone\000CmtGroupMy\000CmtGroupCollection\000Cm"
        "tGroupHistory\000CmtGroupHot\000CmtGroupRecomm"
        "end\000CmtGroupDefine\000CmtTrendMy\000CmtTrendFo"
        "cus\000CmtTrendNew\000CmtTrendRecommend\000CmtTre"
        "ndHot\000CmtTrendDefine\000CmtTagAdmin\000CmtTagD"
        "efine\000";
    static const int32_t values[] = {
        PB3CommunityModuleType_CmtNone,
        PB3CommunityModuleType_CmtGroupMy,
        PB3CommunityModuleType_CmtGroupCollection,
        PB3CommunityModuleType_CmtGroupHistory,
        PB3CommunityModuleType_CmtGroupHot,
        PB3CommunityModuleType_CmtGroupRecommend,
        PB3CommunityModuleType_CmtGroupDefine,
        PB3CommunityModuleType_CmtTrendMy,
        PB3CommunityModuleType_CmtTrendFocus,
        PB3CommunityModuleType_CmtTrendNew,
        PB3CommunityModuleType_CmtTrendRecommend,
        PB3CommunityModuleType_CmtTrendHot,
        PB3CommunityModuleType_CmtTrendDefine,
        PB3CommunityModuleType_CmtTagAdmin,
        PB3CommunityModuleType_CmtTagDefine,
    };
    static const char *extraTextFormatInfo = "\017\000c\204\000\001c\205\202\000\002c\205\212\000\003c\205\207\000\004c\205\203\000\005c\205\211\000\006c\205\206\000\007c\205\202\000\010c\205\205\000\tc\205\203\000\nc\205\211\000\013c\205\203\000\014c\205\206\000\rc\203\205\000\016c\203\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityModuleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityModuleType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityModuleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityModuleType_CmtNone:
    case PB3CommunityModuleType_CmtGroupMy:
    case PB3CommunityModuleType_CmtGroupCollection:
    case PB3CommunityModuleType_CmtGroupHistory:
    case PB3CommunityModuleType_CmtGroupHot:
    case PB3CommunityModuleType_CmtGroupRecommend:
    case PB3CommunityModuleType_CmtGroupDefine:
    case PB3CommunityModuleType_CmtTrendMy:
    case PB3CommunityModuleType_CmtTrendFocus:
    case PB3CommunityModuleType_CmtTrendNew:
    case PB3CommunityModuleType_CmtTrendRecommend:
    case PB3CommunityModuleType_CmtTrendHot:
    case PB3CommunityModuleType_CmtTrendDefine:
    case PB3CommunityModuleType_CmtTagAdmin:
    case PB3CommunityModuleType_CmtTagDefine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityRightRule

GPBEnumDescriptor *PB3CommunityRightRule_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CrrNone\000CrrRefresh\000CrrRoute\000CrrClean\000Crr"
        "NextPage\000CrrText\000";
    static const int32_t values[] = {
        PB3CommunityRightRule_CrrNone,
        PB3CommunityRightRule_CrrRefresh,
        PB3CommunityRightRule_CrrRoute,
        PB3CommunityRightRule_CrrClean,
        PB3CommunityRightRule_CrrNextPage,
        PB3CommunityRightRule_CrrText,
    };
    static const char *extraTextFormatInfo = "\006\000c\204\000\001c\207\000\002c\205\000\003c\205\000\004c\210\000\005c\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityRightRule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityRightRule_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityRightRule_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityRightRule_CrrNone:
    case PB3CommunityRightRule_CrrRefresh:
    case PB3CommunityRightRule_CrrRoute:
    case PB3CommunityRightRule_CrrClean:
    case PB3CommunityRightRule_CrrNextPage:
    case PB3CommunityRightRule_CrrText:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityClanIconType

GPBEnumDescriptor *PB3CommunityClanIconType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CcitNormal\000CcitRely\000CcitBill\000";
    static const int32_t values[] = {
        PB3CommunityClanIconType_CcitNormal,
        PB3CommunityClanIconType_CcitRely,
        PB3CommunityClanIconType_CcitBill,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityClanIconType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityClanIconType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityClanIconType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityClanIconType_CcitNormal:
    case PB3CommunityClanIconType_CcitRely:
    case PB3CommunityClanIconType_CcitBill:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityGroupStatus

GPBEnumDescriptor *PB3CommunityGroupStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CgsNone\000CgsApplicable\000CgsApplying\000CgsAdd"
        "ed\000CgsOwner\000";
    static const int32_t values[] = {
        PB3CommunityGroupStatus_CgsNone,
        PB3CommunityGroupStatus_CgsApplicable,
        PB3CommunityGroupStatus_CgsApplying,
        PB3CommunityGroupStatus_CgsAdded,
        PB3CommunityGroupStatus_CgsOwner,
    };
    static const char *extraTextFormatInfo = "\005\000c\204\000\001c\212\000\002c\210\000\003c\205\000\004c\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityGroupStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityGroupStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityGroupStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityGroupStatus_CgsNone:
    case PB3CommunityGroupStatus_CgsApplicable:
    case PB3CommunityGroupStatus_CgsApplying:
    case PB3CommunityGroupStatus_CgsAdded:
    case PB3CommunityGroupStatus_CgsOwner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TrendTagStyle

GPBEnumDescriptor *PB3TrendTagStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TrendTagStyleNone\000TrendTagStyleImg\000";
    static const int32_t values[] = {
        PB3TrendTagStyle_TrendTagStyleNone,
        PB3TrendTagStyle_TrendTagStyleImg,
    };
    static const char *extraTextFormatInfo = "\002\000\r\204\000\001\r\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TrendTagStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TrendTagStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TrendTagStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TrendTagStyle_TrendTagStyleNone:
    case PB3TrendTagStyle_TrendTagStyleImg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3MediaType

GPBEnumDescriptor *PB3MediaType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MediaTypeNone\000MediaTypePng\000MediaTypeGif\000"
        "MediaTypeVideo\000MediaTypeAudio\000";
    static const int32_t values[] = {
        PB3MediaType_MediaTypeNone,
        PB3MediaType_MediaTypePng,
        PB3MediaType_MediaTypeGif,
        PB3MediaType_MediaTypeVideo,
        PB3MediaType_MediaTypeAudio,
    };
    static const char *extraTextFormatInfo = "\005\000\t\204\000\001\t\203\000\002\t\203\000\003\t\205\000\004\t\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3MediaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3MediaType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3MediaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3MediaType_MediaTypeNone:
    case PB3MediaType_MediaTypePng:
    case PB3MediaType_MediaTypeGif:
    case PB3MediaType_MediaTypeVideo:
    case PB3MediaType_MediaTypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ContentType

GPBEnumDescriptor *PB3ContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentTypeNone\000ContentTypeText\000ContentT"
        "ypePictureText\000ContentTypeVideo\000ContentT"
        "ypeAudio\000";
    static const int32_t values[] = {
        PB3ContentType_ContentTypeNone,
        PB3ContentType_ContentTypeText,
        PB3ContentType_ContentTypePictureText,
        PB3ContentType_ContentTypeVideo,
        PB3ContentType_ContentTypeAudio,
    };
    static const char *extraTextFormatInfo = "\005\000\013\204\000\001\013\204\000\002\013\213\000\003\013\205\000\004\013\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ContentType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ContentType_ContentTypeNone:
    case PB3ContentType_ContentTypeText:
    case PB3ContentType_ContentTypePictureText:
    case PB3ContentType_ContentTypeVideo:
    case PB3ContentType_ContentTypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TrendsType

GPBEnumDescriptor *PB3TrendsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TrendsTypeNormal\000TrendsTypeHotPoint\000";
    static const int32_t values[] = {
        PB3TrendsType_TrendsTypeNormal,
        PB3TrendsType_TrendsTypeHotPoint,
    };
    static const char *extraTextFormatInfo = "\002\000\n\206\000\001\n\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TrendsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TrendsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TrendsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TrendsType_TrendsTypeNormal:
    case PB3TrendsType_TrendsTypeHotPoint:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PublishGroupType

GPBEnumDescriptor *PB3PublishGroupType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PublicGroupTypeNone\000PublicGroupTypePubli"
        "c\000PublicGroupTypeSelect\000";
    static const int32_t values[] = {
        PB3PublishGroupType_PublicGroupTypeNone,
        PB3PublishGroupType_PublicGroupTypePublic,
        PB3PublishGroupType_PublicGroupTypeSelect,
    };
    static const char *extraTextFormatInfo = "\003\000\017\204\000\001\017\206\000\002\017\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PublishGroupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PublishGroupType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PublishGroupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PublishGroupType_PublicGroupTypeNone:
    case PB3PublishGroupType_PublicGroupTypePublic:
    case PB3PublishGroupType_PublicGroupTypeSelect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3TrendsOperType

GPBEnumDescriptor *PB3TrendsOperType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TrendsOperTypeNone\000TrendsOperTypeLike\000Tr"
        "endsOperTypeUnlike\000TrendsOperTypeComment"
        "\000TrendsOperTypeDelComment\000TrendsOperType"
        "DelTrends\000TrendsOperTypeShare\000TrendsOper"
        "TypeLikeVideo\000TrendsOperTypeUnlikeVideo\000"
        "TrendsOperTypeGetShareId\000TrendsOperTypeI"
        "ncrShareNum\000";
    static const int32_t values[] = {
        PB3TrendsOperType_TrendsOperTypeNone,
        PB3TrendsOperType_TrendsOperTypeLike,
        PB3TrendsOperType_TrendsOperTypeUnlike,
        PB3TrendsOperType_TrendsOperTypeComment,
        PB3TrendsOperType_TrendsOperTypeDelComment,
        PB3TrendsOperType_TrendsOperTypeDelTrends,
        PB3TrendsOperType_TrendsOperTypeShare,
        PB3TrendsOperType_TrendsOperTypeLikeVideo,
        PB3TrendsOperType_TrendsOperTypeUnlikeVideo,
        PB3TrendsOperType_TrendsOperTypeGetShareId,
        PB3TrendsOperType_TrendsOperTypeIncrShareNum,
    };
    static const char *extraTextFormatInfo = "\013\000\016\204\000\001\016\204\000\002\016\206\000\003\016\207\000\004\016\212\000\005\016\211\000\006\016\205\000\007\016\204\205\000\010\016\206\205\000\t\016\212\000\n\016\214\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3TrendsOperType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3TrendsOperType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3TrendsOperType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3TrendsOperType_TrendsOperTypeNone:
    case PB3TrendsOperType_TrendsOperTypeLike:
    case PB3TrendsOperType_TrendsOperTypeUnlike:
    case PB3TrendsOperType_TrendsOperTypeComment:
    case PB3TrendsOperType_TrendsOperTypeDelComment:
    case PB3TrendsOperType_TrendsOperTypeDelTrends:
    case PB3TrendsOperType_TrendsOperTypeShare:
    case PB3TrendsOperType_TrendsOperTypeLikeVideo:
    case PB3TrendsOperType_TrendsOperTypeUnlikeVideo:
    case PB3TrendsOperType_TrendsOperTypeGetShareId:
    case PB3TrendsOperType_TrendsOperTypeIncrShareNum:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3ContentResStatus

GPBEnumDescriptor *PB3ContentResStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unaudit\000Pass\000Refuse\000";
    static const int32_t values[] = {
        PB3ContentResStatus_Unaudit,
        PB3ContentResStatus_Pass,
        PB3ContentResStatus_Refuse,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\001\004\000\002\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3ContentResStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3ContentResStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3ContentResStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3ContentResStatus_Unaudit:
    case PB3ContentResStatus_Pass:
    case PB3ContentResStatus_Refuse:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommentType

GPBEnumDescriptor *PB3CommentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CommentTypeNormal\000CommentTypeGood\000";
    static const int32_t values[] = {
        PB3CommentType_CommentTypeNormal,
        PB3CommentType_CommentTypeGood,
    };
    static const char *extraTextFormatInfo = "\002\000\013\206\000\001\013\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommentType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommentType_CommentTypeNormal:
    case PB3CommentType_CommentTypeGood:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityMsgShowType

GPBEnumDescriptor *PB3CommunityMsgShowType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmsgShowTypeNone\000CmsgShowTypeLike\000CmsgSh"
        "owTypeComments\000";
    static const int32_t values[] = {
        PB3CommunityMsgShowType_CmsgShowTypeNone,
        PB3CommunityMsgShowType_CmsgShowTypeLike,
        PB3CommunityMsgShowType_CmsgShowTypeComments,
    };
    static const char *extraTextFormatInfo = "\003\000b\n\204\000\001b\n\204\000\002b\n\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityMsgShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityMsgShowType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityMsgShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityMsgShowType_CmsgShowTypeNone:
    case PB3CommunityMsgShowType_CmsgShowTypeLike:
    case PB3CommunityMsgShowType_CmsgShowTypeComments:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3CommunityPlayerMsgType

GPBEnumDescriptor *PB3CommunityPlayerMsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmsgTypeNone\000CmsgTypeLike\000CmsgTypeUnLike"
        "\000CmsgTypeShare\000CmsgTypeComments\000CmsgType"
        "UnComments\000CmsgTypeReplyComments\000CmsgTyp"
        "eDel\000CmsgTypeAtPlayer\000CmsgTypeFocusMe\000";
    static const int32_t values[] = {
        PB3CommunityPlayerMsgType_CmsgTypeNone,
        PB3CommunityPlayerMsgType_CmsgTypeLike,
        PB3CommunityPlayerMsgType_CmsgTypeUnLike,
        PB3CommunityPlayerMsgType_CmsgTypeShare,
        PB3CommunityPlayerMsgType_CmsgTypeComments,
        PB3CommunityPlayerMsgType_CmsgTypeUnComments,
        PB3CommunityPlayerMsgType_CmsgTypeReplyComments,
        PB3CommunityPlayerMsgType_CmsgTypeDel,
        PB3CommunityPlayerMsgType_CmsgTypeAtPlayer,
        PB3CommunityPlayerMsgType_CmsgTypeFocusMe,
    };
    static const char *extraTextFormatInfo = "\n\000b\006\204\000\001b\006\204\000\002b\006\206\000\003b\006\205\000\004b\006\210\000\005b\006\212\000\006b\006\215\000\007b\006\203\000\010b\006\210\000\tb\006\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3CommunityPlayerMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3CommunityPlayerMsgType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3CommunityPlayerMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3CommunityPlayerMsgType_CmsgTypeNone:
    case PB3CommunityPlayerMsgType_CmsgTypeLike:
    case PB3CommunityPlayerMsgType_CmsgTypeUnLike:
    case PB3CommunityPlayerMsgType_CmsgTypeShare:
    case PB3CommunityPlayerMsgType_CmsgTypeComments:
    case PB3CommunityPlayerMsgType_CmsgTypeUnComments:
    case PB3CommunityPlayerMsgType_CmsgTypeReplyComments:
    case PB3CommunityPlayerMsgType_CmsgTypeDel:
    case PB3CommunityPlayerMsgType_CmsgTypeAtPlayer:
    case PB3CommunityPlayerMsgType_CmsgTypeFocusMe:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3AgreementOperType

GPBEnumDescriptor *PB3AgreementOperType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AgreementOperTypeNone\000AgreementOperTypeC"
        "heck\000AgreementOperTypeAgree\000";
    static const int32_t values[] = {
        PB3AgreementOperType_AgreementOperTypeNone,
        PB3AgreementOperType_AgreementOperTypeCheck,
        PB3AgreementOperType_AgreementOperTypeAgree,
    };
    static const char *extraTextFormatInfo = "\003\000\021\204\000\001\021\205\000\002\021\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3AgreementOperType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3AgreementOperType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3AgreementOperType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3AgreementOperType_AgreementOperTypeNone:
    case PB3AgreementOperType_AgreementOperTypeCheck:
    case PB3AgreementOperType_AgreementOperTypeAgree:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB3PluginEffectTimeType

GPBEnumDescriptor *PB3PluginEffectTimeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PluginEffectTimeTypeAwary\000PluginEffectTi"
        "meTypeUse\000";
    static const int32_t values[] = {
        PB3PluginEffectTimeType_PluginEffectTimeTypeAwary,
        PB3PluginEffectTimeType_PluginEffectTimeTypeUse,
    };
    static const char *extraTextFormatInfo = "\002\000\031\000\001\027\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB3PluginEffectTimeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB3PluginEffectTimeType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB3PluginEffectTimeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB3PluginEffectTimeType_PluginEffectTimeTypeAwary:
    case PB3PluginEffectTimeType_PluginEffectTimeTypeUse:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB3HotReplyCheckNoPass

@implementation PB3HotReplyCheckNoPass

@dynamic hotPointId;

typedef struct PB3HotReplyCheckNoPass__storage_ {
  uint32_t _has_storage_[1];
  int64_t hotPointId;
} PB3HotReplyCheckNoPass__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotPointId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotReplyCheckNoPass_FieldNumber_HotPointId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HotReplyCheckNoPass__storage_, hotPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HotReplyCheckNoPass class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HotReplyCheckNoPass__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HotReplyCheckResult

@implementation PB3HotReplyCheckResult

@dynamic hotPointId;
@dynamic pass;

typedef struct PB3HotReplyCheckResult__storage_ {
  uint32_t _has_storage_[1];
  int64_t hotPointId;
} PB3HotReplyCheckResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotPointId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotReplyCheckResult_FieldNumber_HotPointId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HotReplyCheckResult__storage_, hotPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotReplyCheckResult_FieldNumber_Pass,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HotReplyCheckResult class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HotReplyCheckResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityRightButton

@implementation PB3CommunityRightButton

@dynamic icon;
@dynamic text;
@dynamic rule;
@dynamic route;

typedef struct PB3CommunityRightButton__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityRightRule rule;
  NSString *icon;
  NSString *text;
  NSString *route;
} PB3CommunityRightButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityRightButton_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityRightButton__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityRightButton_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityRightButton__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rule",
        .dataTypeSpecific.enumDescFunc = PB3CommunityRightRule_EnumDescriptor,
        .number = PB3CommunityRightButton_FieldNumber_Rule,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityRightButton__storage_, rule),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityRightButton_FieldNumber_Route,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityRightButton__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityRightButton class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityRightButton__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityRightButton_Rule_RawValue(PB3CommunityRightButton *message) {
  GPBDescriptor *descriptor = [PB3CommunityRightButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityRightButton_FieldNumber_Rule];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityRightButton_Rule_RawValue(PB3CommunityRightButton *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityRightButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityRightButton_FieldNumber_Rule];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTagList

@implementation PB3CommunityTagList

@dynamic listArray, listArray_Count;

typedef struct PB3CommunityTagList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3CommunityTagList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendTag),
        .number = PB3CommunityTagList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTagList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTagList class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTagList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupDataList

@implementation PB3CommunityGroupDataList

@dynamic listArray, listArray_Count;
@dynamic moduleType;

typedef struct PB3CommunityGroupDataList__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityModuleType moduleType;
  NSMutableArray *listArray;
} PB3CommunityGroupDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityGroupData),
        .number = PB3CommunityGroupDataList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityGroupDataList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moduleType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityModuleType_EnumDescriptor,
        .number = PB3CommunityGroupDataList_FieldNumber_ModuleType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupDataList__storage_, moduleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupDataList class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityGroupDataList_ModuleType_RawValue(PB3CommunityGroupDataList *message) {
  GPBDescriptor *descriptor = [PB3CommunityGroupDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupDataList_FieldNumber_ModuleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityGroupDataList_ModuleType_RawValue(PB3CommunityGroupDataList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityGroupDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupDataList_FieldNumber_ModuleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityGroupData

@implementation PB3CommunityGroupData

@dynamic hasGroupInfo, groupInfo;
@dynamic hasTrend, trend;
@dynamic index;

typedef struct PB3CommunityGroupData__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB3CommunityGroupInfo *groupInfo;
  PB3CommunityTrendData *trend;
} PB3CommunityGroupData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityGroupInfo),
        .number = PB3CommunityGroupData_FieldNumber_GroupInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupData__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityGroupData_FieldNumber_Trend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupData__storage_, trend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupData_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityGroupData__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupData class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupInfo

@implementation PB3CommunityGroupInfo

@dynamic id_p;
@dynamic icon;
@dynamic name;
@dynamic memberNum;
@dynamic trendNum;
@dynamic introduction;
@dynamic redNum;
@dynamic type;
@dynamic isAuditing;

typedef struct PB3CommunityGroupInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  int32_t redNum;
  PB3CommunityGroupType type;
  NSString *icon;
  NSString *name;
  NSString *introduction;
  int64_t id_p;
} PB3CommunityGroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_MemberNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_TrendNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "introduction",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_Introduction,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, introduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_RedNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, redNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CommunityGroupType_EnumDescriptor,
        .number = PB3CommunityGroupInfo_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isAuditing",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfo_FieldNumber_IsAuditing,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityGroupInfo_Type_RawValue(PB3CommunityGroupInfo *message) {
  GPBDescriptor *descriptor = [PB3CommunityGroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupInfo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityGroupInfo_Type_RawValue(PB3CommunityGroupInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityGroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupInfo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTrendDataList

@implementation PB3CommunityTrendDataList

@dynamic listArray, listArray_Count;
@dynamic moduleType;

typedef struct PB3CommunityTrendDataList__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityModuleType moduleType;
  NSMutableArray *listArray;
} PB3CommunityTrendDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityTrendDataList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendDataList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moduleType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityModuleType_EnumDescriptor,
        .number = PB3CommunityTrendDataList_FieldNumber_ModuleType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendDataList__storage_, moduleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendDataList class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityTrendDataList_ModuleType_RawValue(PB3CommunityTrendDataList *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendDataList_FieldNumber_ModuleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendDataList_ModuleType_RawValue(PB3CommunityTrendDataList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendDataList_FieldNumber_ModuleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3AtPlayer

@implementation PB3AtPlayer

@dynamic id_p;
@dynamic name;
@dynamic icon;

typedef struct PB3AtPlayer__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *icon;
  int64_t id_p;
} PB3AtPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3AtPlayer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3AtPlayer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3AtPlayer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3AtPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3AtPlayer_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3AtPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3AtPlayer class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3AtPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendData

@implementation PB3CommunityTrendData

@dynamic id_p;
@dynamic hasPublisher, publisher;
@dynamic content;
@dynamic likeNum;
@dynamic commentNum;
@dynamic tagsArray, tagsArray_Count;
@dynamic publishAt;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic isGaveLike;
@dynamic index;
@dynamic groupsArray, groupsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic top;
@dynamic skillId;
@dynamic iaId;
@dynamic activityId;
@dynamic authInfoListArray, authInfoListArray_Count;
@dynamic tagURL;
@dynamic playNum;
@dynamic trendsType;
@dynamic ipArea;
@dynamic shareNum;

typedef struct PB3CommunityTrendData__storage_ {
  uint32_t _has_storage_[1];
  int32_t likeNum;
  int32_t commentNum;
  int32_t index;
  int32_t skillId;
  int32_t iaId;
  int32_t activityId;
  int32_t playNum;
  PB3TrendsType trendsType;
  int32_t shareNum;
  PB3Publisher *publisher;
  NSString *content;
  NSMutableArray *tagsArray;
  NSMutableArray *mediaUrlsArray;
  NSMutableArray *groupsArray;
  NSMutableArray *atPlayerArray;
  NSMutableArray *authInfoListArray;
  NSString *tagURL;
  NSString *ipArea;
  int64_t id_p;
  int64_t publishAt;
  int64_t top;
} PB3CommunityTrendData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "publisher",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3Publisher),
        .number = PB3CommunityTrendData_FieldNumber_Publisher,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, publisher),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_LikeNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_CommentNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendTag),
        .number = PB3CommunityTrendData_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publishAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_PublishAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, publishAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MediaResource),
        .number = PB3CommunityTrendData_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isGaveLike",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_IsGaveLike,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_Index,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GroupInfoSimple),
        .number = PB3CommunityTrendData_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AtPlayer),
        .number = PB3CommunityTrendData_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "top",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_Top,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, top),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_SkillId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "iaId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_IaId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, iaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activityId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_ActivityId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, activityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PAuthInfo),
        .number = PB3CommunityTrendData_FieldNumber_AuthInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, authInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_TagURL,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, tagURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_PlayNum,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, playNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendsType",
        .dataTypeSpecific.enumDescFunc = PB3TrendsType_EnumDescriptor,
        .number = PB3CommunityTrendData_FieldNumber_TrendsType,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, trendsType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ipArea",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_IpArea,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, ipArea),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendData_FieldNumber_ShareNum,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB3CommunityTrendData__storage_, shareNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendData class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\022\003\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityTrendData_TrendsType_RawValue(PB3CommunityTrendData *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendData_FieldNumber_TrendsType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendData_TrendsType_RawValue(PB3CommunityTrendData *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendData_FieldNumber_TrendsType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3Publisher

@implementation PB3Publisher

@dynamic id_p;
@dynamic id2;
@dynamic sex;
@dynamic name;
@dynamic icon;
@dynamic roomId;
@dynamic isBillPlayer;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic clanId;
@dynamic clanName;
@dynamic clanLevel;
@dynamic clanIconWord;
@dynamic iconType;
@dynamic signature;
@dynamic effectArray, effectArray_Count;
@dynamic isDeleted;

typedef struct PB3Publisher__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  int32_t wealthLevel;
  int32_t charmLevel;
  PB3CommunityClanIconType iconType;
  NSString *name;
  NSString *icon;
  NSString *clanName;
  NSString *clanIconWord;
  NSString *signature;
  NSMutableArray *effectArray;
  int64_t id_p;
  int64_t id2;
  int64_t roomId;
  int64_t clanId;
  int64_t clanLevel;
} PB3Publisher__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_RoomId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isBillPlayer",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_IsBillPlayer,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_WealthLevel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_CharmLevel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clanId",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_ClanId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, clanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clanName",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_ClanName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, clanName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clanLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_ClanLevel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, clanLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "clanIconWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_ClanIconWord,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, clanIconWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityClanIconType_EnumDescriptor,
        .number = PB3Publisher_FieldNumber_IconType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, iconType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_Signature,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3PluginEffect),
        .number = PB3Publisher_FieldNumber_EffectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3Publisher__storage_, effectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isDeleted",
        .dataTypeSpecific.className = NULL,
        .number = PB3Publisher_FieldNumber_IsDeleted,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3Publisher class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3Publisher__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3Publisher_IconType_RawValue(PB3Publisher *message) {
  GPBDescriptor *descriptor = [PB3Publisher descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Publisher_FieldNumber_IconType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3Publisher_IconType_RawValue(PB3Publisher *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3Publisher descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3Publisher_FieldNumber_IconType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityGroupTrendList

@implementation PB3CommunityGroupTrendList

@dynamic listArray, listArray_Count;
@dynamic hasGroupInfo, groupInfo;
@dynamic collection;
@dynamic status;
@dynamic applyingNum;

typedef struct PB3CommunityGroupTrendList__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityGroupStatus status;
  int32_t applyingNum;
  NSMutableArray *listArray;
  PB3CommunityGroupInfo *groupInfo;
} PB3CommunityGroupTrendList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityGroupTrendList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityGroupTrendList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityGroupInfo),
        .number = PB3CommunityGroupTrendList_FieldNumber_GroupInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupTrendList__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "collection",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupTrendList_FieldNumber_Collection,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3CommunityGroupStatus_EnumDescriptor,
        .number = PB3CommunityGroupTrendList_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityGroupTrendList__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "applyingNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupTrendList_FieldNumber_ApplyingNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityGroupTrendList__storage_, applyingNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupTrendList class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupTrendList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityGroupTrendList_Status_RawValue(PB3CommunityGroupTrendList *message) {
  GPBDescriptor *descriptor = [PB3CommunityGroupTrendList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupTrendList_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityGroupTrendList_Status_RawValue(PB3CommunityGroupTrendList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityGroupTrendList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityGroupTrendList_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3TrendTag

@implementation PB3TrendTag

@dynamic id_p;
@dynamic name;
@dynamic index;
@dynamic icon;
@dynamic hot;
@dynamic comment;
@dynamic URL;
@dynamic buttonText;
@dynamic styleId;

typedef struct PB3TrendTag__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB3TrendTagStyle styleId;
  NSString *name;
  NSString *icon;
  NSString *comment;
  NSString *URL;
  NSString *buttonText;
  int64_t id_p;
  int64_t hot;
} PB3TrendTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hot",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Hot,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, hot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_Comment,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buttonText",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTag_FieldNumber_ButtonText,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, buttonText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "styleId",
        .dataTypeSpecific.enumDescFunc = PB3TrendTagStyle_EnumDescriptor,
        .number = PB3TrendTag_FieldNumber_StyleId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3TrendTag__storage_, styleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendTag class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3TrendTag_StyleId_RawValue(PB3TrendTag *message) {
  GPBDescriptor *descriptor = [PB3TrendTag descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TrendTag_FieldNumber_StyleId];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3TrendTag_StyleId_RawValue(PB3TrendTag *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3TrendTag descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3TrendTag_FieldNumber_StyleId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPlayerInfo

@implementation PB3CommunityPlayerInfo

@dynamic id_p;
@dynamic id2;
@dynamic nickName;
@dynamic icon;
@dynamic sex;

typedef struct PB3CommunityPlayerInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3PluginSexType sex;
  NSString *nickName;
  NSString *icon;
  int64_t id_p;
  int64_t id2;
} PB3CommunityPlayerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerInfo_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerInfo__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerInfo_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerInfo__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerInfo_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB3PluginSexType_EnumDescriptor,
        .number = PB3CommunityPlayerInfo_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPlayerInfo_Sex_RawValue(PB3CommunityPlayerInfo *message) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPlayerInfo_Sex_RawValue(PB3CommunityPlayerInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3MediaResource

@implementation PB3MediaResource

@dynamic mediaType;
@dynamic mediaURL;
@dynamic coverURL;
@dynamic mediaWidth;
@dynamic mediaHeight;
@dynamic mediaSecond;
@dynamic videoURL;
@dynamic audioURL;
@dynamic videoId;
@dynamic transVideoURL;
@dynamic transCoverURL;

typedef struct PB3MediaResource__storage_ {
  uint32_t _has_storage_[1];
  PB3MediaType mediaType;
  int32_t mediaWidth;
  int32_t mediaHeight;
  int32_t mediaSecond;
  NSString *mediaURL;
  NSString *coverURL;
  NSString *videoURL;
  NSString *audioURL;
  NSString *videoId;
  NSString *transVideoURL;
  NSString *transCoverURL;
} PB3MediaResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaType",
        .dataTypeSpecific.enumDescFunc = PB3MediaType_EnumDescriptor,
        .number = PB3MediaResource_FieldNumber_MediaType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, mediaType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mediaURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_MediaURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, mediaURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_CoverURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaWidth",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_MediaWidth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, mediaWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mediaHeight",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_MediaHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, mediaHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mediaSecond",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_MediaSecond,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, mediaSecond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_VideoURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, videoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "audioURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_AudioURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, audioURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_VideoId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, videoId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transVideoURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_TransVideoURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, transVideoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transCoverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3MediaResource_FieldNumber_TransCoverURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3MediaResource__storage_, transCoverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MediaResource class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MediaResource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\005\241!!\000\003\005\241!!\000\007\005\241!!\000\010\005\241!!\000\n\005\245\241!!\000\013\005\245\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3MediaResource_MediaType_RawValue(PB3MediaResource *message) {
  GPBDescriptor *descriptor = [PB3MediaResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MediaResource_FieldNumber_MediaType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3MediaResource_MediaType_RawValue(PB3MediaResource *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3MediaResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3MediaResource_FieldNumber_MediaType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPublishReq

@implementation PB3CommunityPublishReq

@dynamic content;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic contentType;
@dynamic tagsArray, tagsArray_Count;
@dynamic groupType;
@dynamic groupsArray, groupsArray_Count;
@dynamic atPlayerIdArray, atPlayerIdArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic skillId;
@dynamic interactionId;
@dynamic trendsType;

typedef struct PB3CommunityPublishReq__storage_ {
  uint32_t _has_storage_[1];
  PB3ContentType contentType;
  PB3PublishGroupType groupType;
  PB3TrendsType trendsType;
  NSString *content;
  NSMutableArray *mediaUrlsArray;
  GPBInt64Array *tagsArray;
  GPBInt64Array *groupsArray;
  GPBInt64Array *atPlayerIdArray;
  NSMutableArray *atPlayerArray;
  int64_t skillId;
  int64_t interactionId;
} PB3CommunityPublishReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MediaResource),
        .number = PB3CommunityPublishReq_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.enumDescFunc = PB3ContentType_EnumDescriptor,
        .number = PB3CommunityPublishReq_FieldNumber_ContentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, tagsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupType",
        .dataTypeSpecific.enumDescFunc = PB3PublishGroupType_EnumDescriptor,
        .number = PB3CommunityPublishReq_FieldNumber_GroupType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, groupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, groupsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "atPlayerIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_AtPlayerIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, atPlayerIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AtPlayer),
        .number = PB3CommunityPublishReq_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_SkillId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interactionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishReq_FieldNumber_InteractionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, interactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendsType",
        .dataTypeSpecific.enumDescFunc = PB3TrendsType_EnumDescriptor,
        .number = PB3CommunityPublishReq_FieldNumber_TrendsType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CommunityPublishReq__storage_, trendsType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPublishReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPublishReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPublishReq_ContentType_RawValue(PB3CommunityPublishReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_ContentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPublishReq_ContentType_RawValue(PB3CommunityPublishReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_ContentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3CommunityPublishReq_GroupType_RawValue(PB3CommunityPublishReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_GroupType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPublishReq_GroupType_RawValue(PB3CommunityPublishReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_GroupType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3CommunityPublishReq_TrendsType_RawValue(PB3CommunityPublishReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_TrendsType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPublishReq_TrendsType_RawValue(PB3CommunityPublishReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPublishReq_FieldNumber_TrendsType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPublishRes

@implementation PB3CommunityPublishRes

@dynamic trendsId;
@dynamic toastText;
@dynamic createAt;

typedef struct PB3CommunityPublishRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  int64_t trendsId;
  int64_t createAt;
} PB3CommunityPublishRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishRes_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPublishRes__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishRes_FieldNumber_ToastText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPublishRes__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishRes_FieldNumber_CreateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPublishRes__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPublishRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPublishRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsOperReq

@implementation PB3CommunityTrendsOperReq

@dynamic operType;
@dynamic trendsId;
@dynamic commentId;
@dynamic comment;
@dynamic commentMediaUrlsArray, commentMediaUrlsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic recmdSource;
@dynamic recmdSourceId;
@dynamic traceInfo;

typedef struct PB3CommunityTrendsOperReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TrendsOperType operType;
  int32_t commentId;
  PB3VideoRecmdSource recmdSource;
  NSString *comment;
  NSMutableArray *commentMediaUrlsArray;
  NSMutableArray *atPlayerArray;
  NSString *recmdSourceId;
  NSString *traceInfo;
  int64_t trendsId;
} PB3CommunityTrendsOperReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operType",
        .dataTypeSpecific.enumDescFunc = PB3TrendsOperType_EnumDescriptor,
        .number = PB3CommunityTrendsOperReq_FieldNumber_OperType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, operType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperReq_FieldNumber_TrendsId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperReq_FieldNumber_CommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperReq_FieldNumber_Comment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentMediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MediaResource),
        .number = PB3CommunityTrendsOperReq_FieldNumber_CommentMediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, commentMediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AtPlayer),
        .number = PB3CommunityTrendsOperReq_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recmdSource",
        .dataTypeSpecific.enumDescFunc = PB3VideoRecmdSource_EnumDescriptor,
        .number = PB3CommunityTrendsOperReq_FieldNumber_RecmdSource,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, recmdSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recmdSourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperReq_FieldNumber_RecmdSourceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, recmdSourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperReq_FieldNumber_TraceInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperReq__storage_, traceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsOperReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsOperReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityTrendsOperReq_OperType_RawValue(PB3CommunityTrendsOperReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsOperReq_FieldNumber_OperType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendsOperReq_OperType_RawValue(PB3CommunityTrendsOperReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsOperReq_FieldNumber_OperType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3CommunityTrendsOperReq_RecmdSource_RawValue(PB3CommunityTrendsOperReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsOperReq_FieldNumber_RecmdSource];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendsOperReq_RecmdSource_RawValue(PB3CommunityTrendsOperReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsOperReq_FieldNumber_RecmdSource];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTrendsOperRes

@implementation PB3CommunityTrendsOperRes

@dynamic commentId;
@dynamic shareId;
@dynamic shareURL;

typedef struct PB3CommunityTrendsOperRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  NSString *shareURL;
  int64_t shareId;
} PB3CommunityTrendsOperRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperRes_FieldNumber_CommentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperRes__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shareId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperRes_FieldNumber_ShareId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperRes__storage_, shareId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shareURL",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsOperRes_FieldNumber_ShareURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsOperRes__storage_, shareURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsOperRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsOperRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsListReq

@implementation PB3CommunityTrendsListReq

@dynamic playerId;
@dynamic index;

typedef struct PB3CommunityTrendsListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t playerId;
} PB3CommunityTrendsListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsListReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsListReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsListRes

@implementation PB3CommunityTrendsListRes

@dynamic listArray, listArray_Count;
@dynamic nextIndex;

typedef struct PB3CommunityTrendsListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *listArray;
} PB3CommunityTrendsListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityTrendsListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsListRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityLastTrendsReq

@implementation PB3CommunityLastTrendsReq

@dynamic playerId;

typedef struct PB3CommunityLastTrendsReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3CommunityLastTrendsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityLastTrendsReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityLastTrendsReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityLastTrendsReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityLastTrendsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityLastTrendsRes

@implementation PB3CommunityLastTrendsRes

@dynamic listArray, listArray_Count;

typedef struct PB3CommunityLastTrendsRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB3CommunityLastTrendsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityLastTrendsRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityLastTrendsRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityLastTrendsRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityLastTrendsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsComment

@implementation PB3TrendsComment

@dynamic trendsId;
@dynamic trendsPlayerId;
@dynamic commentId;
@dynamic level;
@dynamic commentNum;
@dynamic detailsArray, detailsArray_Count;
@dynamic nextIndex;

typedef struct PB3TrendsComment__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t level;
  int32_t commentNum;
  int32_t nextIndex;
  NSMutableArray *detailsArray;
  int64_t trendsId;
  int64_t trendsPlayerId;
} PB3TrendsComment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendsPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_TrendsPlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, trendsPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_CommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_CommentNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detailsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendsCommentDetail),
        .number = PB3TrendsComment_FieldNumber_DetailsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, detailsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsComment_FieldNumber_NextIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TrendsComment__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsComment class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsComment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsCommentDetail

@implementation PB3TrendsCommentDetail

@dynamic trendsId;
@dynamic commentId;
@dynamic hasCommentPlayer, commentPlayer;
@dynamic hasToPlayer, toPlayer;
@dynamic content;
@dynamic commentTime;
@dynamic hasComments, comments;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic likeNum;
@dynamic isGaveLike;
@dynamic ipArea;

typedef struct PB3TrendsCommentDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t likeNum;
  PB3CommunityPlayerInfo *commentPlayer;
  PB3CommunityPlayerInfo *toPlayer;
  NSString *content;
  PB3TrendsComment *comments;
  NSMutableArray *mediaUrlsArray;
  NSMutableArray *atPlayerArray;
  NSString *ipArea;
  int64_t trendsId;
  int64_t commentTime;
} PB3TrendsCommentDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerInfo),
        .number = PB3TrendsCommentDetail_FieldNumber_CommentPlayer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, commentPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerInfo),
        .number = PB3TrendsCommentDetail_FieldNumber_ToPlayer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, toPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_CommentTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, commentTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comments",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendsComment),
        .number = PB3TrendsCommentDetail_FieldNumber_Comments,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, comments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MediaResource),
        .number = PB3TrendsCommentDetail_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AtPlayer),
        .number = PB3TrendsCommentDetail_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_LikeNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isGaveLike",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_IsGaveLike,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ipArea",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentDetail_FieldNumber_IpArea,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3TrendsCommentDetail__storage_, ipArea),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsCommentDetail class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsCommentDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3HotPointDetail

@implementation PB3HotPointDetail

@dynamic hotPointId;
@dynamic playerId;
@dynamic name;
@dynamic icon;
@dynamic gold;
@dynamic heat;
@dynamic content;
@dynamic contentResponse;
@dynamic contentResponseTime;
@dynamic contentResponseStatus;
@dynamic contentResponseMediaUrlsArray, contentResponseMediaUrlsArray_Count;
@dynamic isValid;
@dynamic heatRankArray, heatRankArray_Count;
@dynamic resAtPlayerArray, resAtPlayerArray_Count;
@dynamic unShelveGold;
@dynamic type;
@dynamic status;
@dynamic responseLimit;
@dynamic isOnRank;
@dynamic removeHotPointCoefficient;
@dynamic heatGoldLimit;

typedef struct PB3HotPointDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t gold;
  int32_t heat;
  PB3ContentResStatus contentResponseStatus;
  int32_t unShelveGold;
  PB3PluginHotPointType type;
  PB3HotPointStatus status;
  int32_t responseLimit;
  float removeHotPointCoefficient;
  int32_t heatGoldLimit;
  NSString *name;
  NSString *icon;
  NSString *content;
  NSString *contentResponse;
  NSMutableArray *contentResponseMediaUrlsArray;
  NSMutableArray *heatRankArray;
  NSMutableArray *resAtPlayerArray;
  int64_t hotPointId;
  int64_t playerId;
  int64_t contentResponseTime;
} PB3HotPointDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotPointId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_HotPointId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, hotPointId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_Gold,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "heat",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_Heat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, heat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_Content,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentResponse",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_ContentResponse,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, contentResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentResponseTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_ContentResponseTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, contentResponseTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "contentResponseStatus",
        .dataTypeSpecific.enumDescFunc = PB3ContentResStatus_EnumDescriptor,
        .number = PB3HotPointDetail_FieldNumber_ContentResponseStatus,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, contentResponseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contentResponseMediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MediaResource),
        .number = PB3HotPointDetail_FieldNumber_ContentResponseMediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, contentResponseMediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isValid",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_IsValid,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "heatRankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3FirepowerRank),
        .number = PB3HotPointDetail_FieldNumber_HeatRankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, heatRankArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resAtPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3AtPlayer),
        .number = PB3HotPointDetail_FieldNumber_ResAtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, resAtPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unShelveGold",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_UnShelveGold,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, unShelveGold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3PluginHotPointType_EnumDescriptor,
        .number = PB3HotPointDetail_FieldNumber_Type,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3HotPointStatus_EnumDescriptor,
        .number = PB3HotPointDetail_FieldNumber_Status,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "responseLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_ResponseLimit,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, responseLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOnRank",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_IsOnRank,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "removeHotPointCoefficient",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_RemoveHotPointCoefficient,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, removeHotPointCoefficient),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "heatGoldLimit",
        .dataTypeSpecific.className = NULL,
        .number = PB3HotPointDetail_FieldNumber_HeatGoldLimit,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB3HotPointDetail__storage_, heatGoldLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3HotPointDetail class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3HotPointDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\r\000heatRank\000\022M\000\024Y\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3HotPointDetail_ContentResponseStatus_RawValue(PB3HotPointDetail *message) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_ContentResponseStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HotPointDetail_ContentResponseStatus_RawValue(PB3HotPointDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_ContentResponseStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3HotPointDetail_Type_RawValue(PB3HotPointDetail *message) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HotPointDetail_Type_RawValue(PB3HotPointDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB3HotPointDetail_Status_RawValue(PB3HotPointDetail *message) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3HotPointDetail_Status_RawValue(PB3HotPointDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3HotPointDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3HotPointDetail_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTrendsDetailReq

@implementation PB3CommunityTrendsDetailReq

@dynamic trendsId;
@dynamic trendsType;
@dynamic isView;

typedef struct PB3CommunityTrendsDetailReq__storage_ {
  uint32_t _has_storage_[1];
  PB3TrendsType trendsType;
  int64_t trendsId;
} PB3CommunityTrendsDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsDetailReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsDetailReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendsType",
        .dataTypeSpecific.enumDescFunc = PB3TrendsType_EnumDescriptor,
        .number = PB3CommunityTrendsDetailReq_FieldNumber_TrendsType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsDetailReq__storage_, trendsType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isView",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsDetailReq_FieldNumber_IsView,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsDetailReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityTrendsDetailReq_TrendsType_RawValue(PB3CommunityTrendsDetailReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsDetailReq_FieldNumber_TrendsType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendsDetailReq_TrendsType_RawValue(PB3CommunityTrendsDetailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsDetailReq_FieldNumber_TrendsType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTrendsDetailRes

@implementation PB3CommunityTrendsDetailRes

@dynamic hasTrends, trends;
@dynamic likersArray, likersArray_Count;
@dynamic hasHot, hot;

typedef struct PB3CommunityTrendsDetailRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityTrendData *trends;
  NSMutableArray *likersArray;
  PB3HotPointDetail *hot;
} PB3CommunityTrendsDetailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trends",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityTrendsDetailRes_FieldNumber_Trends,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsDetailRes__storage_, trends),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "likersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerInfo),
        .number = PB3CommunityTrendsDetailRes_FieldNumber_LikersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsDetailRes__storage_, likersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hot",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3HotPointDetail),
        .number = PB3CommunityTrendsDetailRes_FieldNumber_Hot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsDetailRes__storage_, hot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsDetailRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsDetailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsCommentsReq

@implementation PB3CommunityTrendsCommentsReq

@dynamic trendsId;
@dynamic commentId;
@dynamic index;
@dynamic commentType;

typedef struct PB3CommunityTrendsCommentsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t index;
  PB3CommentType commentType;
  int64_t trendsId;
} PB3CommunityTrendsCommentsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsCommentsReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsCommentsReq_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsCommentsReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentType",
        .dataTypeSpecific.enumDescFunc = PB3CommentType_EnumDescriptor,
        .number = PB3CommunityTrendsCommentsReq_FieldNumber_CommentType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsReq__storage_, commentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsCommentsReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsCommentsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004G\244\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityTrendsCommentsReq_CommentType_RawValue(PB3CommunityTrendsCommentsReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsCommentsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsCommentsReq_FieldNumber_CommentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityTrendsCommentsReq_CommentType_RawValue(PB3CommunityTrendsCommentsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityTrendsCommentsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityTrendsCommentsReq_FieldNumber_CommentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityTrendsCommentsRes

@implementation PB3CommunityTrendsCommentsRes

@dynamic hasComments, comments;
@dynamic commentNum;

typedef struct PB3CommunityTrendsCommentsRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentNum;
  PB3TrendsComment *comments;
} PB3CommunityTrendsCommentsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "comments",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendsComment),
        .number = PB3CommunityTrendsCommentsRes_FieldNumber_Comments,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsRes__storage_, comments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsCommentsRes_FieldNumber_CommentNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsCommentsRes__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsCommentsRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsCommentsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsLikersReq

@implementation PB3CommunityTrendsLikersReq

@dynamic trendsId;
@dynamic index;

typedef struct PB3CommunityTrendsLikersReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t trendsId;
} PB3CommunityTrendsLikersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsLikersReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsLikersReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsLikersReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsLikersReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsLikersReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsLikersReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityTrendsLikersRes

@implementation PB3CommunityTrendsLikersRes

@dynamic likersArray, likersArray_Count;
@dynamic nextIndex;

typedef struct PB3CommunityTrendsLikersRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *likersArray;
} PB3CommunityTrendsLikersRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "likersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityGroupPlayerItem),
        .number = PB3CommunityTrendsLikersRes_FieldNumber_LikersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsLikersRes__storage_, likersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityTrendsLikersRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityTrendsLikersRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityTrendsLikersRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityTrendsLikersRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityClanInfo

@implementation PB3CommunityClanInfo

@dynamic id_p;
@dynamic iconWord;
@dynamic levelName;
@dynamic name;
@dynamic level;
@dynamic iconType;

typedef struct PB3CommunityClanInfo__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityClanIconType iconType;
  NSString *iconWord;
  NSString *levelName;
  NSString *name;
  int64_t id_p;
  int64_t level;
} PB3CommunityClanInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityClanInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "iconWord",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityClanInfo_FieldNumber_IconWord,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, iconWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levelName",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityClanInfo_FieldNumber_LevelName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, levelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityClanInfo_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityClanInfo_FieldNumber_Level,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "iconType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityClanIconType_EnumDescriptor,
        .number = PB3CommunityClanInfo_FieldNumber_IconType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3CommunityClanInfo__storage_, iconType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityClanInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityClanInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityClanInfo_IconType_RawValue(PB3CommunityClanInfo *message) {
  GPBDescriptor *descriptor = [PB3CommunityClanInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityClanInfo_FieldNumber_IconType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityClanInfo_IconType_RawValue(PB3CommunityClanInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityClanInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityClanInfo_FieldNumber_IconType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityCreateOrUpdateGroupReq

@implementation PB3CommunityCreateOrUpdateGroupReq

@dynamic groupId;
@dynamic groupName;
@dynamic groupImg;
@dynamic groupDescribe;

typedef struct PB3CommunityCreateOrUpdateGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
  NSString *groupImg;
  NSString *groupDescribe;
  int64_t groupId;
} PB3CommunityCreateOrUpdateGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateOrUpdateGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityCreateOrUpdateGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateOrUpdateGroupReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityCreateOrUpdateGroupReq__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateOrUpdateGroupReq_FieldNumber_GroupImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityCreateOrUpdateGroupReq__storage_, groupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateOrUpdateGroupReq_FieldNumber_GroupDescribe,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityCreateOrUpdateGroupReq__storage_, groupDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityCreateOrUpdateGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityCreateOrUpdateGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityCreateOrUpdateGroupRes

@implementation PB3CommunityCreateOrUpdateGroupRes

@dynamic groupId;

typedef struct PB3CommunityCreateOrUpdateGroupRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB3CommunityCreateOrUpdateGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateOrUpdateGroupRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityCreateOrUpdateGroupRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityCreateOrUpdateGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityCreateOrUpdateGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityJoinGroupReq

@implementation PB3CommunityJoinGroupReq

@dynamic groupId;
@dynamic applyMsg;

typedef struct PB3CommunityJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *applyMsg;
  int64_t groupId;
} PB3CommunityJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinGroupReq_FieldNumber_ApplyMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityJoinGroupReq__storage_, applyMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityJoinGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityJoinGroupRes

@implementation PB3CommunityJoinGroupRes


typedef struct PB3CommunityJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityJoinGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityJoinInfo

@implementation PB3CommunityJoinInfo

@dynamic playerId;
@dynamic groupId;
@dynamic applyAt;
@dynamic applyMsg;

typedef struct PB3CommunityJoinInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *applyMsg;
  int64_t playerId;
  int64_t groupId;
  int64_t applyAt;
} PB3CommunityJoinInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityJoinInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinInfo_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityJoinInfo__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinInfo_FieldNumber_ApplyAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityJoinInfo__storage_, applyAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityJoinInfo_FieldNumber_ApplyMsg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityJoinInfo__storage_, applyMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityJoinInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityJoinInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityVerifyListReq

@implementation PB3CommunityVerifyListReq

@dynamic groupId;
@dynamic index;

typedef struct PB3CommunityVerifyListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t groupId;
} PB3CommunityVerifyListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityVerifyListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyListReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityVerifyListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityVerifyListReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityVerifyListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityVerifyListRes

@implementation PB3CommunityVerifyListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB3CommunityVerifyListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB3CommunityVerifyListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3VerifyItem),
        .number = PB3CommunityVerifyListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityVerifyListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityVerifyListRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityVerifyListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3VerifyItem

@implementation PB3VerifyItem

@dynamic hasInfo, info;
@dynamic hasBaseInfo, baseInfo;

typedef struct PB3VerifyItem__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityJoinInfo *info;
  PB3MemberBaseInfo *baseInfo;
} PB3VerifyItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityJoinInfo),
        .number = PB3VerifyItem_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3VerifyItem__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MemberBaseInfo),
        .number = PB3VerifyItem_FieldNumber_BaseInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3VerifyItem__storage_, baseInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3VerifyItem class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3VerifyItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3MemberBaseInfo

@implementation PB3MemberBaseInfo

@dynamic playerId;
@dynamic playerId2;
@dynamic sex;
@dynamic name;
@dynamic signature;
@dynamic charmLv;
@dynamic wealthLv;
@dynamic icon;
@dynamic hasClan, clan;

typedef struct PB3MemberBaseInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  int32_t charmLv;
  int32_t wealthLv;
  NSString *name;
  NSString *signature;
  NSString *icon;
  PB3CommunityClanInfo *clan;
  int64_t playerId;
  int64_t playerId2;
} PB3MemberBaseInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId2",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_PlayerId2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, playerId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_Signature,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charmLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_CharmLv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, charmLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_WealthLv,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, wealthLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3MemberBaseInfo_FieldNumber_Icon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityClanInfo),
        .number = PB3MemberBaseInfo_FieldNumber_Clan,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3MemberBaseInfo__storage_, clan),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3MemberBaseInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3MemberBaseInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityVerifyJoinReq

@implementation PB3CommunityVerifyJoinReq

@dynamic groupId;
@dynamic playerId;
@dynamic opt;

typedef struct PB3CommunityVerifyJoinReq__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityGroupOpt opt;
  int64_t groupId;
  int64_t playerId;
} PB3CommunityVerifyJoinReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityVerifyJoinReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyJoinReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityVerifyJoinReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyJoinReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.enumDescFunc = PB3CommunityGroupOpt_EnumDescriptor,
        .number = PB3CommunityVerifyJoinReq_FieldNumber_Opt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityVerifyJoinReq__storage_, opt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityVerifyJoinReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityVerifyJoinReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityVerifyJoinReq_Opt_RawValue(PB3CommunityVerifyJoinReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityVerifyJoinReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityVerifyJoinReq_FieldNumber_Opt];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityVerifyJoinReq_Opt_RawValue(PB3CommunityVerifyJoinReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityVerifyJoinReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityVerifyJoinReq_FieldNumber_Opt];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityVerifyJoinRes

@implementation PB3CommunityVerifyJoinRes


typedef struct PB3CommunityVerifyJoinRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityVerifyJoinRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityVerifyJoinRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityVerifyJoinRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityStoreGroupReq

@implementation PB3CommunityStoreGroupReq

@dynamic groupId;
@dynamic opt;

typedef struct PB3CommunityStoreGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t opt;
  int64_t groupId;
} PB3CommunityStoreGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityStoreGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityStoreGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityStoreGroupReq_FieldNumber_Opt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityStoreGroupReq__storage_, opt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityStoreGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityStoreGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityStoreGroupRes

@implementation PB3CommunityStoreGroupRes


typedef struct PB3CommunityStoreGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityStoreGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityStoreGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityStoreGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupInfoReq

@implementation PB3CommunityGroupInfoReq

@dynamic groupId;

typedef struct PB3CommunityGroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB3CommunityGroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupInfoReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupInfoRes

@implementation PB3CommunityGroupInfoRes

@dynamic hasBaseDetail, baseDetail;
@dynamic memberNum;
@dynamic trendNum;
@dynamic hasOwnerInfo, ownerInfo;
@dynamic applyNum;

typedef struct PB3CommunityGroupInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  int32_t applyNum;
  PB3GroupDetail *baseDetail;
  PB3MemberBaseInfo *ownerInfo;
} PB3CommunityGroupInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GroupDetail),
        .number = PB3CommunityGroupInfoRes_FieldNumber_BaseDetail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoRes__storage_, baseDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfoRes_FieldNumber_MemberNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoRes__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfoRes_FieldNumber_TrendNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoRes__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ownerInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MemberBaseInfo),
        .number = PB3CommunityGroupInfoRes_FieldNumber_OwnerInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoRes__storage_, ownerInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupInfoRes_FieldNumber_ApplyNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityGroupInfoRes__storage_, applyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupInfoRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GroupDetail

@implementation PB3GroupDetail

@dynamic groupId;
@dynamic groupName;
@dynamic groupImg;
@dynamic groupDescribe;
@dynamic clanId;
@dynamic status;
@dynamic isStore;
@dynamic isAuditing;

typedef struct PB3GroupDetail__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityGroupStatus status;
  NSString *groupName;
  NSString *groupImg;
  NSString *groupDescribe;
  int64_t groupId;
  int64_t clanId;
} PB3GroupDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_GroupImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, groupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_GroupDescribe,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, groupDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clanId",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_ClanId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, clanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB3CommunityGroupStatus_EnumDescriptor,
        .number = PB3GroupDetail_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB3GroupDetail__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isStore",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_IsStore,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAuditing",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupDetail_FieldNumber_IsAuditing,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GroupDetail class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GroupDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3GroupDetail_Status_RawValue(PB3GroupDetail *message) {
  GPBDescriptor *descriptor = [PB3GroupDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GroupDetail_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3GroupDetail_Status_RawValue(PB3GroupDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3GroupDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3GroupDetail_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityLeaveGroupReq

@implementation PB3CommunityLeaveGroupReq

@dynamic groupId;
@dynamic leavePlayerId;
@dynamic opt;

typedef struct PB3CommunityLeaveGroupReq__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityGroupLeaveOpt opt;
  int64_t groupId;
  int64_t leavePlayerId;
} PB3CommunityLeaveGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityLeaveGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityLeaveGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leavePlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityLeaveGroupReq_FieldNumber_LeavePlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityLeaveGroupReq__storage_, leavePlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.enumDescFunc = PB3CommunityGroupLeaveOpt_EnumDescriptor,
        .number = PB3CommunityLeaveGroupReq_FieldNumber_Opt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityLeaveGroupReq__storage_, opt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityLeaveGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityLeaveGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityLeaveGroupReq_Opt_RawValue(PB3CommunityLeaveGroupReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityLeaveGroupReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityLeaveGroupReq_FieldNumber_Opt];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityLeaveGroupReq_Opt_RawValue(PB3CommunityLeaveGroupReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityLeaveGroupReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityLeaveGroupReq_FieldNumber_Opt];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityLeaveGroupRes

@implementation PB3CommunityLeaveGroupRes


typedef struct PB3CommunityLeaveGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityLeaveGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityLeaveGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityLeaveGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerGroupListReq

@implementation PB3CommunityPlayerGroupListReq

@dynamic playerGroupType;
@dynamic playerId;
@dynamic index;

typedef struct PB3CommunityPlayerGroupListReq__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityPlayerGroupType playerGroupType;
  int32_t index;
  int64_t playerId;
} PB3CommunityPlayerGroupListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerGroupType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityPlayerGroupType_EnumDescriptor,
        .number = PB3CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerGroupListReq__storage_, playerGroupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerGroupListReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerGroupListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerGroupListReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerGroupListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerGroupListReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerGroupListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPlayerGroupListReq_PlayerGroupType_RawValue(PB3CommunityPlayerGroupListReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerGroupListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPlayerGroupListReq_PlayerGroupType_RawValue(PB3CommunityPlayerGroupListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerGroupListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPlayerGroupListRes

@implementation PB3CommunityPlayerGroupListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB3CommunityPlayerGroupListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB3CommunityPlayerGroupListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GroupListItem),
        .number = PB3CommunityPlayerGroupListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerGroupListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerGroupListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerGroupListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerGroupListRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerGroupListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GroupListItem

@implementation PB3GroupListItem

@dynamic hasBaseDetail, baseDetail;
@dynamic memberNum;
@dynamic trendNum;
@dynamic isOwner;

typedef struct PB3GroupListItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  PB3GroupDetail *baseDetail;
} PB3GroupListItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GroupDetail),
        .number = PB3GroupListItem_FieldNumber_BaseDetail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GroupListItem__storage_, baseDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupListItem_FieldNumber_MemberNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GroupListItem__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupListItem_FieldNumber_TrendNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3GroupListItem__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOwner",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupListItem_FieldNumber_IsOwner,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GroupListItem class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GroupListItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupPlayerListReq

@implementation PB3CommunityGroupPlayerListReq

@dynamic groupId;
@dynamic index;

typedef struct PB3CommunityGroupPlayerListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t groupId;
} PB3CommunityGroupPlayerListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupPlayerListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerListReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupPlayerListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupPlayerListReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupPlayerListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupPlayerListRes

@implementation PB3CommunityGroupPlayerListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB3CommunityGroupPlayerListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB3CommunityGroupPlayerListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityGroupPlayerItem),
        .number = PB3CommunityGroupPlayerListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupPlayerListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupPlayerListRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupPlayerListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupPlayerItem

@implementation PB3CommunityGroupPlayerItem

@dynamic hasInfo, info;
@dynamic roomId;

typedef struct PB3CommunityGroupPlayerItem__storage_ {
  uint32_t _has_storage_[1];
  PB3MemberBaseInfo *info;
  int64_t roomId;
} PB3CommunityGroupPlayerItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3MemberBaseInfo),
        .number = PB3CommunityGroupPlayerItem_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerItem__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupPlayerItem_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupPlayerItem__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupPlayerItem class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupPlayerItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityCreateTagReq

@implementation PB3CommunityCreateTagReq

@dynamic tagName;

typedef struct PB3CommunityCreateTagReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *tagName;
} PB3CommunityCreateTagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagName",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityCreateTagReq_FieldNumber_TagName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityCreateTagReq__storage_, tagName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityCreateTagReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityCreateTagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityCreateTagRes

@implementation PB3CommunityCreateTagRes


typedef struct PB3CommunityCreateTagRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityCreateTagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityCreateTagRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityCreateTagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityAllTagReq

@implementation PB3CommunityAllTagReq


typedef struct PB3CommunityAllTagReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityAllTagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityAllTagReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityAllTagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityAllTagRes

@implementation PB3CommunityAllTagRes

@dynamic itemArray, itemArray_Count;

typedef struct PB3CommunityAllTagRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB3CommunityAllTagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendTag),
        .number = PB3CommunityAllTagRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityAllTagRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityAllTagRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityAllTagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgRedPointReq

@implementation PB3CommunityPlayerMsgRedPointReq


typedef struct PB3CommunityPlayerMsgRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityPlayerMsgRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgRedPointReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityPlayerMsgRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgRedPointRes

@implementation PB3CommunityPlayerMsgRedPointRes

@dynamic hasRedPoint, redPoint;

typedef struct PB3CommunityPlayerMsgRedPointRes__storage_ {
  uint32_t _has_storage_[1];
  PB3CommunityPlayerMsgRedPoint *redPoint;
} PB3CommunityPlayerMsgRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerMsgRedPoint),
        .number = PB3CommunityPlayerMsgRedPointRes_FieldNumber_RedPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgRedPointRes__storage_, redPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgRedPointRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerMsgRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgClearRedPointReq

@implementation PB3CommunityPlayerMsgClearRedPointReq


typedef struct PB3CommunityPlayerMsgClearRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityPlayerMsgClearRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgClearRedPointReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityPlayerMsgClearRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgClearRedPointRes

@implementation PB3CommunityPlayerMsgClearRedPointRes


typedef struct PB3CommunityPlayerMsgClearRedPointRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityPlayerMsgClearRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgClearRedPointRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityPlayerMsgClearRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgRedPoint

@implementation PB3CommunityPlayerMsgRedPoint

@dynamic num;

typedef struct PB3CommunityPlayerMsgRedPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB3CommunityPlayerMsgRedPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsgRedPoint_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgRedPoint__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgRedPoint class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerMsgRedPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerMsgReq

@implementation PB3CommunityPlayerMsgReq

@dynamic index;
@dynamic showType;

typedef struct PB3CommunityPlayerMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB3CommunityMsgShowType showType;
} PB3CommunityPlayerMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsgReq_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityMsgShowType_EnumDescriptor,
        .number = PB3CommunityPlayerMsgReq_FieldNumber_ShowType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgReq__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPlayerMsgReq_ShowType_RawValue(PB3CommunityPlayerMsgReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsgReq_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPlayerMsgReq_ShowType_RawValue(PB3CommunityPlayerMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsgReq_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPlayerMsgRes

@implementation PB3CommunityPlayerMsgRes

@dynamic listArray, listArray_Count;
@dynamic nextIndex;
@dynamic showType;

typedef struct PB3CommunityPlayerMsgRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  PB3CommunityMsgShowType showType;
  NSMutableArray *listArray;
} PB3CommunityPlayerMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerMsg),
        .number = PB3CommunityPlayerMsgRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsgRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB3CommunityMsgShowType_EnumDescriptor,
        .number = PB3CommunityPlayerMsgRes_FieldNumber_ShowType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsgRes__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsgRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPlayerMsgRes_ShowType_RawValue(PB3CommunityPlayerMsgRes *message) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsgRes_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPlayerMsgRes_ShowType_RawValue(PB3CommunityPlayerMsgRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsgRes_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPlayerMsg

@implementation PB3CommunityPlayerMsg

@dynamic id_p;
@dynamic hasTrend, trend;
@dynamic hasPlayer, player;
@dynamic hasCommentedPlayer, commentedPlayer;
@dynamic commentId;
@dynamic selfTrend;
@dynamic comment;
@dynamic creatAt;
@dynamic type;
@dynamic desc;

typedef struct PB3CommunityPlayerMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t commentId;
  PB3CommunityPlayerMsgType type;
  PB3CommunityTrendData *trend;
  PB3CommunityPlayerInfo *player;
  PB3CommunityPlayerInfo *commentedPlayer;
  NSString *comment;
  NSString *desc;
  int64_t creatAt;
} PB3CommunityPlayerMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityTrendData),
        .number = PB3CommunityPlayerMsg_FieldNumber_Trend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, trend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerInfo),
        .number = PB3CommunityPlayerMsg_FieldNumber_Player,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentedPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3CommunityPlayerInfo),
        .number = PB3CommunityPlayerMsg_FieldNumber_CommentedPlayer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, commentedPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_CommentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "selfTrend",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_SelfTrend,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_Comment,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creatAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_CreatAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, creatAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB3CommunityPlayerMsgType_EnumDescriptor,
        .number = PB3CommunityPlayerMsg_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerMsg_FieldNumber_Desc,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerMsg__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerMsg class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityPlayerMsg_Type_RawValue(PB3CommunityPlayerMsg *message) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsg_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityPlayerMsg_Type_RawValue(PB3CommunityPlayerMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityPlayerMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityPlayerMsg_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityPlayerStatReq

@implementation PB3CommunityPlayerStatReq

@dynamic playerId;

typedef struct PB3CommunityPlayerStatReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB3CommunityPlayerStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerStatReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerStatReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerStatReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPlayerStatRes

@implementation PB3CommunityPlayerStatRes

@dynamic trendsNum;
@dynamic joinGroupNum;

typedef struct PB3CommunityPlayerStatRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t trendsNum;
  int32_t joinGroupNum;
} PB3CommunityPlayerStatRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerStatRes_FieldNumber_TrendsNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerStatRes__storage_, trendsNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "joinGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPlayerStatRes_FieldNumber_JoinGroupNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityPlayerStatRes__storage_, joinGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPlayerStatRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPlayerStatRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityAgreementReq

@implementation PB3CommunityAgreementReq

@dynamic operType;

typedef struct PB3CommunityAgreementReq__storage_ {
  uint32_t _has_storage_[1];
  PB3AgreementOperType operType;
} PB3CommunityAgreementReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operType",
        .dataTypeSpecific.enumDescFunc = PB3AgreementOperType_EnumDescriptor,
        .number = PB3CommunityAgreementReq_FieldNumber_OperType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityAgreementReq__storage_, operType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityAgreementReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityAgreementReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3CommunityAgreementReq_OperType_RawValue(PB3CommunityAgreementReq *message) {
  GPBDescriptor *descriptor = [PB3CommunityAgreementReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityAgreementReq_FieldNumber_OperType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3CommunityAgreementReq_OperType_RawValue(PB3CommunityAgreementReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3CommunityAgreementReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3CommunityAgreementReq_FieldNumber_OperType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB3CommunityAgreementRes

@implementation PB3CommunityAgreementRes

@dynamic isAgree;

typedef struct PB3CommunityAgreementRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityAgreementRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isAgree",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityAgreementRes_FieldNumber_IsAgree,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityAgreementRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityAgreementRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPublishPermissionReq

@implementation PB3CommunityPublishPermissionReq


typedef struct PB3CommunityPublishPermissionReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityPublishPermissionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPublishPermissionReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityPublishPermissionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityPublishPermissionRes

@implementation PB3CommunityPublishPermissionRes

@dynamic isPermit;
@dynamic maxSelectLabelNum;
@dynamic maxSelectGroupNum;
@dynamic maxSelectMediaNum;

typedef struct PB3CommunityPublishPermissionRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxSelectLabelNum;
  int32_t maxSelectGroupNum;
  int32_t maxSelectMediaNum;
} PB3CommunityPublishPermissionRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPermit",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishPermissionRes_FieldNumber_IsPermit,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "maxSelectLabelNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishPermissionRes_FieldNumber_MaxSelectLabelNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityPublishPermissionRes__storage_, maxSelectLabelNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxSelectGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishPermissionRes_FieldNumber_MaxSelectGroupNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityPublishPermissionRes__storage_, maxSelectGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxSelectMediaNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityPublishPermissionRes_FieldNumber_MaxSelectMediaNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityPublishPermissionRes__storage_, maxSelectMediaNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityPublishPermissionRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityPublishPermissionRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupLimitReq

@implementation PB3CommunityGroupLimitReq


typedef struct PB3CommunityGroupLimitReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityGroupLimitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupLimitReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityGroupLimitReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityGroupLimitRes

@implementation PB3CommunityGroupLimitRes

@dynamic wealthLv;
@dynamic charmLv;
@dynamic andOr;
@dynamic maxActiveGroupNum;
@dynamic maxGroupMemberNum;
@dynamic showCreateButton;
@dynamic invitedInvalidTime;
@dynamic createMsg;

typedef struct PB3CommunityGroupLimitRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t wealthLv;
  int32_t charmLv;
  int32_t andOr;
  int32_t maxActiveGroupNum;
  int32_t maxGroupMemberNum;
  NSString *createMsg;
  int64_t invitedInvalidTime;
} PB3CommunityGroupLimitRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wealthLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_WealthLv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, wealthLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLv",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_CharmLv,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, charmLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "andOr",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_AndOr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, andOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxActiveGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_MaxActiveGroupNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, maxActiveGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxGroupMemberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_MaxGroupMemberNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, maxGroupMemberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showCreateButton",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_ShowCreateButton,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "invitedInvalidTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_InvitedInvalidTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, invitedInvalidTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityGroupLimitRes_FieldNumber_CreateMsg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3CommunityGroupLimitRes__storage_, createMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityGroupLimitRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityGroupLimitRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClearCommunityPlayerMsgReq

@implementation PB3ClearCommunityPlayerMsgReq


typedef struct PB3ClearCommunityPlayerMsgReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ClearCommunityPlayerMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearCommunityPlayerMsgReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClearCommunityPlayerMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClearCommunityPlayerMsgRes

@implementation PB3ClearCommunityPlayerMsgRes


typedef struct PB3ClearCommunityPlayerMsgRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClearCommunityPlayerMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearCommunityPlayerMsgRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClearCommunityPlayerMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3GroupInfoSimple

@implementation PB3GroupInfoSimple

@dynamic id_p;
@dynamic name;

typedef struct PB3GroupInfoSimple__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t id_p;
} PB3GroupInfoSimple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupInfoSimple_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3GroupInfoSimple__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB3GroupInfoSimple_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3GroupInfoSimple__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3GroupInfoSimple class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3GroupInfoSimple__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckCreateGroupReq

@implementation PB3CheckCreateGroupReq


typedef struct PB3CheckCreateGroupReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckCreateGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckCreateGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckCreateGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CheckCreateGroupRes

@implementation PB3CheckCreateGroupRes


typedef struct PB3CheckCreateGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3CheckCreateGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CheckCreateGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CheckCreateGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ApplyJoinNumPush

@implementation PB3ApplyJoinNumPush

@dynamic applyNum;
@dynamic groupId;

typedef struct PB3ApplyJoinNumPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t applyNum;
  int64_t groupId;
} PB3ApplyJoinNumPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB3ApplyJoinNumPush_FieldNumber_ApplyNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ApplyJoinNumPush__storage_, applyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ApplyJoinNumPush_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ApplyJoinNumPush__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ApplyJoinNumPush class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ApplyJoinNumPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PlayerGroupListResPush

@implementation PB3PlayerGroupListResPush

@dynamic itemArray, itemArray_Count;

typedef struct PB3PlayerGroupListResPush__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB3PlayerGroupListResPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3GroupListItem),
        .number = PB3PlayerGroupListResPush_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3PlayerGroupListResPush__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PlayerGroupListResPush class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PlayerGroupListResPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteJoinGroupReq

@implementation PB3InviteJoinGroupReq

@dynamic invitedId;
@dynamic groupId;

typedef struct PB3InviteJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t invitedId;
  int64_t groupId;
} PB3InviteJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteJoinGroupReq_FieldNumber_InvitedId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3InviteJoinGroupReq__storage_, invitedId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3InviteJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3InviteJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteJoinGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3InviteJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3InviteJoinGroupRes

@implementation PB3InviteJoinGroupRes


typedef struct PB3InviteJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3InviteJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3InviteJoinGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3InviteJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ImmediateJoinGroupReq

@implementation PB3ImmediateJoinGroupReq

@dynamic groupId;

typedef struct PB3ImmediateJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB3ImmediateJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB3ImmediateJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ImmediateJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImmediateJoinGroupReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ImmediateJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ImmediateJoinGroupRes

@implementation PB3ImmediateJoinGroupRes


typedef struct PB3ImmediateJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ImmediateJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ImmediateJoinGroupRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ImmediateJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsCheckNoPass

@implementation PB3TrendsCheckNoPass

@dynamic trendsId;

typedef struct PB3TrendsCheckNoPass__storage_ {
  uint32_t _has_storage_[1];
  int64_t trendsId;
} PB3TrendsCheckNoPass__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCheckNoPass_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsCheckNoPass__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsCheckNoPass class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsCheckNoPass__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ContentSensitiveCheck

@implementation PB3ContentSensitiveCheck

@dynamic toastText;
@dynamic checkedContent;

typedef struct PB3ContentSensitiveCheck__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  NSString *checkedContent;
} PB3ContentSensitiveCheck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB3ContentSensitiveCheck_FieldNumber_ToastText,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ContentSensitiveCheck__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkedContent",
        .dataTypeSpecific.className = NULL,
        .number = PB3ContentSensitiveCheck_FieldNumber_CheckedContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ContentSensitiveCheck__storage_, checkedContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ContentSensitiveCheck class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ContentSensitiveCheck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsCheckResult

@implementation PB3TrendsCheckResult

@dynamic trendsId;
@dynamic pass;

typedef struct PB3TrendsCheckResult__storage_ {
  uint32_t _has_storage_[1];
  int64_t trendsId;
} PB3TrendsCheckResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCheckResult_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsCheckResult__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCheckResult_FieldNumber_Pass,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsCheckResult class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsCheckResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsCommentCheckResult

@implementation PB3TrendsCommentCheckResult

@dynamic trendsId;
@dynamic commentId;
@dynamic pass;

typedef struct PB3TrendsCommentCheckResult__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int64_t trendsId;
} PB3TrendsCommentCheckResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentCheckResult_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsCommentCheckResult__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentCheckResult_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendsCommentCheckResult__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsCommentCheckResult_FieldNumber_Pass,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsCommentCheckResult class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsCommentCheckResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityFocusFriendReq

@implementation PB3CommunityFocusFriendReq


typedef struct PB3CommunityFocusFriendReq__storage_ {
  uint32_t _has_storage_[1];
} PB3CommunityFocusFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityFocusFriendReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3CommunityFocusFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3CommunityFocusFriendRes

@implementation PB3CommunityFocusFriendRes

@dynamic num;
@dynamic route;

typedef struct PB3CommunityFocusFriendRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  NSString *route;
} PB3CommunityFocusFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityFocusFriendRes_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3CommunityFocusFriendRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB3CommunityFocusFriendRes_FieldNumber_Route,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3CommunityFocusFriendRes__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3CommunityFocusFriendRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3CommunityFocusFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClearFocusFriendReq

@implementation PB3ClearFocusFriendReq


typedef struct PB3ClearFocusFriendReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ClearFocusFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearFocusFriendReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClearFocusFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ClearFocusFriendRes

@implementation PB3ClearFocusFriendRes


typedef struct PB3ClearFocusFriendRes__storage_ {
  uint32_t _has_storage_[1];
} PB3ClearFocusFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ClearFocusFriendRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ClearFocusFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ViolationPictureExampleReq

@implementation PB3ViolationPictureExampleReq


typedef struct PB3ViolationPictureExampleReq__storage_ {
  uint32_t _has_storage_[1];
} PB3ViolationPictureExampleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ViolationPictureExampleReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3ViolationPictureExampleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ViolationInfo

@implementation PB3ViolationInfo

@dynamic URL;
@dynamic content;

typedef struct PB3ViolationInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *content;
} PB3ViolationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB3ViolationInfo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ViolationInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB3ViolationInfo_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ViolationInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ViolationInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ViolationInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3ViolationPictureExampleRes

@implementation PB3ViolationPictureExampleRes

@dynamic title;
@dynamic listArray, listArray_Count;
@dynamic remark;

typedef struct PB3ViolationPictureExampleRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSMutableArray *listArray;
  NSString *remark;
} PB3ViolationPictureExampleRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB3ViolationPictureExampleRes_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3ViolationPictureExampleRes__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3ViolationInfo),
        .number = PB3ViolationPictureExampleRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3ViolationPictureExampleRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB3ViolationPictureExampleRes_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3ViolationPictureExampleRes__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3ViolationPictureExampleRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3ViolationPictureExampleRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendTagInfoReq

@implementation PB3TrendTagInfoReq

@dynamic id_p;

typedef struct PB3TrendTagInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB3TrendTagInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendTagInfoReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendTagInfoReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendTagInfoReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendTagInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendTagInfoRes

@implementation PB3TrendTagInfoRes

@dynamic hasTag, tag;

typedef struct PB3TrendTagInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB3TrendTag *tag;
} PB3TrendTagInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendTag),
        .number = PB3TrendTagInfoRes_FieldNumber_Tag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendTagInfoRes__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendTagInfoRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendTagInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SkillInteractionInfoReq

@implementation PB3SkillInteractionInfoReq


typedef struct PB3SkillInteractionInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB3SkillInteractionInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SkillInteractionInfoReq class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB3SkillInteractionInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3SkillInteractionInfoRes

@implementation PB3SkillInteractionInfoRes

@dynamic skillListArray, skillListArray_Count;
@dynamic interactionListArray, interactionListArray_Count;

typedef struct PB3SkillInteractionInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *skillListArray;
  NSMutableArray *interactionListArray;
} PB3SkillInteractionInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendsSkillInfo),
        .number = PB3SkillInteractionInfoRes_FieldNumber_SkillListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SkillInteractionInfoRes__storage_, skillListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interactionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB3TrendsInteractionInfo),
        .number = PB3SkillInteractionInfoRes_FieldNumber_InteractionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB3SkillInteractionInfoRes__storage_, interactionListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3SkillInteractionInfoRes class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3SkillInteractionInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsSkillInfo

@implementation PB3TrendsSkillInfo

@dynamic skillId;
@dynamic skillName;
@dynamic icon;

typedef struct PB3TrendsSkillInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *skillName;
  NSString *icon;
  int64_t skillId;
} PB3TrendsSkillInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsSkillInfo_FieldNumber_SkillId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsSkillInfo__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "skillName",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsSkillInfo_FieldNumber_SkillName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendsSkillInfo__storage_, skillName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsSkillInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TrendsSkillInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsSkillInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsSkillInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3TrendsInteractionInfo

@implementation PB3TrendsInteractionInfo

@dynamic interactionId;
@dynamic interactionName;
@dynamic icon;

typedef struct PB3TrendsInteractionInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *interactionName;
  NSString *icon;
  int64_t interactionId;
} PB3TrendsInteractionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interactionId",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsInteractionInfo_FieldNumber_InteractionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3TrendsInteractionInfo__storage_, interactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interactionName",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsInteractionInfo_FieldNumber_InteractionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3TrendsInteractionInfo__storage_, interactionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB3TrendsInteractionInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3TrendsInteractionInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3TrendsInteractionInfo class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3TrendsInteractionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB3PluginEffect

@implementation PB3PluginEffect

@dynamic id_p;
@dynamic flag;
@dynamic str;
@dynamic timeType;
@dynamic endTime;
@dynamic isUse;
@dynamic effectDecOwn;
@dynamic isAllow;
@dynamic effectDecReview;
@dynamic decCreateAt;
@dynamic protectSecond;
@dynamic protectStartAt;
@dynamic endTimeNew;
@dynamic effectType;
@dynamic effectSubType;
@dynamic counter;

typedef struct PB3PluginEffect__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t flag;
  PB3PluginEffectTimeType timeType;
  int32_t endTime;
  int32_t isAllow;
  int32_t protectSecond;
  int32_t effectType;
  int32_t effectSubType;
  int32_t counter;
  NSString *str;
  NSString *effectDecOwn;
  NSString *effectDecReview;
  int64_t decCreateAt;
  int64_t protectStartAt;
  int64_t endTimeNew;
} PB3PluginEffect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_Flag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "str",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_Str,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, str),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeType",
        .dataTypeSpecific.enumDescFunc = PB3PluginEffectTimeType_EnumDescriptor,
        .number = PB3PluginEffect_FieldNumber_TimeType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, timeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EndTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isUse",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_IsUse,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "effectDecOwn",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EffectDecOwn,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, effectDecOwn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAllow",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_IsAllow,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, isAllow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectDecReview",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EffectDecReview,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, effectDecReview),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "decCreateAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_DecCreateAt,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, decCreateAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "protectSecond",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_ProtectSecond,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, protectSecond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "protectStartAt",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_ProtectStartAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, protectStartAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTimeNew",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EndTimeNew,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, endTimeNew),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectType",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EffectType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, effectType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "effectSubType",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_EffectSubType,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, effectSubType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "counter",
        .dataTypeSpecific.className = NULL,
        .number = PB3PluginEffect_FieldNumber_Counter,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB3PluginEffect__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB3PluginEffect class]
                                     rootClass:[PB3CommunityExtRoot class]
                                          file:PB3CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB3PluginEffect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB3PluginEffect_TimeType_RawValue(PB3PluginEffect *message) {
  GPBDescriptor *descriptor = [PB3PluginEffect descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PluginEffect_FieldNumber_TimeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB3PluginEffect_TimeType_RawValue(PB3PluginEffect *message, int32_t value) {
  GPBDescriptor *descriptor = [PB3PluginEffect descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB3PluginEffect_FieldNumber_TimeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
