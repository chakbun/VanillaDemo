// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plugin_pb/community.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "plugin_pb/CommunityExt.pbobjc.h"
#import "plugin_pb/PluginExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB4CommunityExtRoot

@implementation PB4CommunityExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB4CommunityExtRoot_FileDescriptor

static GPBFileDescriptor *PB4CommunityExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"plugin_pb"
                                                 objcPrefix:@"PB4"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB4CommunityCmdId

GPBEnumDescriptor *PB4CommunityCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcCommunityZero\000IcCommunity\000IcCommunityG"
        "roupLimit\000IcPlayerGroupList\000IcGroupApply"
        "\000IcTrendsCheckNoPass\000IcTrendsCheckResult"
        "\000IcTrendsCommentCheckResult\000IcTrendsComm"
        "emtMsg\000IcTrendsLikeMsg\000";
    static const int32_t values[] = {
        PB4CommunityCmdId_IcCommunityZero,
        PB4CommunityCmdId_IcCommunity,
        PB4CommunityCmdId_IcCommunityGroupLimit,
        PB4CommunityCmdId_IcPlayerGroupList,
        PB4CommunityCmdId_IcGroupApply,
        PB4CommunityCmdId_IcTrendsCheckNoPass,
        PB4CommunityCmdId_IcTrendsCheckResult,
        PB4CommunityCmdId_IcTrendsCommentCheckResult,
        PB4CommunityCmdId_IcTrendsCommemtMsg,
        PB4CommunityCmdId_IcTrendsLikeMsg,
    };
    static const char *extraTextFormatInfo = "\n\000b\215\000\001b\211\000\002b\223\000\003b\217\000\004b\212\000\005b\221\000\006b\221\000\007b\230\000\010b\220\000\tb\215\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityCmdId_IcCommunityZero:
    case PB4CommunityCmdId_IcCommunity:
    case PB4CommunityCmdId_IcCommunityGroupLimit:
    case PB4CommunityCmdId_IcPlayerGroupList:
    case PB4CommunityCmdId_IcGroupApply:
    case PB4CommunityCmdId_IcTrendsCheckNoPass:
    case PB4CommunityCmdId_IcTrendsCheckResult:
    case PB4CommunityCmdId_IcTrendsCommentCheckResult:
    case PB4CommunityCmdId_IcTrendsCommemtMsg:
    case PB4CommunityCmdId_IcTrendsLikeMsg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityNavStyle

GPBEnumDescriptor *PB4CommunityNavStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CnsNone\000";
    static const int32_t values[] = {
        PB4CommunityNavStyle_CnsNone,
    };
    static const char *extraTextFormatInfo = "\001\000c\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityNavStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityNavStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityNavStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityNavStyle_CnsNone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityModuleType

GPBEnumDescriptor *PB4CommunityModuleType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmtNone\000CmtGroupMy\000CmtGroupCollection\000Cm"
        "tGroupHistory\000CmtGroupHot\000CmtGroupRecomm"
        "end\000CmtGroupDefine\000CmtTrendMy\000CmtTrendFo"
        "cus\000CmtTrendNew\000CmtTrendRecommend\000CmtTre"
        "ndHot\000CmtTrendDefine\000CmtTagAdmin\000CmtTagD"
        "efine\000";
    static const int32_t values[] = {
        PB4CommunityModuleType_CmtNone,
        PB4CommunityModuleType_CmtGroupMy,
        PB4CommunityModuleType_CmtGroupCollection,
        PB4CommunityModuleType_CmtGroupHistory,
        PB4CommunityModuleType_CmtGroupHot,
        PB4CommunityModuleType_CmtGroupRecommend,
        PB4CommunityModuleType_CmtGroupDefine,
        PB4CommunityModuleType_CmtTrendMy,
        PB4CommunityModuleType_CmtTrendFocus,
        PB4CommunityModuleType_CmtTrendNew,
        PB4CommunityModuleType_CmtTrendRecommend,
        PB4CommunityModuleType_CmtTrendHot,
        PB4CommunityModuleType_CmtTrendDefine,
        PB4CommunityModuleType_CmtTagAdmin,
        PB4CommunityModuleType_CmtTagDefine,
    };
    static const char *extraTextFormatInfo = "\017\000c\204\000\001c\205\202\000\002c\205\212\000\003c\205\207\000\004c\205\203\000\005c\205\211\000\006c\205\206\000\007c\205\202\000\010c\205\205\000\tc\205\203\000\nc\205\211\000\013c\205\203\000\014c\205\206\000\rc\203\205\000\016c\203\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityModuleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityModuleType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityModuleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityModuleType_CmtNone:
    case PB4CommunityModuleType_CmtGroupMy:
    case PB4CommunityModuleType_CmtGroupCollection:
    case PB4CommunityModuleType_CmtGroupHistory:
    case PB4CommunityModuleType_CmtGroupHot:
    case PB4CommunityModuleType_CmtGroupRecommend:
    case PB4CommunityModuleType_CmtGroupDefine:
    case PB4CommunityModuleType_CmtTrendMy:
    case PB4CommunityModuleType_CmtTrendFocus:
    case PB4CommunityModuleType_CmtTrendNew:
    case PB4CommunityModuleType_CmtTrendRecommend:
    case PB4CommunityModuleType_CmtTrendHot:
    case PB4CommunityModuleType_CmtTrendDefine:
    case PB4CommunityModuleType_CmtTagAdmin:
    case PB4CommunityModuleType_CmtTagDefine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityRightRule

GPBEnumDescriptor *PB4CommunityRightRule_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CrrNone\000CrrRefresh\000CrrRoute\000CrrClean\000Crr"
        "NextPage\000CrrText\000";
    static const int32_t values[] = {
        PB4CommunityRightRule_CrrNone,
        PB4CommunityRightRule_CrrRefresh,
        PB4CommunityRightRule_CrrRoute,
        PB4CommunityRightRule_CrrClean,
        PB4CommunityRightRule_CrrNextPage,
        PB4CommunityRightRule_CrrText,
    };
    static const char *extraTextFormatInfo = "\006\000c\204\000\001c\207\000\002c\205\000\003c\205\000\004c\210\000\005c\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityRightRule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityRightRule_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityRightRule_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityRightRule_CrrNone:
    case PB4CommunityRightRule_CrrRefresh:
    case PB4CommunityRightRule_CrrRoute:
    case PB4CommunityRightRule_CrrClean:
    case PB4CommunityRightRule_CrrNextPage:
    case PB4CommunityRightRule_CrrText:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityClanIconType

GPBEnumDescriptor *PB4CommunityClanIconType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CcitNormal\000CcitRely\000CcitBill\000";
    static const int32_t values[] = {
        PB4CommunityClanIconType_CcitNormal,
        PB4CommunityClanIconType_CcitRely,
        PB4CommunityClanIconType_CcitBill,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityClanIconType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityClanIconType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityClanIconType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityClanIconType_CcitNormal:
    case PB4CommunityClanIconType_CcitRely:
    case PB4CommunityClanIconType_CcitBill:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityGroupStatus

GPBEnumDescriptor *PB4CommunityGroupStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CgsNone\000CgsApplicable\000CgsApplying\000CgsAdd"
        "ed\000CgsOwner\000";
    static const int32_t values[] = {
        PB4CommunityGroupStatus_CgsNone,
        PB4CommunityGroupStatus_CgsApplicable,
        PB4CommunityGroupStatus_CgsApplying,
        PB4CommunityGroupStatus_CgsAdded,
        PB4CommunityGroupStatus_CgsOwner,
    };
    static const char *extraTextFormatInfo = "\005\000c\204\000\001c\212\000\002c\210\000\003c\205\000\004c\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityGroupStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityGroupStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityGroupStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityGroupStatus_CgsNone:
    case PB4CommunityGroupStatus_CgsApplicable:
    case PB4CommunityGroupStatus_CgsApplying:
    case PB4CommunityGroupStatus_CgsAdded:
    case PB4CommunityGroupStatus_CgsOwner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4TrendTagStyle

GPBEnumDescriptor *PB4TrendTagStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TrendTagStyleNone\000TrendTagStyleImg\000";
    static const int32_t values[] = {
        PB4TrendTagStyle_TrendTagStyleNone,
        PB4TrendTagStyle_TrendTagStyleImg,
    };
    static const char *extraTextFormatInfo = "\002\000\r\204\000\001\r\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4TrendTagStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4TrendTagStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4TrendTagStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4TrendTagStyle_TrendTagStyleNone:
    case PB4TrendTagStyle_TrendTagStyleImg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4MediaType

GPBEnumDescriptor *PB4MediaType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MediaTypeNone\000MediaTypePng\000MediaTypeGif\000"
        "MediaTypeVideo\000MediaTypeAudio\000";
    static const int32_t values[] = {
        PB4MediaType_MediaTypeNone,
        PB4MediaType_MediaTypePng,
        PB4MediaType_MediaTypeGif,
        PB4MediaType_MediaTypeVideo,
        PB4MediaType_MediaTypeAudio,
    };
    static const char *extraTextFormatInfo = "\005\000\t\204\000\001\t\203\000\002\t\203\000\003\t\205\000\004\t\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4MediaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4MediaType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4MediaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4MediaType_MediaTypeNone:
    case PB4MediaType_MediaTypePng:
    case PB4MediaType_MediaTypeGif:
    case PB4MediaType_MediaTypeVideo:
    case PB4MediaType_MediaTypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4ContentType

GPBEnumDescriptor *PB4ContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentTypeNone\000ContentTypeText\000ContentT"
        "ypePictureText\000ContentTypeVideo\000ContentT"
        "ypeAudio\000ContentTypeGame\000";
    static const int32_t values[] = {
        PB4ContentType_ContentTypeNone,
        PB4ContentType_ContentTypeText,
        PB4ContentType_ContentTypePictureText,
        PB4ContentType_ContentTypeVideo,
        PB4ContentType_ContentTypeAudio,
        PB4ContentType_ContentTypeGame,
    };
    static const char *extraTextFormatInfo = "\006\000\013\204\000\001\013\204\000\002\013\213\000\003\013\205\000\004\013\205\000\005\013\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4ContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4ContentType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4ContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4ContentType_ContentTypeNone:
    case PB4ContentType_ContentTypeText:
    case PB4ContentType_ContentTypePictureText:
    case PB4ContentType_ContentTypeVideo:
    case PB4ContentType_ContentTypeAudio:
    case PB4ContentType_ContentTypeGame:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PublishGroupType

GPBEnumDescriptor *PB4PublishGroupType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PublicGroupTypeNone\000PublicGroupTypePubli"
        "c\000PublicGroupTypeSelect\000";
    static const int32_t values[] = {
        PB4PublishGroupType_PublicGroupTypeNone,
        PB4PublishGroupType_PublicGroupTypePublic,
        PB4PublishGroupType_PublicGroupTypeSelect,
    };
    static const char *extraTextFormatInfo = "\003\000\017\204\000\001\017\206\000\002\017\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PublishGroupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PublishGroupType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PublishGroupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PublishGroupType_PublicGroupTypeNone:
    case PB4PublishGroupType_PublicGroupTypePublic:
    case PB4PublishGroupType_PublicGroupTypeSelect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4TrendsOperType

GPBEnumDescriptor *PB4TrendsOperType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TrendsOperTypeNone\000TrendsOperTypeLike\000Tr"
        "endsOperTypeUnlike\000TrendsOperTypeComment"
        "\000TrendsOperTypeDelComment\000TrendsOperType"
        "DelTrends\000TrendsOperTypeShare\000TrendsOper"
        "TypeLikeVideo\000TrendsOperTypeUnlikeVideo\000"
        "TrendsOperTypeCommentLike\000TrendsOperType"
        "CommentUnlike\000";
    static const int32_t values[] = {
        PB4TrendsOperType_TrendsOperTypeNone,
        PB4TrendsOperType_TrendsOperTypeLike,
        PB4TrendsOperType_TrendsOperTypeUnlike,
        PB4TrendsOperType_TrendsOperTypeComment,
        PB4TrendsOperType_TrendsOperTypeDelComment,
        PB4TrendsOperType_TrendsOperTypeDelTrends,
        PB4TrendsOperType_TrendsOperTypeShare,
        PB4TrendsOperType_TrendsOperTypeLikeVideo,
        PB4TrendsOperType_TrendsOperTypeUnlikeVideo,
        PB4TrendsOperType_TrendsOperTypeCommentLike,
        PB4TrendsOperType_TrendsOperTypeCommentUnlike,
    };
    static const char *extraTextFormatInfo = "\013\000\016\204\000\001\016\204\000\002\016\206\000\003\016\207\000\004\016\212\000\005\016\211\000\006\016\205\000\007\016\204\205\000\010\016\206\205\000\t\016\207\204\000\n\016\207\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4TrendsOperType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4TrendsOperType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4TrendsOperType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4TrendsOperType_TrendsOperTypeNone:
    case PB4TrendsOperType_TrendsOperTypeLike:
    case PB4TrendsOperType_TrendsOperTypeUnlike:
    case PB4TrendsOperType_TrendsOperTypeComment:
    case PB4TrendsOperType_TrendsOperTypeDelComment:
    case PB4TrendsOperType_TrendsOperTypeDelTrends:
    case PB4TrendsOperType_TrendsOperTypeShare:
    case PB4TrendsOperType_TrendsOperTypeLikeVideo:
    case PB4TrendsOperType_TrendsOperTypeUnlikeVideo:
    case PB4TrendsOperType_TrendsOperTypeCommentLike:
    case PB4TrendsOperType_TrendsOperTypeCommentUnlike:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityTrendsCommentsOrderType

GPBEnumDescriptor *PB4CommunityTrendsCommentsOrderType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "OrderHots\000OrderTime\000";
    static const int32_t values[] = {
        PB4CommunityTrendsCommentsOrderType_OrderHots,
        PB4CommunityTrendsCommentsOrderType_OrderTime,
    };
    static const char *extraTextFormatInfo = "\002\000\005\204\000\001\005\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityTrendsCommentsOrderType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityTrendsCommentsOrderType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityTrendsCommentsOrderType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityTrendsCommentsOrderType_OrderHots:
    case PB4CommunityTrendsCommentsOrderType_OrderTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityMsgShowType

GPBEnumDescriptor *PB4CommunityMsgShowType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmsgShowTypeNone\000CmsgShowTypeLike\000CmsgSh"
        "owTypeComments\000CmsgShowTypeSystem\000CmsgSh"
        "owTypeFollow\000CmsgShowTypeTrendAll\000";
    static const int32_t values[] = {
        PB4CommunityMsgShowType_CmsgShowTypeNone,
        PB4CommunityMsgShowType_CmsgShowTypeLike,
        PB4CommunityMsgShowType_CmsgShowTypeComments,
        PB4CommunityMsgShowType_CmsgShowTypeSystem,
        PB4CommunityMsgShowType_CmsgShowTypeFollow,
        PB4CommunityMsgShowType_CmsgShowTypeTrendAll,
    };
    static const char *extraTextFormatInfo = "\006\000b\n\204\000\001b\n\204\000\002b\n\210\000\003b\n\206\000\004b\n\206\000\005b\n\205\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityMsgShowType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityMsgShowType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityMsgShowType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityMsgShowType_CmsgShowTypeNone:
    case PB4CommunityMsgShowType_CmsgShowTypeLike:
    case PB4CommunityMsgShowType_CmsgShowTypeComments:
    case PB4CommunityMsgShowType_CmsgShowTypeSystem:
    case PB4CommunityMsgShowType_CmsgShowTypeFollow:
    case PB4CommunityMsgShowType_CmsgShowTypeTrendAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4CommunityPlayerMsgType

GPBEnumDescriptor *PB4CommunityPlayerMsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmsgTypeNone\000CmsgTypeLike\000CmsgTypeUnLike"
        "\000CmsgTypeShare\000CmsgTypeComments\000CmsgType"
        "UnComments\000CmsgTypeReplyComments\000CmsgTyp"
        "eDel\000CmsgTypeAtPlayer\000CmsgTypeFocusMe\000Cm"
        "sgTypeLikeComment\000CmsgTypeUnLikeeComment"
        "\000";
    static const int32_t values[] = {
        PB4CommunityPlayerMsgType_CmsgTypeNone,
        PB4CommunityPlayerMsgType_CmsgTypeLike,
        PB4CommunityPlayerMsgType_CmsgTypeUnLike,
        PB4CommunityPlayerMsgType_CmsgTypeShare,
        PB4CommunityPlayerMsgType_CmsgTypeComments,
        PB4CommunityPlayerMsgType_CmsgTypeUnComments,
        PB4CommunityPlayerMsgType_CmsgTypeReplyComments,
        PB4CommunityPlayerMsgType_CmsgTypeDel,
        PB4CommunityPlayerMsgType_CmsgTypeAtPlayer,
        PB4CommunityPlayerMsgType_CmsgTypeFocusMe,
        PB4CommunityPlayerMsgType_CmsgTypeLikeComment,
        PB4CommunityPlayerMsgType_CmsgTypeUnLikeeComment,
    };
    static const char *extraTextFormatInfo = "\014\000b\006\204\000\001b\006\204\000\002b\006\206\000\003b\006\205\000\004b\006\210\000\005b\006\212\000\006b\006\215\000\007b\006\203\000\010b\006\210\000\tb\006\207\000\nb\006\204\207\000\013b\006\207\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4CommunityPlayerMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4CommunityPlayerMsgType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4CommunityPlayerMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4CommunityPlayerMsgType_CmsgTypeNone:
    case PB4CommunityPlayerMsgType_CmsgTypeLike:
    case PB4CommunityPlayerMsgType_CmsgTypeUnLike:
    case PB4CommunityPlayerMsgType_CmsgTypeShare:
    case PB4CommunityPlayerMsgType_CmsgTypeComments:
    case PB4CommunityPlayerMsgType_CmsgTypeUnComments:
    case PB4CommunityPlayerMsgType_CmsgTypeReplyComments:
    case PB4CommunityPlayerMsgType_CmsgTypeDel:
    case PB4CommunityPlayerMsgType_CmsgTypeAtPlayer:
    case PB4CommunityPlayerMsgType_CmsgTypeFocusMe:
    case PB4CommunityPlayerMsgType_CmsgTypeLikeComment:
    case PB4CommunityPlayerMsgType_CmsgTypeUnLikeeComment:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4AgreementOperType

GPBEnumDescriptor *PB4AgreementOperType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AgreementOperTypeNone\000AgreementOperTypeC"
        "heck\000AgreementOperTypeAgree\000";
    static const int32_t values[] = {
        PB4AgreementOperType_AgreementOperTypeNone,
        PB4AgreementOperType_AgreementOperTypeCheck,
        PB4AgreementOperType_AgreementOperTypeAgree,
    };
    static const char *extraTextFormatInfo = "\003\000\021\204\000\001\021\205\000\002\021\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4AgreementOperType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4AgreementOperType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4AgreementOperType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4AgreementOperType_AgreementOperTypeNone:
    case PB4AgreementOperType_AgreementOperTypeCheck:
    case PB4AgreementOperType_AgreementOperTypeAgree:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB4CommunityRightButton

@implementation PB4CommunityRightButton

@dynamic icon;
@dynamic text;
@dynamic rule;
@dynamic route;

typedef struct PB4CommunityRightButton__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityRightRule rule;
  NSString *icon;
  NSString *text;
  NSString *route;
} PB4CommunityRightButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityRightButton_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityRightButton__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityRightButton_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityRightButton__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rule",
        .dataTypeSpecific.enumDescFunc = PB4CommunityRightRule_EnumDescriptor,
        .number = PB4CommunityRightButton_FieldNumber_Rule,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityRightButton__storage_, rule),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityRightButton_FieldNumber_Route,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityRightButton__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityRightButton class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityRightButton__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityRightButton_Rule_RawValue(PB4CommunityRightButton *message) {
  GPBDescriptor *descriptor = [PB4CommunityRightButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityRightButton_FieldNumber_Rule];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityRightButton_Rule_RawValue(PB4CommunityRightButton *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityRightButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityRightButton_FieldNumber_Rule];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityTagList

@implementation PB4CommunityTagList

@dynamic listArray, listArray_Count;

typedef struct PB4CommunityTagList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4CommunityTagList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendTag),
        .number = PB4CommunityTagList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTagList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTagList class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTagList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupDataList

@implementation PB4CommunityGroupDataList

@dynamic listArray, listArray_Count;
@dynamic moduleType;

typedef struct PB4CommunityGroupDataList__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityModuleType moduleType;
  NSMutableArray *listArray;
} PB4CommunityGroupDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityGroupData),
        .number = PB4CommunityGroupDataList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityGroupDataList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moduleType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityModuleType_EnumDescriptor,
        .number = PB4CommunityGroupDataList_FieldNumber_ModuleType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupDataList__storage_, moduleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupDataList class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityGroupDataList_ModuleType_RawValue(PB4CommunityGroupDataList *message) {
  GPBDescriptor *descriptor = [PB4CommunityGroupDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupDataList_FieldNumber_ModuleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityGroupDataList_ModuleType_RawValue(PB4CommunityGroupDataList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityGroupDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupDataList_FieldNumber_ModuleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityGroupData

@implementation PB4CommunityGroupData

@dynamic hasGroupInfo, groupInfo;
@dynamic hasTrend, trend;
@dynamic index;

typedef struct PB4CommunityGroupData__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB4CommunityGroupInfo *groupInfo;
  PB4CommunityTrendData *trend;
} PB4CommunityGroupData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityGroupInfo),
        .number = PB4CommunityGroupData_FieldNumber_GroupInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupData__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityGroupData_FieldNumber_Trend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupData__storage_, trend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupData_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityGroupData__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupData class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4Effort

@implementation PB4Effort

@dynamic effortId;
@dynamic effortTitle;
@dynamic effortContent;
@dynamic effortIcon;

typedef struct PB4Effort__storage_ {
  uint32_t _has_storage_[1];
  NSString *effortTitle;
  NSString *effortContent;
  NSString *effortIcon;
  int64_t effortId;
} PB4Effort__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effortId",
        .dataTypeSpecific.className = NULL,
        .number = PB4Effort_FieldNumber_EffortId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4Effort__storage_, effortId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effortTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB4Effort_FieldNumber_EffortTitle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4Effort__storage_, effortTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effortContent",
        .dataTypeSpecific.className = NULL,
        .number = PB4Effort_FieldNumber_EffortContent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4Effort__storage_, effortContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effortIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4Effort_FieldNumber_EffortIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4Effort__storage_, effortIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4Effort class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4Effort__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupInfo

@implementation PB4CommunityGroupInfo

@dynamic id_p;
@dynamic icon;
@dynamic name;
@dynamic memberNum;
@dynamic trendNum;
@dynamic introduction;
@dynamic redNum;
@dynamic type;
@dynamic isAuditing;

typedef struct PB4CommunityGroupInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  int32_t redNum;
  PB4CommunityGroupType type;
  NSString *icon;
  NSString *name;
  NSString *introduction;
  int64_t id_p;
} PB4CommunityGroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_MemberNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_TrendNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "introduction",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_Introduction,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, introduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_RedNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, redNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4CommunityGroupType_EnumDescriptor,
        .number = PB4CommunityGroupInfo_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isAuditing",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfo_FieldNumber_IsAuditing,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityGroupInfo_Type_RawValue(PB4CommunityGroupInfo *message) {
  GPBDescriptor *descriptor = [PB4CommunityGroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupInfo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityGroupInfo_Type_RawValue(PB4CommunityGroupInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityGroupInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupInfo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityTrendDataList

@implementation PB4CommunityTrendDataList

@dynamic listArray, listArray_Count;
@dynamic moduleType;

typedef struct PB4CommunityTrendDataList__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityModuleType moduleType;
  NSMutableArray *listArray;
} PB4CommunityTrendDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityTrendDataList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendDataList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "moduleType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityModuleType_EnumDescriptor,
        .number = PB4CommunityTrendDataList_FieldNumber_ModuleType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendDataList__storage_, moduleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendDataList class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityTrendDataList_ModuleType_RawValue(PB4CommunityTrendDataList *message) {
  GPBDescriptor *descriptor = [PB4CommunityTrendDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendDataList_FieldNumber_ModuleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityTrendDataList_ModuleType_RawValue(PB4CommunityTrendDataList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityTrendDataList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendDataList_FieldNumber_ModuleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4AtPlayer

@implementation PB4AtPlayer

@dynamic id_p;
@dynamic name;

typedef struct PB4AtPlayer__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t id_p;
} PB4AtPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4AtPlayer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4AtPlayer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4AtPlayer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4AtPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4AtPlayer class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4AtPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendData

@implementation PB4CommunityTrendData

@dynamic id_p;
@dynamic hasPublisher, publisher;
@dynamic content;
@dynamic likeNum;
@dynamic commentNum;
@dynamic tagsArray, tagsArray_Count;
@dynamic publishAt;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic isGaveLike;
@dynamic index;
@dynamic groupsArray, groupsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic top;
@dynamic skillId;
@dynamic iaId;
@dynamic activityId;
@dynamic authInfoListArray, authInfoListArray_Count;
@dynamic tagURL;
@dynamic playNum;
@dynamic hasGame, game;
@dynamic isLike;
@dynamic hasComments, comments;
@dynamic ago;
@dynamic hasEffort, effort;

typedef struct PB4CommunityTrendData__storage_ {
  uint32_t _has_storage_[1];
  int32_t likeNum;
  int32_t commentNum;
  int32_t index;
  int32_t skillId;
  int32_t iaId;
  int32_t activityId;
  int32_t playNum;
  PB4Publisher *publisher;
  NSString *content;
  NSMutableArray *tagsArray;
  NSMutableArray *mediaUrlsArray;
  NSMutableArray *groupsArray;
  NSMutableArray *atPlayerArray;
  NSMutableArray *authInfoListArray;
  NSString *tagURL;
  PB4TrendGameInfo *game;
  PB4TrendsComment *comments;
  NSString *ago;
  PB4Effort *effort;
  int64_t id_p;
  int64_t publishAt;
  int64_t top;
} PB4CommunityTrendData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "publisher",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Publisher),
        .number = PB4CommunityTrendData_FieldNumber_Publisher,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, publisher),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_LikeNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_CommentNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendTag),
        .number = PB4CommunityTrendData_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publishAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_PublishAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, publishAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MediaResource),
        .number = PB4CommunityTrendData_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isGaveLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_IsGaveLike,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_Index,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4GroupInfoSimple),
        .number = PB4CommunityTrendData_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4AtPlayer),
        .number = PB4CommunityTrendData_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "top",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_Top,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, top),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_SkillId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "iaId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_IaId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, iaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activityId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_ActivityId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, activityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PAuthInfo),
        .number = PB4CommunityTrendData_FieldNumber_AuthInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, authInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_TagURL,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, tagURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_PlayNum,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, playNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendGameInfo),
        .number = PB4CommunityTrendData_FieldNumber_Game,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_IsLike,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "comments",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsComment),
        .number = PB4CommunityTrendData_FieldNumber_Comments,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, comments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ago",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendData_FieldNumber_Ago,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, ago),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effort",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Effort),
        .number = PB4CommunityTrendData_FieldNumber_Effort,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB4CommunityTrendData__storage_, effort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendData class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\022\003\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendGameInfo

@implementation PB4TrendGameInfo

@dynamic gameIcon;
@dynamic gameName;
@dynamic gameMsg;
@dynamic gameId;
@dynamic screenDirection;

typedef struct PB4TrendGameInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t screenDirection;
  NSString *gameIcon;
  NSString *gameName;
  NSString *gameMsg;
  int64_t gameId;
} PB4TrendGameInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendGameInfo_FieldNumber_GameIcon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendGameInfo__storage_, gameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendGameInfo_FieldNumber_GameName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendGameInfo__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendGameInfo_FieldNumber_GameMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendGameInfo__storage_, gameMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendGameInfo_FieldNumber_GameId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4TrendGameInfo__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "screenDirection",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendGameInfo_FieldNumber_ScreenDirection,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4TrendGameInfo__storage_, screenDirection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendGameInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendGameInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4Publisher

@implementation PB4Publisher

@dynamic id_p;
@dynamic id2;
@dynamic sex;
@dynamic name;
@dynamic icon;
@dynamic roomId;
@dynamic isBillPlayer;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic signature;
@dynamic hasClan, clan;
@dynamic playerLabelArray, playerLabelArray_Count;

typedef struct PB4Publisher__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  int32_t wealthLevel;
  int32_t charmLevel;
  NSString *name;
  NSString *icon;
  NSString *signature;
  PB4CommunityClanInfo *clan;
  NSMutableArray *playerLabelArray;
  int64_t id_p;
  int64_t id2;
  int64_t roomId;
} PB4Publisher__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_RoomId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isBillPlayer",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_IsBillPlayer,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_WealthLevel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_CharmLevel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB4Publisher_FieldNumber_Signature,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityClanInfo),
        .number = PB4Publisher_FieldNumber_Clan,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, clan),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerLabelArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PlayerLabel),
        .number = PB4Publisher_FieldNumber_PlayerLabelArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4Publisher__storage_, playerLabelArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4Publisher class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4Publisher__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PlayerLabel

@implementation PB4PlayerLabel

@dynamic labelIcon;
@dynamic labelWord;
@dynamic dialogImg;

typedef struct PB4PlayerLabel__storage_ {
  uint32_t _has_storage_[1];
  NSString *labelIcon;
  NSString *labelWord;
  NSString *dialogImg;
} PB4PlayerLabel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PlayerLabel_FieldNumber_LabelIcon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PlayerLabel__storage_, labelIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelWord",
        .dataTypeSpecific.className = NULL,
        .number = PB4PlayerLabel_FieldNumber_LabelWord,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PlayerLabel__storage_, labelWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialogImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PlayerLabel_FieldNumber_DialogImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PlayerLabel__storage_, dialogImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PlayerLabel class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PlayerLabel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupTrendList

@implementation PB4CommunityGroupTrendList

@dynamic listArray, listArray_Count;
@dynamic hasGroupInfo, groupInfo;
@dynamic collection;
@dynamic status;
@dynamic applyingNum;

typedef struct PB4CommunityGroupTrendList__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityGroupStatus status;
  int32_t applyingNum;
  NSMutableArray *listArray;
  PB4CommunityGroupInfo *groupInfo;
} PB4CommunityGroupTrendList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityGroupTrendList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityGroupTrendList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityGroupInfo),
        .number = PB4CommunityGroupTrendList_FieldNumber_GroupInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupTrendList__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "collection",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupTrendList_FieldNumber_Collection,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB4CommunityGroupStatus_EnumDescriptor,
        .number = PB4CommunityGroupTrendList_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityGroupTrendList__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "applyingNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupTrendList_FieldNumber_ApplyingNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityGroupTrendList__storage_, applyingNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupTrendList class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupTrendList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityGroupTrendList_Status_RawValue(PB4CommunityGroupTrendList *message) {
  GPBDescriptor *descriptor = [PB4CommunityGroupTrendList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupTrendList_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityGroupTrendList_Status_RawValue(PB4CommunityGroupTrendList *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityGroupTrendList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupTrendList_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4TrendTag

@implementation PB4TrendTag

@dynamic id_p;
@dynamic name;
@dynamic index;
@dynamic icon;
@dynamic hot;
@dynamic comment;
@dynamic URL;
@dynamic buttonText;
@dynamic styleId;

typedef struct PB4TrendTag__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB4TrendTagStyle styleId;
  NSString *name;
  NSString *icon;
  NSString *comment;
  NSString *URL;
  NSString *buttonText;
  int64_t id_p;
  int64_t hot;
} PB4TrendTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hot",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Hot,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, hot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_Comment,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buttonText",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTag_FieldNumber_ButtonText,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, buttonText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "styleId",
        .dataTypeSpecific.enumDescFunc = PB4TrendTagStyle_EnumDescriptor,
        .number = PB4TrendTag_FieldNumber_StyleId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4TrendTag__storage_, styleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendTag class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4TrendTag_StyleId_RawValue(PB4TrendTag *message) {
  GPBDescriptor *descriptor = [PB4TrendTag descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4TrendTag_FieldNumber_StyleId];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4TrendTag_StyleId_RawValue(PB4TrendTag *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4TrendTag descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4TrendTag_FieldNumber_StyleId];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPlayerInfo

@implementation PB4CommunityPlayerInfo

@dynamic id_p;
@dynamic id2;
@dynamic nickName;
@dynamic icon;
@dynamic sex;
@dynamic hasClan, clan;
@dynamic playerLabelArray, playerLabelArray_Count;

typedef struct PB4CommunityPlayerInfo__storage_ {
  uint32_t _has_storage_[1];
  PB4PluginSexType sex;
  NSString *nickName;
  NSString *icon;
  PB4CommunityClanInfo *clan;
  NSMutableArray *playerLabelArray;
  int64_t id_p;
  int64_t id2;
} PB4CommunityPlayerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerInfo_FieldNumber_Id2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerInfo_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerInfo_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4CommunityPlayerInfo_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityClanInfo),
        .number = PB4CommunityPlayerInfo_FieldNumber_Clan,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, clan),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerLabelArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PlayerLabel),
        .number = PB4CommunityPlayerInfo_FieldNumber_PlayerLabelArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerInfo__storage_, playerLabelArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPlayerInfo_Sex_RawValue(PB4CommunityPlayerInfo *message) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPlayerInfo_Sex_RawValue(PB4CommunityPlayerInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4MediaResource

@implementation PB4MediaResource

@dynamic mediaType;
@dynamic mediaURL;
@dynamic coverURL;
@dynamic mediaWidth;
@dynamic mediaHeight;
@dynamic mediaSecond;
@dynamic videoURL;
@dynamic audioURL;
@dynamic videoId;
@dynamic transVideoURL;
@dynamic transCoverURL;
@dynamic trendId;

typedef struct PB4MediaResource__storage_ {
  uint32_t _has_storage_[1];
  PB4MediaType mediaType;
  int32_t mediaWidth;
  int32_t mediaHeight;
  int32_t mediaSecond;
  NSString *mediaURL;
  NSString *coverURL;
  NSString *videoURL;
  NSString *audioURL;
  NSString *videoId;
  NSString *transVideoURL;
  NSString *transCoverURL;
  int64_t trendId;
} PB4MediaResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaType",
        .dataTypeSpecific.enumDescFunc = PB4MediaType_EnumDescriptor,
        .number = PB4MediaResource_FieldNumber_MediaType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, mediaType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mediaURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_MediaURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, mediaURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_CoverURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaWidth",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_MediaWidth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, mediaWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mediaHeight",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_MediaHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, mediaHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mediaSecond",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_MediaSecond,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, mediaSecond),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_VideoURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, videoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "audioURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_AudioURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, audioURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_VideoId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, videoId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transVideoURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_TransVideoURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, transVideoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transCoverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_TransCoverURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, transCoverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MediaResource_FieldNumber_TrendId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4MediaResource__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MediaResource class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MediaResource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\005\241!!\000\003\005\241!!\000\007\005\241!!\000\010\005\241!!\000\n\005\245\241!!\000\013\005\245\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4MediaResource_MediaType_RawValue(PB4MediaResource *message) {
  GPBDescriptor *descriptor = [PB4MediaResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MediaResource_FieldNumber_MediaType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MediaResource_MediaType_RawValue(PB4MediaResource *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MediaResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MediaResource_FieldNumber_MediaType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4Photo

@implementation PB4Photo

@dynamic hasMedia, media;
@dynamic trendContent;
@dynamic mediaId;

typedef struct PB4Photo__storage_ {
  uint32_t _has_storage_[1];
  int32_t mediaId;
  PB4MediaResource *media;
  NSString *trendContent;
} PB4Photo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "media",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MediaResource),
        .number = PB4Photo_FieldNumber_Media,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4Photo__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trendContent",
        .dataTypeSpecific.className = NULL,
        .number = PB4Photo_FieldNumber_TrendContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4Photo__storage_, trendContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaId",
        .dataTypeSpecific.className = NULL,
        .number = PB4Photo_FieldNumber_MediaId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4Photo__storage_, mediaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4Photo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4Photo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPublishReq

@implementation PB4CommunityPublishReq

@dynamic content;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic contentType;
@dynamic tagsArray, tagsArray_Count;
@dynamic groupType;
@dynamic groupsArray, groupsArray_Count;
@dynamic atPlayerIdArray, atPlayerIdArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic skillId;
@dynamic interactionId;
@dynamic gameId;
@dynamic hasEffort, effort;

typedef struct PB4CommunityPublishReq__storage_ {
  uint32_t _has_storage_[1];
  PB4ContentType contentType;
  PB4PublishGroupType groupType;
  NSString *content;
  NSMutableArray *mediaUrlsArray;
  GPBInt64Array *tagsArray;
  GPBInt64Array *groupsArray;
  GPBInt64Array *atPlayerIdArray;
  NSMutableArray *atPlayerArray;
  PB4Effort *effort;
  int64_t skillId;
  int64_t interactionId;
  int64_t gameId;
} PB4CommunityPublishReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MediaResource),
        .number = PB4CommunityPublishReq_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.enumDescFunc = PB4ContentType_EnumDescriptor,
        .number = PB4CommunityPublishReq_FieldNumber_ContentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, tagsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupType",
        .dataTypeSpecific.enumDescFunc = PB4PublishGroupType_EnumDescriptor,
        .number = PB4CommunityPublishReq_FieldNumber_GroupType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, groupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, groupsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "atPlayerIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_AtPlayerIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, atPlayerIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4AtPlayer),
        .number = PB4CommunityPublishReq_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_SkillId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interactionId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_InteractionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, interactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishReq_FieldNumber_GameId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effort",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Effort),
        .number = PB4CommunityPublishReq_FieldNumber_Effort,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommunityPublishReq__storage_, effort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPublishReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPublishReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPublishReq_ContentType_RawValue(PB4CommunityPublishReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPublishReq_FieldNumber_ContentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPublishReq_ContentType_RawValue(PB4CommunityPublishReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPublishReq_FieldNumber_ContentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4CommunityPublishReq_GroupType_RawValue(PB4CommunityPublishReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPublishReq_FieldNumber_GroupType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPublishReq_GroupType_RawValue(PB4CommunityPublishReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPublishReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPublishReq_FieldNumber_GroupType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPublishRes

@implementation PB4CommunityPublishRes

@dynamic trendsId;
@dynamic toastText;
@dynamic createAt;

typedef struct PB4CommunityPublishRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  int64_t trendsId;
  int64_t createAt;
} PB4CommunityPublishRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishRes_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPublishRes__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishRes_FieldNumber_ToastText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPublishRes__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishRes_FieldNumber_CreateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPublishRes__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPublishRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPublishRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsOperReq

@implementation PB4CommunityTrendsOperReq

@dynamic operType;
@dynamic trendsId;
@dynamic commentId;
@dynamic comment;
@dynamic commentMediaUrlsArray, commentMediaUrlsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic recmdSource;
@dynamic recmdSourceId;
@dynamic traceInfo;

typedef struct PB4CommunityTrendsOperReq__storage_ {
  uint32_t _has_storage_[1];
  PB4TrendsOperType operType;
  int32_t commentId;
  PB4VideoRecmdSource recmdSource;
  NSString *comment;
  NSMutableArray *commentMediaUrlsArray;
  NSMutableArray *atPlayerArray;
  NSString *recmdSourceId;
  NSString *traceInfo;
  int64_t trendsId;
} PB4CommunityTrendsOperReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operType",
        .dataTypeSpecific.enumDescFunc = PB4TrendsOperType_EnumDescriptor,
        .number = PB4CommunityTrendsOperReq_FieldNumber_OperType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, operType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperReq_FieldNumber_TrendsId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperReq_FieldNumber_CommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperReq_FieldNumber_Comment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentMediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MediaResource),
        .number = PB4CommunityTrendsOperReq_FieldNumber_CommentMediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, commentMediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4AtPlayer),
        .number = PB4CommunityTrendsOperReq_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recmdSource",
        .dataTypeSpecific.enumDescFunc = PB4VideoRecmdSource_EnumDescriptor,
        .number = PB4CommunityTrendsOperReq_FieldNumber_RecmdSource,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, recmdSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recmdSourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperReq_FieldNumber_RecmdSourceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, recmdSourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperReq_FieldNumber_TraceInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperReq__storage_, traceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsOperReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsOperReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityTrendsOperReq_OperType_RawValue(PB4CommunityTrendsOperReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsOperReq_FieldNumber_OperType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityTrendsOperReq_OperType_RawValue(PB4CommunityTrendsOperReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsOperReq_FieldNumber_OperType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4CommunityTrendsOperReq_RecmdSource_RawValue(PB4CommunityTrendsOperReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsOperReq_FieldNumber_RecmdSource];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityTrendsOperReq_RecmdSource_RawValue(PB4CommunityTrendsOperReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsOperReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsOperReq_FieldNumber_RecmdSource];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityTrendsOperRes

@implementation PB4CommunityTrendsOperRes

@dynamic commentId;

typedef struct PB4CommunityTrendsOperRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
} PB4CommunityTrendsOperRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsOperRes_FieldNumber_CommentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsOperRes__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsOperRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsOperRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsListReq

@implementation PB4CommunityTrendsListReq

@dynamic playerId;
@dynamic index;

typedef struct PB4CommunityTrendsListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t playerId;
} PB4CommunityTrendsListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsListReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsListReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsListRes

@implementation PB4CommunityTrendsListRes

@dynamic listArray, listArray_Count;
@dynamic nextIndex;
@dynamic isPrivacy;
@dynamic isBlack;

typedef struct PB4CommunityTrendsListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *listArray;
} PB4CommunityTrendsListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityTrendsListRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsListRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isPrivacy",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsListRes_FieldNumber_IsPrivacy,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isBlack",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsListRes_FieldNumber_IsBlack,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsListRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityLastTrendsReq

@implementation PB4CommunityLastTrendsReq

@dynamic playerId;

typedef struct PB4CommunityLastTrendsReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB4CommunityLastTrendsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityLastTrendsReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityLastTrendsReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityLastTrendsReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityLastTrendsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityLastTrendsRes

@implementation PB4CommunityLastTrendsRes

@dynamic listArray, listArray_Count;

typedef struct PB4CommunityLastTrendsRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4CommunityLastTrendsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityLastTrendsRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityLastTrendsRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityLastTrendsRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityLastTrendsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsComment

@implementation PB4TrendsComment

@dynamic trendsId;
@dynamic trendsPlayerId;
@dynamic commentId;
@dynamic level;
@dynamic commentNum;
@dynamic detailsArray, detailsArray_Count;
@dynamic nextIndex;

typedef struct PB4TrendsComment__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t level;
  int32_t commentNum;
  int32_t nextIndex;
  NSMutableArray *detailsArray;
  int64_t trendsId;
  int64_t trendsPlayerId;
} PB4TrendsComment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendsPlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_TrendsPlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, trendsPlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_CommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_CommentNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detailsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsCommentDetail),
        .number = PB4TrendsComment_FieldNumber_DetailsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, detailsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsComment_FieldNumber_NextIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4TrendsComment__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsComment class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsComment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsCommentDetail

@implementation PB4TrendsCommentDetail

@dynamic trendsId;
@dynamic commentId;
@dynamic hasCommentPlayer, commentPlayer;
@dynamic hasToPlayer, toPlayer;
@dynamic content;
@dynamic commentTime;
@dynamic hasComments, comments;
@dynamic mediaUrlsArray, mediaUrlsArray_Count;
@dynamic atPlayerArray, atPlayerArray_Count;
@dynamic likeNum;
@dynamic isLike;
@dynamic ago;

typedef struct PB4TrendsCommentDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t likeNum;
  PB4CommunityPlayerInfo *commentPlayer;
  PB4CommunityPlayerInfo *toPlayer;
  NSString *content;
  PB4TrendsComment *comments;
  NSMutableArray *mediaUrlsArray;
  NSMutableArray *atPlayerArray;
  NSString *ago;
  int64_t trendsId;
  int64_t commentTime;
} PB4TrendsCommentDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerInfo),
        .number = PB4TrendsCommentDetail_FieldNumber_CommentPlayer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, commentPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerInfo),
        .number = PB4TrendsCommentDetail_FieldNumber_ToPlayer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, toPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_CommentTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, commentTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comments",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsComment),
        .number = PB4TrendsCommentDetail_FieldNumber_Comments,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, comments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mediaUrlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MediaResource),
        .number = PB4TrendsCommentDetail_FieldNumber_MediaUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, mediaUrlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atPlayerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4AtPlayer),
        .number = PB4TrendsCommentDetail_FieldNumber_AtPlayerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, atPlayerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_LikeNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_IsLike,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ago",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentDetail_FieldNumber_Ago,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4TrendsCommentDetail__storage_, ago),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsCommentDetail class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsCommentDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsDetailReq

@implementation PB4CommunityTrendsDetailReq

@dynamic trendsId;

typedef struct PB4CommunityTrendsDetailReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t trendsId;
} PB4CommunityTrendsDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsDetailReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsDetailReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsDetailReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsDetailRes

@implementation PB4CommunityTrendsDetailRes

@dynamic hasTrends, trends;
@dynamic likersArray, likersArray_Count;

typedef struct PB4CommunityTrendsDetailRes__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityTrendData *trends;
  NSMutableArray *likersArray;
} PB4CommunityTrendsDetailRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trends",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityTrendsDetailRes_FieldNumber_Trends,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsDetailRes__storage_, trends),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "likersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerInfo),
        .number = PB4CommunityTrendsDetailRes_FieldNumber_LikersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsDetailRes__storage_, likersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsDetailRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsDetailRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsCommentsReq

@implementation PB4CommunityTrendsCommentsReq

@dynamic trendsId;
@dynamic commentId;
@dynamic index;
@dynamic orderType;

typedef struct PB4CommunityTrendsCommentsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t index;
  PB4CommunityTrendsCommentsOrderType orderType;
  int64_t trendsId;
} PB4CommunityTrendsCommentsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsReq_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "orderType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityTrendsCommentsOrderType_EnumDescriptor,
        .number = PB4CommunityTrendsCommentsReq_FieldNumber_OrderType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsReq__storage_, orderType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsCommentsReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsCommentsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityTrendsCommentsReq_OrderType_RawValue(PB4CommunityTrendsCommentsReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsCommentsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsCommentsReq_FieldNumber_OrderType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityTrendsCommentsReq_OrderType_RawValue(PB4CommunityTrendsCommentsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityTrendsCommentsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTrendsCommentsReq_FieldNumber_OrderType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityTrendsCommentsRes

@implementation PB4CommunityTrendsCommentsRes

@dynamic hasComments, comments;
@dynamic commentNum;
@dynamic likeNum;
@dynamic isLike;

typedef struct PB4CommunityTrendsCommentsRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentNum;
  int32_t likeNum;
  PB4TrendsComment *comments;
} PB4CommunityTrendsCommentsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "comments",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsComment),
        .number = PB4CommunityTrendsCommentsRes_FieldNumber_Comments,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsRes__storage_, comments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsRes_FieldNumber_CommentNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsRes__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsRes_FieldNumber_LikeNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsCommentsRes__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsCommentsRes_FieldNumber_IsLike,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsCommentsRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsCommentsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsLikersReq

@implementation PB4CommunityTrendsLikersReq

@dynamic trendsId;
@dynamic index;

typedef struct PB4CommunityTrendsLikersReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t trendsId;
} PB4CommunityTrendsLikersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsLikersReq_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsLikersReq__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsLikersReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsLikersReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsLikersReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsLikersReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsLikersRes

@implementation PB4CommunityTrendsLikersRes

@dynamic likersArray, likersArray_Count;
@dynamic nextIndex;

typedef struct PB4CommunityTrendsLikersRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *likersArray;
} PB4CommunityTrendsLikersRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "likersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityGroupPlayerItem),
        .number = PB4CommunityTrendsLikersRes_FieldNumber_LikersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsLikersRes__storage_, likersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsLikersRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsLikersRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsLikersRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsLikersRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityClanInfo

@implementation PB4CommunityClanInfo

@dynamic id_p;
@dynamic iconWord;
@dynamic levelName;
@dynamic name;
@dynamic level;
@dynamic iconType;
@dynamic labelIcon;

typedef struct PB4CommunityClanInfo__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityClanIconType iconType;
  NSString *iconWord;
  NSString *levelName;
  NSString *name;
  NSString *labelIcon;
  int64_t id_p;
  int64_t level;
} PB4CommunityClanInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "iconWord",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_IconWord,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, iconWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levelName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_LevelName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, levelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_Level,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "iconType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityClanIconType_EnumDescriptor,
        .number = PB4CommunityClanInfo_FieldNumber_IconType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, iconType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "labelIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityClanInfo_FieldNumber_LabelIcon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommunityClanInfo__storage_, labelIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityClanInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityClanInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityClanInfo_IconType_RawValue(PB4CommunityClanInfo *message) {
  GPBDescriptor *descriptor = [PB4CommunityClanInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityClanInfo_FieldNumber_IconType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityClanInfo_IconType_RawValue(PB4CommunityClanInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityClanInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityClanInfo_FieldNumber_IconType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityCreateOrUpdateGroupReq

@implementation PB4CommunityCreateOrUpdateGroupReq

@dynamic groupId;
@dynamic groupName;
@dynamic groupImg;
@dynamic groupDescribe;

typedef struct PB4CommunityCreateOrUpdateGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
  NSString *groupImg;
  NSString *groupDescribe;
  int64_t groupId;
} PB4CommunityCreateOrUpdateGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateOrUpdateGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityCreateOrUpdateGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateOrUpdateGroupReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityCreateOrUpdateGroupReq__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateOrUpdateGroupReq_FieldNumber_GroupImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityCreateOrUpdateGroupReq__storage_, groupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateOrUpdateGroupReq_FieldNumber_GroupDescribe,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityCreateOrUpdateGroupReq__storage_, groupDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityCreateOrUpdateGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityCreateOrUpdateGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityCreateOrUpdateGroupRes

@implementation PB4CommunityCreateOrUpdateGroupRes

@dynamic groupId;

typedef struct PB4CommunityCreateOrUpdateGroupRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB4CommunityCreateOrUpdateGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateOrUpdateGroupRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityCreateOrUpdateGroupRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityCreateOrUpdateGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityCreateOrUpdateGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityJoinGroupReq

@implementation PB4CommunityJoinGroupReq

@dynamic groupId;
@dynamic applyMsg;

typedef struct PB4CommunityJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *applyMsg;
  int64_t groupId;
} PB4CommunityJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinGroupReq_FieldNumber_ApplyMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityJoinGroupReq__storage_, applyMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityJoinGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityJoinGroupRes

@implementation PB4CommunityJoinGroupRes


typedef struct PB4CommunityJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityJoinGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityJoinInfo

@implementation PB4CommunityJoinInfo

@dynamic playerId;
@dynamic groupId;
@dynamic applyAt;
@dynamic applyMsg;

typedef struct PB4CommunityJoinInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *applyMsg;
  int64_t playerId;
  int64_t groupId;
  int64_t applyAt;
} PB4CommunityJoinInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityJoinInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinInfo_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityJoinInfo__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinInfo_FieldNumber_ApplyAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityJoinInfo__storage_, applyAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "applyMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityJoinInfo_FieldNumber_ApplyMsg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityJoinInfo__storage_, applyMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityJoinInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityJoinInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityVerifyListReq

@implementation PB4CommunityVerifyListReq

@dynamic groupId;
@dynamic index;

typedef struct PB4CommunityVerifyListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t groupId;
} PB4CommunityVerifyListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityVerifyListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyListReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityVerifyListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityVerifyListReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityVerifyListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityVerifyListRes

@implementation PB4CommunityVerifyListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB4CommunityVerifyListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB4CommunityVerifyListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4VerifyItem),
        .number = PB4CommunityVerifyListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityVerifyListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityVerifyListRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityVerifyListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VerifyItem

@implementation PB4VerifyItem

@dynamic hasInfo, info;
@dynamic hasBaseInfo, baseInfo;

typedef struct PB4VerifyItem__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityJoinInfo *info;
  PB4MemberBaseInfo *baseInfo;
} PB4VerifyItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityJoinInfo),
        .number = PB4VerifyItem_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VerifyItem__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MemberBaseInfo),
        .number = PB4VerifyItem_FieldNumber_BaseInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VerifyItem__storage_, baseInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VerifyItem class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VerifyItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MemberBaseInfo

@implementation PB4MemberBaseInfo

@dynamic playerId;
@dynamic playerId2;
@dynamic sex;
@dynamic name;
@dynamic signature;
@dynamic charmLv;
@dynamic wealthLv;
@dynamic icon;
@dynamic hasClan, clan;
@dynamic playerLabelArray, playerLabelArray_Count;

typedef struct PB4MemberBaseInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  int32_t charmLv;
  int32_t wealthLv;
  NSString *name;
  NSString *signature;
  NSString *icon;
  PB4CommunityClanInfo *clan;
  NSMutableArray *playerLabelArray;
  int64_t playerId;
  int64_t playerId2;
} PB4MemberBaseInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId2",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_PlayerId2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, playerId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_Signature,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charmLv",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_CharmLv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, charmLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wealthLv",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_WealthLv,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, wealthLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4MemberBaseInfo_FieldNumber_Icon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clan",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityClanInfo),
        .number = PB4MemberBaseInfo_FieldNumber_Clan,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, clan),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playerLabelArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PlayerLabel),
        .number = PB4MemberBaseInfo_FieldNumber_PlayerLabelArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4MemberBaseInfo__storage_, playerLabelArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MemberBaseInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MemberBaseInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityVerifyJoinReq

@implementation PB4CommunityVerifyJoinReq

@dynamic groupId;
@dynamic playerId;
@dynamic opt;

typedef struct PB4CommunityVerifyJoinReq__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityGroupOpt opt;
  int64_t groupId;
  int64_t playerId;
} PB4CommunityVerifyJoinReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityVerifyJoinReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyJoinReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityVerifyJoinReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyJoinReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.enumDescFunc = PB4CommunityGroupOpt_EnumDescriptor,
        .number = PB4CommunityVerifyJoinReq_FieldNumber_Opt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityVerifyJoinReq__storage_, opt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityVerifyJoinReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityVerifyJoinReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityVerifyJoinReq_Opt_RawValue(PB4CommunityVerifyJoinReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityVerifyJoinReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityVerifyJoinReq_FieldNumber_Opt];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityVerifyJoinReq_Opt_RawValue(PB4CommunityVerifyJoinReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityVerifyJoinReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityVerifyJoinReq_FieldNumber_Opt];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityVerifyJoinRes

@implementation PB4CommunityVerifyJoinRes


typedef struct PB4CommunityVerifyJoinRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityVerifyJoinRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityVerifyJoinRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityVerifyJoinRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityStoreGroupReq

@implementation PB4CommunityStoreGroupReq

@dynamic groupId;
@dynamic opt;

typedef struct PB4CommunityStoreGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t opt;
  int64_t groupId;
} PB4CommunityStoreGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityStoreGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityStoreGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityStoreGroupReq_FieldNumber_Opt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityStoreGroupReq__storage_, opt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityStoreGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityStoreGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityStoreGroupRes

@implementation PB4CommunityStoreGroupRes


typedef struct PB4CommunityStoreGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityStoreGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityStoreGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityStoreGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupInfoReq

@implementation PB4CommunityGroupInfoReq

@dynamic groupId;

typedef struct PB4CommunityGroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB4CommunityGroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupInfoReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupInfoRes

@implementation PB4CommunityGroupInfoRes

@dynamic hasBaseDetail, baseDetail;
@dynamic memberNum;
@dynamic trendNum;
@dynamic hasOwnerInfo, ownerInfo;
@dynamic applyNum;

typedef struct PB4CommunityGroupInfoRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  int32_t applyNum;
  PB4GroupDetail *baseDetail;
  PB4MemberBaseInfo *ownerInfo;
} PB4CommunityGroupInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4GroupDetail),
        .number = PB4CommunityGroupInfoRes_FieldNumber_BaseDetail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoRes__storage_, baseDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfoRes_FieldNumber_MemberNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoRes__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfoRes_FieldNumber_TrendNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoRes__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ownerInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MemberBaseInfo),
        .number = PB4CommunityGroupInfoRes_FieldNumber_OwnerInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoRes__storage_, ownerInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupInfoRes_FieldNumber_ApplyNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityGroupInfoRes__storage_, applyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupInfoRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GroupDetail

@implementation PB4GroupDetail

@dynamic groupId;
@dynamic groupName;
@dynamic groupImg;
@dynamic groupDescribe;
@dynamic clanId;
@dynamic status;
@dynamic isStore;
@dynamic isAuditing;

typedef struct PB4GroupDetail__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityGroupStatus status;
  NSString *groupName;
  NSString *groupImg;
  NSString *groupDescribe;
  int64_t groupId;
  int64_t clanId;
} PB4GroupDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_GroupImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, groupImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupDescribe",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_GroupDescribe,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, groupDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clanId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_ClanId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, clanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB4CommunityGroupStatus_EnumDescriptor,
        .number = PB4GroupDetail_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4GroupDetail__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isStore",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_IsStore,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAuditing",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupDetail_FieldNumber_IsAuditing,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GroupDetail class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GroupDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4GroupDetail_Status_RawValue(PB4GroupDetail *message) {
  GPBDescriptor *descriptor = [PB4GroupDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GroupDetail_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GroupDetail_Status_RawValue(PB4GroupDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GroupDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GroupDetail_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityLeaveGroupReq

@implementation PB4CommunityLeaveGroupReq

@dynamic groupId;
@dynamic leavePlayerId;
@dynamic opt;

typedef struct PB4CommunityLeaveGroupReq__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityGroupLeaveOpt opt;
  int64_t groupId;
  int64_t leavePlayerId;
} PB4CommunityLeaveGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityLeaveGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityLeaveGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leavePlayerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityLeaveGroupReq_FieldNumber_LeavePlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityLeaveGroupReq__storage_, leavePlayerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "opt",
        .dataTypeSpecific.enumDescFunc = PB4CommunityGroupLeaveOpt_EnumDescriptor,
        .number = PB4CommunityLeaveGroupReq_FieldNumber_Opt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityLeaveGroupReq__storage_, opt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityLeaveGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityLeaveGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityLeaveGroupReq_Opt_RawValue(PB4CommunityLeaveGroupReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityLeaveGroupReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityLeaveGroupReq_FieldNumber_Opt];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityLeaveGroupReq_Opt_RawValue(PB4CommunityLeaveGroupReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityLeaveGroupReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityLeaveGroupReq_FieldNumber_Opt];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityLeaveGroupRes

@implementation PB4CommunityLeaveGroupRes


typedef struct PB4CommunityLeaveGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityLeaveGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityLeaveGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityLeaveGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerGroupListReq

@implementation PB4CommunityPlayerGroupListReq

@dynamic playerGroupType;
@dynamic playerId;
@dynamic index;

typedef struct PB4CommunityPlayerGroupListReq__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityPlayerGroupType playerGroupType;
  int32_t index;
  int64_t playerId;
} PB4CommunityPlayerGroupListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerGroupType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityPlayerGroupType_EnumDescriptor,
        .number = PB4CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerGroupListReq__storage_, playerGroupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerGroupListReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerGroupListReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerGroupListReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerGroupListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerGroupListReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerGroupListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPlayerGroupListReq_PlayerGroupType_RawValue(PB4CommunityPlayerGroupListReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerGroupListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPlayerGroupListReq_PlayerGroupType_RawValue(PB4CommunityPlayerGroupListReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerGroupListReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerGroupListReq_FieldNumber_PlayerGroupType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPlayerGroupListRes

@implementation PB4CommunityPlayerGroupListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB4CommunityPlayerGroupListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB4CommunityPlayerGroupListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4GroupListItem),
        .number = PB4CommunityPlayerGroupListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerGroupListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerGroupListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerGroupListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerGroupListRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerGroupListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GroupListItem

@implementation PB4GroupListItem

@dynamic hasBaseDetail, baseDetail;
@dynamic memberNum;
@dynamic trendNum;
@dynamic isOwner;

typedef struct PB4GroupListItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberNum;
  int32_t trendNum;
  PB4GroupDetail *baseDetail;
} PB4GroupListItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4GroupDetail),
        .number = PB4GroupListItem_FieldNumber_BaseDetail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GroupListItem__storage_, baseDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupListItem_FieldNumber_MemberNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GroupListItem__storage_, memberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupListItem_FieldNumber_TrendNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GroupListItem__storage_, trendNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isOwner",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupListItem_FieldNumber_IsOwner,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GroupListItem class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GroupListItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupPlayerListReq

@implementation PB4CommunityGroupPlayerListReq

@dynamic groupId;
@dynamic index;

typedef struct PB4CommunityGroupPlayerListReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int64_t groupId;
} PB4CommunityGroupPlayerListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupPlayerListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerListReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupPlayerListReq_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerListReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupPlayerListReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupPlayerListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupPlayerListRes

@implementation PB4CommunityGroupPlayerListRes

@dynamic itemArray, itemArray_Count;
@dynamic nextIndex;

typedef struct PB4CommunityGroupPlayerListRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  NSMutableArray *itemArray;
} PB4CommunityGroupPlayerListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityGroupPlayerItem),
        .number = PB4CommunityGroupPlayerListRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerListRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupPlayerListRes_FieldNumber_NextIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerListRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupPlayerListRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupPlayerListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupPlayerItem

@implementation PB4CommunityGroupPlayerItem

@dynamic hasInfo, info;
@dynamic roomId;

typedef struct PB4CommunityGroupPlayerItem__storage_ {
  uint32_t _has_storage_[1];
  PB4MemberBaseInfo *info;
  int64_t roomId;
} PB4CommunityGroupPlayerItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MemberBaseInfo),
        .number = PB4CommunityGroupPlayerItem_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerItem__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupPlayerItem_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupPlayerItem__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupPlayerItem class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupPlayerItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityCreateTagReq

@implementation PB4CommunityCreateTagReq

@dynamic tagName;

typedef struct PB4CommunityCreateTagReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *tagName;
} PB4CommunityCreateTagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityCreateTagReq_FieldNumber_TagName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityCreateTagReq__storage_, tagName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityCreateTagReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityCreateTagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityCreateTagRes

@implementation PB4CommunityCreateTagRes


typedef struct PB4CommunityCreateTagRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityCreateTagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityCreateTagRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityCreateTagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityAllTagReq

@implementation PB4CommunityAllTagReq


typedef struct PB4CommunityAllTagReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityAllTagReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityAllTagReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityAllTagReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityAllTagRes

@implementation PB4CommunityAllTagRes

@dynamic itemArray, itemArray_Count;

typedef struct PB4CommunityAllTagRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB4CommunityAllTagRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendTag),
        .number = PB4CommunityAllTagRes_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityAllTagRes__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityAllTagRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityAllTagRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgRedPointReq

@implementation PB4CommunityPlayerMsgRedPointReq


typedef struct PB4CommunityPlayerMsgRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityPlayerMsgRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgRedPointReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityPlayerMsgRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgRedPointRes

@implementation PB4CommunityPlayerMsgRedPointRes

@dynamic hasRedPoint, redPoint;

typedef struct PB4CommunityPlayerMsgRedPointRes__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityPlayerMsgRedPoint *redPoint;
} PB4CommunityPlayerMsgRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerMsgRedPoint),
        .number = PB4CommunityPlayerMsgRedPointRes_FieldNumber_RedPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgRedPointRes__storage_, redPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgRedPointRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsgRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgClearRedPointReq

@implementation PB4CommunityPlayerMsgClearRedPointReq


typedef struct PB4CommunityPlayerMsgClearRedPointReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityPlayerMsgClearRedPointReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgClearRedPointReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityPlayerMsgClearRedPointReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgClearRedPointRes

@implementation PB4CommunityPlayerMsgClearRedPointRes


typedef struct PB4CommunityPlayerMsgClearRedPointRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityPlayerMsgClearRedPointRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgClearRedPointRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityPlayerMsgClearRedPointRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgRedPoint

@implementation PB4CommunityPlayerMsgRedPoint

@dynamic num;

typedef struct PB4CommunityPlayerMsgRedPoint__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
} PB4CommunityPlayerMsgRedPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsgRedPoint_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgRedPoint__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgRedPoint class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsgRedPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsgReq

@implementation PB4CommunityPlayerMsgReq

@dynamic index;
@dynamic showType;

typedef struct PB4CommunityPlayerMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB4CommunityMsgShowType showType;
} PB4CommunityPlayerMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsgReq_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityMsgShowType_EnumDescriptor,
        .number = PB4CommunityPlayerMsgReq_FieldNumber_ShowType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgReq__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPlayerMsgReq_ShowType_RawValue(PB4CommunityPlayerMsgReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsgReq_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPlayerMsgReq_ShowType_RawValue(PB4CommunityPlayerMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsgReq_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPlayerMsgRes

@implementation PB4CommunityPlayerMsgRes

@dynamic list;
@dynamic nextIndex;
@dynamic showType;

typedef struct PB4CommunityPlayerMsgRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextIndex;
  PB4CommunityMsgShowType showType;
  NSData *list;
} PB4CommunityPlayerMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "list",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsgRes_FieldNumber_List,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgRes__storage_, list),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsgRes_FieldNumber_NextIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityMsgShowType_EnumDescriptor,
        .number = PB4CommunityPlayerMsgRes_FieldNumber_ShowType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgRes__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPlayerMsgRes_ShowType_RawValue(PB4CommunityPlayerMsgRes *message) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsgRes_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPlayerMsgRes_ShowType_RawValue(PB4CommunityPlayerMsgRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsgRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsgRes_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPlayerMsgs

@implementation PB4CommunityPlayerMsgs

@dynamic msgArray, msgArray_Count;

typedef struct PB4CommunityPlayerMsgs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgArray;
} PB4CommunityPlayerMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerMsg),
        .number = PB4CommunityPlayerMsgs_FieldNumber_MsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsgs__storage_, msgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsgs class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerMsg

@implementation PB4CommunityPlayerMsg

@dynamic id_p;
@dynamic hasTrend, trend;
@dynamic hasPlayer, player;
@dynamic hasCommentedPlayer, commentedPlayer;
@dynamic commentId;
@dynamic selfTrend;
@dynamic comment;
@dynamic creatAt;
@dynamic type;
@dynamic desc;

typedef struct PB4CommunityPlayerMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t commentId;
  PB4CommunityPlayerMsgType type;
  PB4CommunityTrendData *trend;
  PB4CommunityPlayerInfo *player;
  PB4CommunityPlayerInfo *commentedPlayer;
  NSString *comment;
  NSString *desc;
  int64_t creatAt;
} PB4CommunityPlayerMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trend",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityPlayerMsg_FieldNumber_Trend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, trend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "player",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerInfo),
        .number = PB4CommunityPlayerMsg_FieldNumber_Player,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, player),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentedPlayer",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityPlayerInfo),
        .number = PB4CommunityPlayerMsg_FieldNumber_CommentedPlayer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, commentedPlayer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_CommentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "selfTrend",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_SelfTrend,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_Comment,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creatAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_CreatAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, creatAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4CommunityPlayerMsgType_EnumDescriptor,
        .number = PB4CommunityPlayerMsg_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerMsg_FieldNumber_Desc,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerMsg__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerMsg class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityPlayerMsg_Type_RawValue(PB4CommunityPlayerMsg *message) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsg_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityPlayerMsg_Type_RawValue(PB4CommunityPlayerMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityPlayerMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityPlayerMsg_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityPlayerStatReq

@implementation PB4CommunityPlayerStatReq

@dynamic playerId;

typedef struct PB4CommunityPlayerStatReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t playerId;
} PB4CommunityPlayerStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerStatReq_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerStatReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerStatReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityMailMsgItem

@implementation PB4CommunityMailMsgItem

@dynamic id_p;
@dynamic cmdId;
@dynamic createAt;
@dynamic data_p;

typedef struct PB4CommunityMailMsgItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdId;
  int32_t createAt;
  NSData *data_p;
  int64_t id_p;
} PB4CommunityMailMsgItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityMailMsgItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityMailMsgItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityMailMsgItem_FieldNumber_CmdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityMailMsgItem__storage_, cmdId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityMailMsgItem_FieldNumber_CreateAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityMailMsgItem__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityMailMsgItem_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityMailMsgItem__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityMailMsgItem class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityMailMsgItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPlayerStatRes

@implementation PB4CommunityPlayerStatRes

@dynamic trendsNum;
@dynamic joinGroupNum;

typedef struct PB4CommunityPlayerStatRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t trendsNum;
  int32_t joinGroupNum;
} PB4CommunityPlayerStatRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerStatRes_FieldNumber_TrendsNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerStatRes__storage_, trendsNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "joinGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPlayerStatRes_FieldNumber_JoinGroupNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityPlayerStatRes__storage_, joinGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPlayerStatRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPlayerStatRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityAgreementReq

@implementation PB4CommunityAgreementReq

@dynamic operType;

typedef struct PB4CommunityAgreementReq__storage_ {
  uint32_t _has_storage_[1];
  PB4AgreementOperType operType;
} PB4CommunityAgreementReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operType",
        .dataTypeSpecific.enumDescFunc = PB4AgreementOperType_EnumDescriptor,
        .number = PB4CommunityAgreementReq_FieldNumber_OperType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityAgreementReq__storage_, operType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityAgreementReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityAgreementReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityAgreementReq_OperType_RawValue(PB4CommunityAgreementReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityAgreementReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityAgreementReq_FieldNumber_OperType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityAgreementReq_OperType_RawValue(PB4CommunityAgreementReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityAgreementReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityAgreementReq_FieldNumber_OperType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityAgreementRes

@implementation PB4CommunityAgreementRes

@dynamic isAgree;

typedef struct PB4CommunityAgreementRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityAgreementRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isAgree",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityAgreementRes_FieldNumber_IsAgree,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityAgreementRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityAgreementRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPublishPermissionReq

@implementation PB4CommunityPublishPermissionReq


typedef struct PB4CommunityPublishPermissionReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityPublishPermissionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPublishPermissionReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityPublishPermissionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityPublishPermissionRes

@implementation PB4CommunityPublishPermissionRes

@dynamic isPermit;
@dynamic maxSelectLabelNum;
@dynamic maxSelectGroupNum;
@dynamic maxSelectMediaNum;

typedef struct PB4CommunityPublishPermissionRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxSelectLabelNum;
  int32_t maxSelectGroupNum;
  int32_t maxSelectMediaNum;
} PB4CommunityPublishPermissionRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isPermit",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishPermissionRes_FieldNumber_IsPermit,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "maxSelectLabelNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishPermissionRes_FieldNumber_MaxSelectLabelNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityPublishPermissionRes__storage_, maxSelectLabelNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxSelectGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishPermissionRes_FieldNumber_MaxSelectGroupNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityPublishPermissionRes__storage_, maxSelectGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxSelectMediaNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityPublishPermissionRes_FieldNumber_MaxSelectMediaNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityPublishPermissionRes__storage_, maxSelectMediaNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityPublishPermissionRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityPublishPermissionRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupLimitReq

@implementation PB4CommunityGroupLimitReq


typedef struct PB4CommunityGroupLimitReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityGroupLimitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupLimitReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityGroupLimitReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityGroupLimitRes

@implementation PB4CommunityGroupLimitRes

@dynamic wealthLv;
@dynamic charmLv;
@dynamic andOr;
@dynamic maxActiveGroupNum;
@dynamic maxGroupMemberNum;
@dynamic showCreateButton;
@dynamic invitedInvalidTime;
@dynamic createMsg;

typedef struct PB4CommunityGroupLimitRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t wealthLv;
  int32_t charmLv;
  int32_t andOr;
  int32_t maxActiveGroupNum;
  int32_t maxGroupMemberNum;
  NSString *createMsg;
  int64_t invitedInvalidTime;
} PB4CommunityGroupLimitRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wealthLv",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_WealthLv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, wealthLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLv",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_CharmLv,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, charmLv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "andOr",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_AndOr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, andOr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxActiveGroupNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_MaxActiveGroupNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, maxActiveGroupNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxGroupMemberNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_MaxGroupMemberNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, maxGroupMemberNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showCreateButton",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_ShowCreateButton,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "invitedInvalidTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_InvitedInvalidTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, invitedInvalidTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupLimitRes_FieldNumber_CreateMsg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4CommunityGroupLimitRes__storage_, createMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupLimitRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupLimitRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearCommunityPlayerMsgReq

@implementation PB4ClearCommunityPlayerMsgReq


typedef struct PB4ClearCommunityPlayerMsgReq__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearCommunityPlayerMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearCommunityPlayerMsgReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ClearCommunityPlayerMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearCommunityPlayerMsgRes

@implementation PB4ClearCommunityPlayerMsgRes


typedef struct PB4ClearCommunityPlayerMsgRes__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearCommunityPlayerMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearCommunityPlayerMsgRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ClearCommunityPlayerMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GroupInfoSimple

@implementation PB4GroupInfoSimple

@dynamic id_p;
@dynamic name;

typedef struct PB4GroupInfoSimple__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t id_p;
} PB4GroupInfoSimple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupInfoSimple_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GroupInfoSimple__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4GroupInfoSimple_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GroupInfoSimple__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GroupInfoSimple class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GroupInfoSimple__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CheckCreateGroupReq

@implementation PB4CheckCreateGroupReq


typedef struct PB4CheckCreateGroupReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CheckCreateGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CheckCreateGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CheckCreateGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CheckCreateGroupRes

@implementation PB4CheckCreateGroupRes


typedef struct PB4CheckCreateGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CheckCreateGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CheckCreateGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CheckCreateGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ApplyJoinNumPush

@implementation PB4ApplyJoinNumPush

@dynamic applyNum;
@dynamic groupId;

typedef struct PB4ApplyJoinNumPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t applyNum;
  int64_t groupId;
} PB4ApplyJoinNumPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4ApplyJoinNumPush_FieldNumber_ApplyNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ApplyJoinNumPush__storage_, applyNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4ApplyJoinNumPush_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ApplyJoinNumPush__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ApplyJoinNumPush class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ApplyJoinNumPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PlayerGroupListResPush

@implementation PB4PlayerGroupListResPush

@dynamic itemArray, itemArray_Count;

typedef struct PB4PlayerGroupListResPush__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} PB4PlayerGroupListResPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4GroupListItem),
        .number = PB4PlayerGroupListResPush_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PlayerGroupListResPush__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PlayerGroupListResPush class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PlayerGroupListResPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4InviteJoinGroupReq

@implementation PB4InviteJoinGroupReq

@dynamic invitedId;
@dynamic groupId;

typedef struct PB4InviteJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t invitedId;
  int64_t groupId;
} PB4InviteJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitedId",
        .dataTypeSpecific.className = NULL,
        .number = PB4InviteJoinGroupReq_FieldNumber_InvitedId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4InviteJoinGroupReq__storage_, invitedId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4InviteJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4InviteJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4InviteJoinGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4InviteJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4InviteJoinGroupRes

@implementation PB4InviteJoinGroupRes


typedef struct PB4InviteJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4InviteJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4InviteJoinGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4InviteJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ImmediateJoinGroupReq

@implementation PB4ImmediateJoinGroupReq

@dynamic groupId;

typedef struct PB4ImmediateJoinGroupReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t groupId;
} PB4ImmediateJoinGroupReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4ImmediateJoinGroupReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ImmediateJoinGroupReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ImmediateJoinGroupReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ImmediateJoinGroupReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ImmediateJoinGroupRes

@implementation PB4ImmediateJoinGroupRes


typedef struct PB4ImmediateJoinGroupRes__storage_ {
  uint32_t _has_storage_[1];
} PB4ImmediateJoinGroupRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ImmediateJoinGroupRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ImmediateJoinGroupRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsCheckNoPass

@implementation PB4TrendsCheckNoPass

@dynamic trendsId;

typedef struct PB4TrendsCheckNoPass__storage_ {
  uint32_t _has_storage_[1];
  int64_t trendsId;
} PB4TrendsCheckNoPass__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCheckNoPass_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsCheckNoPass__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsCheckNoPass class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsCheckNoPass__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ContentSensitiveCheck

@implementation PB4ContentSensitiveCheck

@dynamic toastText;
@dynamic checkedContent;

typedef struct PB4ContentSensitiveCheck__storage_ {
  uint32_t _has_storage_[1];
  NSString *toastText;
  NSString *checkedContent;
} PB4ContentSensitiveCheck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "toastText",
        .dataTypeSpecific.className = NULL,
        .number = PB4ContentSensitiveCheck_FieldNumber_ToastText,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ContentSensitiveCheck__storage_, toastText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkedContent",
        .dataTypeSpecific.className = NULL,
        .number = PB4ContentSensitiveCheck_FieldNumber_CheckedContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ContentSensitiveCheck__storage_, checkedContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ContentSensitiveCheck class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ContentSensitiveCheck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsCheckResult

@implementation PB4TrendsCheckResult

@dynamic trendsId;
@dynamic pass;

typedef struct PB4TrendsCheckResult__storage_ {
  uint32_t _has_storage_[1];
  int64_t trendsId;
} PB4TrendsCheckResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCheckResult_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsCheckResult__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCheckResult_FieldNumber_Pass,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsCheckResult class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsCheckResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsCommentCheckResult

@implementation PB4TrendsCommentCheckResult

@dynamic trendsId;
@dynamic commentId;
@dynamic pass;

typedef struct PB4TrendsCommentCheckResult__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int64_t trendsId;
} PB4TrendsCommentCheckResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendsId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentCheckResult_FieldNumber_TrendsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsCommentCheckResult__storage_, trendsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentCheckResult_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendsCommentCheckResult__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pass",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsCommentCheckResult_FieldNumber_Pass,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsCommentCheckResult class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsCommentCheckResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityFocusFriendReq

@implementation PB4CommunityFocusFriendReq


typedef struct PB4CommunityFocusFriendReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CommunityFocusFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityFocusFriendReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CommunityFocusFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityFocusFriendRes

@implementation PB4CommunityFocusFriendRes

@dynamic num;
@dynamic route;

typedef struct PB4CommunityFocusFriendRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  NSString *route;
} PB4CommunityFocusFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityFocusFriendRes_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityFocusFriendRes__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityFocusFriendRes_FieldNumber_Route,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityFocusFriendRes__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityFocusFriendRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityFocusFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearFocusFriendReq

@implementation PB4ClearFocusFriendReq


typedef struct PB4ClearFocusFriendReq__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearFocusFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearFocusFriendReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ClearFocusFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearFocusFriendRes

@implementation PB4ClearFocusFriendRes


typedef struct PB4ClearFocusFriendRes__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearFocusFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearFocusFriendRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ClearFocusFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ViolationPictureExampleReq

@implementation PB4ViolationPictureExampleReq


typedef struct PB4ViolationPictureExampleReq__storage_ {
  uint32_t _has_storage_[1];
} PB4ViolationPictureExampleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ViolationPictureExampleReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ViolationPictureExampleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ViolationInfo

@implementation PB4ViolationInfo

@dynamic URL;
@dynamic content;

typedef struct PB4ViolationInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *content;
} PB4ViolationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB4ViolationInfo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ViolationInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4ViolationInfo_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ViolationInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ViolationInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ViolationInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ViolationPictureExampleRes

@implementation PB4ViolationPictureExampleRes

@dynamic title;
@dynamic listArray, listArray_Count;
@dynamic remark;

typedef struct PB4ViolationPictureExampleRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSMutableArray *listArray;
  NSString *remark;
} PB4ViolationPictureExampleRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4ViolationPictureExampleRes_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ViolationPictureExampleRes__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4ViolationInfo),
        .number = PB4ViolationPictureExampleRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4ViolationPictureExampleRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = PB4ViolationPictureExampleRes_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ViolationPictureExampleRes__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ViolationPictureExampleRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ViolationPictureExampleRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendTagInfoReq

@implementation PB4TrendTagInfoReq

@dynamic id_p;

typedef struct PB4TrendTagInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB4TrendTagInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendTagInfoReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendTagInfoReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendTagInfoReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendTagInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendTagInfoRes

@implementation PB4TrendTagInfoRes

@dynamic hasTag, tag;

typedef struct PB4TrendTagInfoRes__storage_ {
  uint32_t _has_storage_[1];
  PB4TrendTag *tag;
} PB4TrendTagInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendTag),
        .number = PB4TrendTagInfoRes_FieldNumber_Tag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendTagInfoRes__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendTagInfoRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendTagInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SkillInteractionInfoReq

@implementation PB4SkillInteractionInfoReq


typedef struct PB4SkillInteractionInfoReq__storage_ {
  uint32_t _has_storage_[1];
} PB4SkillInteractionInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SkillInteractionInfoReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4SkillInteractionInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SkillInteractionInfoRes

@implementation PB4SkillInteractionInfoRes

@dynamic skillListArray, skillListArray_Count;
@dynamic interactionListArray, interactionListArray_Count;

typedef struct PB4SkillInteractionInfoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *skillListArray;
  NSMutableArray *interactionListArray;
} PB4SkillInteractionInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsSkillInfo),
        .number = PB4SkillInteractionInfoRes_FieldNumber_SkillListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4SkillInteractionInfoRes__storage_, skillListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interactionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendsInteractionInfo),
        .number = PB4SkillInteractionInfoRes_FieldNumber_InteractionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4SkillInteractionInfoRes__storage_, interactionListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SkillInteractionInfoRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SkillInteractionInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsSkillInfo

@implementation PB4TrendsSkillInfo

@dynamic skillId;
@dynamic skillName;
@dynamic icon;

typedef struct PB4TrendsSkillInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *skillName;
  NSString *icon;
  int64_t skillId;
} PB4TrendsSkillInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsSkillInfo_FieldNumber_SkillId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsSkillInfo__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "skillName",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsSkillInfo_FieldNumber_SkillName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendsSkillInfo__storage_, skillName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsSkillInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendsSkillInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsSkillInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsSkillInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4TrendsInteractionInfo

@implementation PB4TrendsInteractionInfo

@dynamic interactionId;
@dynamic interactionName;
@dynamic icon;

typedef struct PB4TrendsInteractionInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *interactionName;
  NSString *icon;
  int64_t interactionId;
} PB4TrendsInteractionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interactionId",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsInteractionInfo_FieldNumber_InteractionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4TrendsInteractionInfo__storage_, interactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interactionName",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsInteractionInfo_FieldNumber_InteractionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4TrendsInteractionInfo__storage_, interactionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4TrendsInteractionInfo_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4TrendsInteractionInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4TrendsInteractionInfo class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4TrendsInteractionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SystemMiscMsgItem

@implementation PB4SystemMiscMsgItem

@dynamic showType;
@dynamic unreadNum;
@dynamic desc;
@dynamic msgTime;

typedef struct PB4SystemMiscMsgItem__storage_ {
  uint32_t _has_storage_[1];
  PB4CommunityMsgShowType showType;
  NSString *desc;
  int64_t unreadNum;
  int64_t msgTime;
} PB4SystemMiscMsgItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showType",
        .dataTypeSpecific.enumDescFunc = PB4CommunityMsgShowType_EnumDescriptor,
        .number = PB4SystemMiscMsgItem_FieldNumber_ShowType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4SystemMiscMsgItem__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unreadNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4SystemMiscMsgItem_FieldNumber_UnreadNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4SystemMiscMsgItem__storage_, unreadNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB4SystemMiscMsgItem_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4SystemMiscMsgItem__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4SystemMiscMsgItem_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4SystemMiscMsgItem__storage_, msgTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SystemMiscMsgItem class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SystemMiscMsgItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4SystemMiscMsgItem_ShowType_RawValue(PB4SystemMiscMsgItem *message) {
  GPBDescriptor *descriptor = [PB4SystemMiscMsgItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4SystemMiscMsgItem_FieldNumber_ShowType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4SystemMiscMsgItem_ShowType_RawValue(PB4SystemMiscMsgItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4SystemMiscMsgItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4SystemMiscMsgItem_FieldNumber_ShowType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityNewTrendsReq

@implementation PB4CommunityNewTrendsReq

@dynamic index;

typedef struct PB4CommunityNewTrendsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
} PB4CommunityNewTrendsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityNewTrendsReq_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityNewTrendsReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityNewTrendsReq class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityNewTrendsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityNewTrendsRes

@implementation PB4CommunityNewTrendsRes

@dynamic listArray, listArray_Count;

typedef struct PB4CommunityNewTrendsRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4CommunityNewTrendsRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommunityTrendData),
        .number = PB4CommunityNewTrendsRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityNewTrendsRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityNewTrendsRes class]
                                     rootClass:[PB4CommunityExtRoot class]
                                          file:PB4CommunityExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityNewTrendsRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
