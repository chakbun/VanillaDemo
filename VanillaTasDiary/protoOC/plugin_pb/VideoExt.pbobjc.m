// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plugin_pb/video.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "plugin_pb/VideoExt.pbobjc.h"
#import "plugin_pb/CommunityExt.pbobjc.h"
#import "plugin_pb/PluginExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB4VideoExtRoot

@implementation PB4VideoExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB4VideoExtRoot_FileDescriptor

static GPBFileDescriptor *PB4VideoExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"plugin_pb"
                                                 objcPrefix:@"PB4"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB4VideoCmdId

GPBEnumDescriptor *PB4VideoCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcVideoZero\000";
    static const int32_t values[] = {
        PB4VideoCmdId_IcVideoZero,
    };
    static const char *extraTextFormatInfo = "\001\000b\211\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoCmdId_IcVideoZero:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoGetType

GPBEnumDescriptor *PB4VideoGetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VgtZero\000VgtFirst\000";
    static const int32_t values[] = {
        PB4VideoGetType_VgtZero,
        PB4VideoGetType_VgtFirst,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoGetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoGetType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoGetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoGetType_VgtZero:
    case PB4VideoGetType_VgtFirst:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4EIButtonType

GPBEnumDescriptor *PB4EIButtonType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EibtZero\000EibtSkill\000EibtChat\000EibtLiaoTa\000E"
        "ibtZhenxinhua\000EibtCpYuehui\000";
    static const int32_t values[] = {
        PB4EIButtonType_EibtZero,
        PB4EIButtonType_EibtSkill,
        PB4EIButtonType_EibtChat,
        PB4EIButtonType_EibtLiaoTa,
        PB4EIButtonType_EibtZhenxinhua,
        PB4EIButtonType_EibtCpYuehui,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4EIButtonType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4EIButtonType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4EIButtonType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4EIButtonType_EibtZero:
    case PB4EIButtonType_EibtSkill:
    case PB4EIButtonType_EibtChat:
    case PB4EIButtonType_EibtLiaoTa:
    case PB4EIButtonType_EibtZhenxinhua:
    case PB4EIButtonType_EibtCpYuehui:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoPlayerStatus

GPBEnumDescriptor *PB4VideoPlayerStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VpsZero\000VpsOutRoom\000VpsInRoom\000VpsOnChair\000"
        "VpsSinging\000";
    static const int32_t values[] = {
        PB4VideoPlayerStatus_VpsZero,
        PB4VideoPlayerStatus_VpsOutRoom,
        PB4VideoPlayerStatus_VpsInRoom,
        PB4VideoPlayerStatus_VpsOnChair,
        PB4VideoPlayerStatus_VpsSinging,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoPlayerStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoPlayerStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoPlayerStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoPlayerStatus_VpsZero:
    case PB4VideoPlayerStatus_VpsOutRoom:
    case PB4VideoPlayerStatus_VpsInRoom:
    case PB4VideoPlayerStatus_VpsOnChair:
    case PB4VideoPlayerStatus_VpsSinging:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoCTopType

GPBEnumDescriptor *PB4VideoCTopType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VctZero\000VctActivity\000VctSameCity\000VctFallo"
        "w\000";
    static const int32_t values[] = {
        PB4VideoCTopType_VctZero,
        PB4VideoCTopType_VctActivity,
        PB4VideoCTopType_VctSameCity,
        PB4VideoCTopType_VctFallow,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoCTopType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoCTopType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoCTopType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoCTopType_VctZero:
    case PB4VideoCTopType_VctActivity:
    case PB4VideoCTopType_VctSameCity:
    case PB4VideoCTopType_VctFallow:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoRecReason

GPBEnumDescriptor *PB4VideoRecReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VrrZero\000VrrNearby\000VrrFocus\000VrrGood\000VrrTo"
        "p\000VrrLabel\000";
    static const int32_t values[] = {
        PB4VideoRecReason_VrrZero,
        PB4VideoRecReason_VrrNearby,
        PB4VideoRecReason_VrrFocus,
        PB4VideoRecReason_VrrGood,
        PB4VideoRecReason_VrrTop,
        PB4VideoRecReason_VrrLabel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoRecReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoRecReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoRecReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoRecReason_VrrZero:
    case PB4VideoRecReason_VrrNearby:
    case PB4VideoRecReason_VrrFocus:
    case PB4VideoRecReason_VrrGood:
    case PB4VideoRecReason_VrrTop:
    case PB4VideoRecReason_VrrLabel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoButtonType

GPBEnumDescriptor *PB4VideoButtonType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VbtZero\000VbtInteraction\000VbtBill\000VbtIm\000";
    static const int32_t values[] = {
        PB4VideoButtonType_VbtZero,
        PB4VideoButtonType_VbtInteraction,
        PB4VideoButtonType_VbtBill,
        PB4VideoButtonType_VbtIm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoButtonType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoButtonType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoButtonType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoButtonType_VbtZero:
    case PB4VideoButtonType_VbtInteraction:
    case PB4VideoButtonType_VbtBill:
    case PB4VideoButtonType_VbtIm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4VideoOptType

GPBEnumDescriptor *PB4VideoOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VotZero\000VotStart\000VotComplete\000VotStop\000Vot"
        "Uninterested\000VotCover\000";
    static const int32_t values[] = {
        PB4VideoOptType_VotZero,
        PB4VideoOptType_VotStart,
        PB4VideoOptType_VotComplete,
        PB4VideoOptType_VotStop,
        PB4VideoOptType_VotUninterested,
        PB4VideoOptType_VotCover,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4VideoOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4VideoOptType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4VideoOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4VideoOptType_VotZero:
    case PB4VideoOptType_VotStart:
    case PB4VideoOptType_VotComplete:
    case PB4VideoOptType_VotStop:
    case PB4VideoOptType_VotUninterested:
    case PB4VideoOptType_VotCover:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB4VideoReq

@implementation PB4VideoReq

@dynamic getType;
@dynamic lastTrendId;
@dynamic lastIdsArray, lastIdsArray_Count;
@dynamic lastIndex;

typedef struct PB4VideoReq__storage_ {
  uint32_t _has_storage_[1];
  PB4VideoGetType getType;
  int32_t lastIndex;
  GPBInt64Array *lastIdsArray;
  int64_t lastTrendId;
} PB4VideoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "getType",
        .dataTypeSpecific.enumDescFunc = PB4VideoGetType_EnumDescriptor,
        .number = PB4VideoReq_FieldNumber_GetType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoReq__storage_, getType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lastTrendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoReq_FieldNumber_LastTrendId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoReq__storage_, lastTrendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoReq_FieldNumber_LastIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoReq__storage_, lastIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoReq_FieldNumber_LastIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoReq__storage_, lastIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoReq class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoReq_GetType_RawValue(PB4VideoReq *message) {
  GPBDescriptor *descriptor = [PB4VideoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoReq_FieldNumber_GetType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoReq_GetType_RawValue(PB4VideoReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoReq_FieldNumber_GetType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoRes

@implementation PB4VideoRes

@dynamic infosArray, infosArray_Count;
@dynamic preloadIdxArray, preloadIdxArray_Count;

typedef struct PB4VideoRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *infosArray;
  GPBInt64Array *preloadIdxArray;
} PB4VideoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "infosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4VideoInfo),
        .number = PB4VideoRes_FieldNumber_InfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoRes__storage_, infosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preloadIdxArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoRes_FieldNumber_PreloadIdxArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoRes__storage_, preloadIdxArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoRes class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VideoInfo

@implementation PB4VideoInfo

@dynamic trendId;
@dynamic playerId;
@dynamic name;
@dynamic sex;
@dynamic icon;
@dynamic videoURL;
@dynamic likeNum;
@dynamic commentNum;
@dynamic content;
@dynamic tagsArray, tagsArray_Count;
@dynamic isGaveLike;
@dynamic coverURL;
@dynamic videoWidth;
@dynamic videoHeight;
@dynamic skillId;
@dynamic iaId;
@dynamic activityId;
@dynamic sourceId;
@dynamic from;
@dynamic quality;
@dynamic labelId;
@dynamic recmdSource;
@dynamic recmdSourceId;
@dynamic traceInfo;
@dynamic authInfoListArray, authInfoListArray_Count;

typedef struct PB4VideoInfo__storage_ {
  uint32_t _has_storage_[1];
  PB4PluginSexType sex;
  int32_t videoWidth;
  int32_t videoHeight;
  int32_t skillId;
  int32_t iaId;
  int32_t activityId;
  int32_t from;
  int32_t quality;
  int32_t labelId;
  PB4VideoRecmdSource recmdSource;
  NSString *name;
  NSString *icon;
  NSString *videoURL;
  NSString *content;
  NSMutableArray *tagsArray;
  NSString *coverURL;
  NSString *recmdSourceId;
  NSString *traceInfo;
  NSMutableArray *authInfoListArray;
  int64_t trendId;
  int64_t playerId;
  int64_t likeNum;
  int64_t commentNum;
  int64_t sourceId;
} PB4VideoInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_TrendId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4VideoInfo_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_VideoURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, videoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_LikeNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, likeNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_CommentNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, commentNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_Content,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4TrendTag),
        .number = PB4VideoInfo_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isGaveLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_IsGaveLike,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_CoverURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoWidth",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_VideoWidth,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, videoWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "videoHeight",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_VideoHeight,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, videoHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_SkillId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "iaId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_IaId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, iaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activityId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_ActivityId,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, activityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_SourceId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, sourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_From,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "quality",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_Quality,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, quality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "labelId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_LabelId,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, labelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recmdSource",
        .dataTypeSpecific.enumDescFunc = PB4VideoRecmdSource_EnumDescriptor,
        .number = PB4VideoInfo_FieldNumber_RecmdSource,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, recmdSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recmdSourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_RecmdSourceId,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, recmdSourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoInfo_FieldNumber_TraceInfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, traceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PAuthInfo),
        .number = PB4VideoInfo_FieldNumber_AuthInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoInfo__storage_, authInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoInfo class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\006\005\241!!\000\014\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoInfo_Sex_RawValue(PB4VideoInfo *message) {
  GPBDescriptor *descriptor = [PB4VideoInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoInfo_Sex_RawValue(PB4VideoInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4VideoInfo_RecmdSource_RawValue(PB4VideoInfo *message) {
  GPBDescriptor *descriptor = [PB4VideoInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoInfo_FieldNumber_RecmdSource];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoInfo_RecmdSource_RawValue(PB4VideoInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoInfo_FieldNumber_RecmdSource];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoPlayerReq

@implementation PB4VideoPlayerReq

@dynamic trendId;
@dynamic from;
@dynamic quality;
@dynamic labelId;

typedef struct PB4VideoPlayerReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t from;
  int32_t quality;
  int32_t labelId;
  int64_t trendId;
} PB4VideoPlayerReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoPlayerReq_FieldNumber_TrendId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoPlayerReq__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoPlayerReq_FieldNumber_From,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoPlayerReq__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "quality",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoPlayerReq_FieldNumber_Quality,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoPlayerReq__storage_, quality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "labelId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoPlayerReq_FieldNumber_LabelId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoPlayerReq__storage_, labelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoPlayerReq class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoPlayerReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VideoPlayerRes

@implementation PB4VideoPlayerRes

@dynamic hasContentTop, contentTop;
@dynamic hasButton, button;
@dynamic status;
@dynamic roomId;
@dynamic recReason;
@dynamic hasExtraInfoBtn, extraInfoBtn;

typedef struct PB4VideoPlayerRes__storage_ {
  uint32_t _has_storage_[1];
  PB4VideoPlayerStatus status;
  PB4VideoRecReason recReason;
  PB4VideoContentTop *contentTop;
  PB4VideoButton *button;
  PB4ExtraInfo *extraInfoBtn;
  int64_t roomId;
} PB4VideoPlayerRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentTop",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4VideoContentTop),
        .number = PB4VideoPlayerRes_FieldNumber_ContentTop,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, contentTop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "button",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4VideoButton),
        .number = PB4VideoPlayerRes_FieldNumber_Button,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, button),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB4VideoPlayerStatus_EnumDescriptor,
        .number = PB4VideoPlayerRes_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoPlayerRes_FieldNumber_RoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "recReason",
        .dataTypeSpecific.enumDescFunc = PB4VideoRecReason_EnumDescriptor,
        .number = PB4VideoPlayerRes_FieldNumber_RecReason,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, recReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extraInfoBtn",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4ExtraInfo),
        .number = PB4VideoPlayerRes_FieldNumber_ExtraInfoBtn,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4VideoPlayerRes__storage_, extraInfoBtn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoPlayerRes class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoPlayerRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoPlayerRes_Status_RawValue(PB4VideoPlayerRes *message) {
  GPBDescriptor *descriptor = [PB4VideoPlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoPlayerRes_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoPlayerRes_Status_RawValue(PB4VideoPlayerRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoPlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoPlayerRes_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4VideoPlayerRes_RecReason_RawValue(PB4VideoPlayerRes *message) {
  GPBDescriptor *descriptor = [PB4VideoPlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoPlayerRes_FieldNumber_RecReason];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoPlayerRes_RecReason_RawValue(PB4VideoPlayerRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoPlayerRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoPlayerRes_FieldNumber_RecReason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4ExtraInfo

@implementation PB4ExtraInfo

@dynamic buttonType;
@dynamic buttonIcon;
@dynamic buttonContent;
@dynamic icon;
@dynamic content;
@dynamic orderNum;
@dynamic skillInfo;
@dynamic expireTime;
@dynamic jumpURL;
@dynamic price;

typedef struct PB4ExtraInfo__storage_ {
  uint32_t _has_storage_[1];
  PB4EIButtonType buttonType;
  int32_t orderNum;
  int32_t price;
  NSString *buttonIcon;
  NSString *buttonContent;
  NSString *icon;
  NSString *content;
  NSString *skillInfo;
  NSString *jumpURL;
  int64_t expireTime;
} PB4ExtraInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "buttonType",
        .dataTypeSpecific.enumDescFunc = PB4EIButtonType_EnumDescriptor,
        .number = PB4ExtraInfo_FieldNumber_ButtonType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, buttonType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "buttonIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_ButtonIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, buttonIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buttonContent",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_ButtonContent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, buttonContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_OrderNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, orderNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skillInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_SkillInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, skillInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_ExpireTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_JumpURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraInfo_FieldNumber_Price,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4ExtraInfo__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ExtraInfo class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ExtraInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4ExtraInfo_ButtonType_RawValue(PB4ExtraInfo *message) {
  GPBDescriptor *descriptor = [PB4ExtraInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraInfo_FieldNumber_ButtonType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ExtraInfo_ButtonType_RawValue(PB4ExtraInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ExtraInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraInfo_FieldNumber_ButtonType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoContentTop

@implementation PB4VideoContentTop

@dynamic ctType;
@dynamic icon;
@dynamic text;
@dynamic jumpURL;

typedef struct PB4VideoContentTop__storage_ {
  uint32_t _has_storage_[1];
  PB4VideoCTopType ctType;
  NSString *icon;
  NSString *text;
  NSString *jumpURL;
} PB4VideoContentTop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ctType",
        .dataTypeSpecific.enumDescFunc = PB4VideoCTopType_EnumDescriptor,
        .number = PB4VideoContentTop_FieldNumber_CtType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoContentTop__storage_, ctType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoContentTop_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoContentTop__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoContentTop_FieldNumber_Text,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoContentTop__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoContentTop_FieldNumber_JumpURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoContentTop__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoContentTop class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoContentTop__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoContentTop_CtType_RawValue(PB4VideoContentTop *message) {
  GPBDescriptor *descriptor = [PB4VideoContentTop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoContentTop_FieldNumber_CtType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoContentTop_CtType_RawValue(PB4VideoContentTop *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoContentTop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoContentTop_FieldNumber_CtType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoButton

@implementation PB4VideoButton

@dynamic icon;
@dynamic text;
@dynamic jumpURL;
@dynamic ctType;
@dynamic typeId;

typedef struct PB4VideoButton__storage_ {
  uint32_t _has_storage_[1];
  PB4VideoButtonType ctType;
  NSString *icon;
  NSString *text;
  NSString *jumpURL;
  int64_t typeId;
} PB4VideoButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoButton_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoButton__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoButton_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoButton__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jumpURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoButton_FieldNumber_JumpURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoButton__storage_, jumpURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ctType",
        .dataTypeSpecific.enumDescFunc = PB4VideoButtonType_EnumDescriptor,
        .number = PB4VideoButton_FieldNumber_CtType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoButton__storage_, ctType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "typeId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoButton_FieldNumber_TypeId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4VideoButton__storage_, typeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoButton class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoButton__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoButton_CtType_RawValue(PB4VideoButton *message) {
  GPBDescriptor *descriptor = [PB4VideoButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoButton_FieldNumber_CtType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoButton_CtType_RawValue(PB4VideoButton *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoButton descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoButton_FieldNumber_CtType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoLikeReq

@implementation PB4VideoLikeReq

@dynamic page;

typedef struct PB4VideoLikeReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t page;
} PB4VideoLikeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoLikeReq_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoLikeReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoLikeReq class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoLikeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VideoLikeRes

@implementation PB4VideoLikeRes

@dynamic nextPage;
@dynamic infosArray, infosArray_Count;

typedef struct PB4VideoLikeRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t nextPage;
  NSMutableArray *infosArray;
} PB4VideoLikeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nextPage",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoLikeRes_FieldNumber_NextPage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoLikeRes__storage_, nextPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "infosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4VideoInfo),
        .number = PB4VideoLikeRes_FieldNumber_InfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4VideoLikeRes__storage_, infosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoLikeRes class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoLikeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VideoOptReq

@implementation PB4VideoOptReq

@dynamic optType;
@dynamic trendId;
@dynamic second;
@dynamic leftNum;
@dynamic sourceId;
@dynamic recmdSource;
@dynamic recmdSourceId;
@dynamic traceInfo;
@dynamic firstPlay;

typedef struct PB4VideoOptReq__storage_ {
  uint32_t _has_storage_[1];
  PB4VideoOptType optType;
  int32_t leftNum;
  PB4VideoRecmdSource recmdSource;
  NSString *recmdSourceId;
  NSString *traceInfo;
  int64_t trendId;
  int64_t second;
  int64_t sourceId;
} PB4VideoOptReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optType",
        .dataTypeSpecific.enumDescFunc = PB4VideoOptType_EnumDescriptor,
        .number = PB4VideoOptReq_FieldNumber_OptType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, optType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_TrendId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "second",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_Second,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, second),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_LeftNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, leftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_SourceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, sourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "recmdSource",
        .dataTypeSpecific.enumDescFunc = PB4VideoRecmdSource_EnumDescriptor,
        .number = PB4VideoOptReq_FieldNumber_RecmdSource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, recmdSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recmdSourceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_RecmdSourceId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, recmdSourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceInfo",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_TraceInfo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4VideoOptReq__storage_, traceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstPlay",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoOptReq_FieldNumber_FirstPlay,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoOptReq class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoOptReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoOptReq_OptType_RawValue(PB4VideoOptReq *message) {
  GPBDescriptor *descriptor = [PB4VideoOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoOptReq_FieldNumber_OptType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoOptReq_OptType_RawValue(PB4VideoOptReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoOptReq_FieldNumber_OptType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4VideoOptReq_RecmdSource_RawValue(PB4VideoOptReq *message) {
  GPBDescriptor *descriptor = [PB4VideoOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoOptReq_FieldNumber_RecmdSource];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoOptReq_RecmdSource_RawValue(PB4VideoOptReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoOptReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoOptReq_FieldNumber_RecmdSource];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoOptRes

@implementation PB4VideoOptRes


typedef struct PB4VideoOptRes__storage_ {
  uint32_t _has_storage_[1];
} PB4VideoOptRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoOptRes class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4VideoOptRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4VideoButtonReportReq

@implementation PB4VideoButtonReportReq

@dynamic btn;
@dynamic trendId;

typedef struct PB4VideoButtonReportReq__storage_ {
  uint32_t _has_storage_[1];
  PB4EIButtonType btn;
  int64_t trendId;
} PB4VideoButtonReportReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "btn",
        .dataTypeSpecific.enumDescFunc = PB4EIButtonType_EnumDescriptor,
        .number = PB4VideoButtonReportReq_FieldNumber_Btn,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4VideoButtonReportReq__storage_, btn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4VideoButtonReportReq_FieldNumber_TrendId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4VideoButtonReportReq__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoButtonReportReq class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4VideoButtonReportReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4VideoButtonReportReq_Btn_RawValue(PB4VideoButtonReportReq *message) {
  GPBDescriptor *descriptor = [PB4VideoButtonReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoButtonReportReq_FieldNumber_Btn];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4VideoButtonReportReq_Btn_RawValue(PB4VideoButtonReportReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4VideoButtonReportReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4VideoButtonReportReq_FieldNumber_Btn];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4VideoButtonReportRes

@implementation PB4VideoButtonReportRes


typedef struct PB4VideoButtonReportRes__storage_ {
  uint32_t _has_storage_[1];
} PB4VideoButtonReportRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4VideoButtonReportRes class]
                                     rootClass:[PB4VideoExtRoot class]
                                          file:PB4VideoExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4VideoButtonReportRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
