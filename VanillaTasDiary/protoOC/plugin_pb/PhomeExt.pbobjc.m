// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plugin_pb/phome.ext.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "plugin_pb/PhomeExt.pbobjc.h"
#import "plugin_pb/PluginExt.pbobjc.h"
#import "plugin_pb/CommunityExt.pbobjc.h"
#import "plugin_pb/VideoExt.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PB4PhomeExtRoot

@implementation PB4PhomeExtRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PB4PhomeExtRoot_FileDescriptor

static GPBFileDescriptor *PB4PhomeExtRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"plugin_pb"
                                                 objcPrefix:@"PB4"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PB4PHomeCmdId

GPBEnumDescriptor *PB4PHomeCmdId_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IcHomeZero\000IcHomePushBcFriend\000IcHomePush"
        "Bubble\000IcHomePushBcFriendGame\000IcHomeSyst"
        "emToastCmdId\000IcHomeMatchCmdId\000IcHomePush"
        "UpdateAction\000IcHomePushModActionReset\000Ic"
        "HomePushNavRed\000IcHomePushBcFriendPlayerT"
        "ogether\000";
    static const int32_t values[] = {
        PB4PHomeCmdId_IcHomeZero,
        PB4PHomeCmdId_IcHomePushBcFriend,
        PB4PHomeCmdId_IcHomePushBubble,
        PB4PHomeCmdId_IcHomePushBcFriendGame,
        PB4PHomeCmdId_IcHomeSystemToastCmdId,
        PB4PHomeCmdId_IcHomeMatchCmdId,
        PB4PHomeCmdId_IcHomePushUpdateAction,
        PB4PHomeCmdId_IcHomePushModActionReset,
        PB4PHomeCmdId_IcHomePushNavRed,
        PB4PHomeCmdId_IcHomePushBcFriendPlayerTogether,
    };
    static const char *extraTextFormatInfo = "\n\000b\210\000\001b\220\000\002b\216\000\003b\224\000\004b\204\346\345\343\342\000\005b\204\345\343\342\000\006b\224\000\007b\226\000\010b\216\000\tb\236\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeCmdId_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeCmdId_IcHomeZero:
    case PB4PHomeCmdId_IcHomePushBcFriend:
    case PB4PHomeCmdId_IcHomePushBubble:
    case PB4PHomeCmdId_IcHomePushBcFriendGame:
    case PB4PHomeCmdId_IcHomeSystemToastCmdId:
    case PB4PHomeCmdId_IcHomeMatchCmdId:
    case PB4PHomeCmdId_IcHomePushUpdateAction:
    case PB4PHomeCmdId_IcHomePushModActionReset:
    case PB4PHomeCmdId_IcHomePushNavRed:
    case PB4PHomeCmdId_IcHomePushBcFriendPlayerTogether:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeSysToastType

GPBEnumDescriptor *PB4PHomeSysToastType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SysToastNormal\000SysToastSucc\000SysToastWarn"
        "\000SysToastError\000";
    static const int32_t values[] = {
        PB4PHomeSysToastType_SysToastNormal,
        PB4PHomeSysToastType_SysToastSucc,
        PB4PHomeSysToastType_SysToastWarn,
        PB4PHomeSysToastType_SysToastError,
    };
    static const char *extraTextFormatInfo = "\004\000\016\000\001\014\000\002\014\000\003\r\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeSysToastType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeSysToastType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeSysToastType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeSysToastType_SysToastNormal:
    case PB4PHomeSysToastType_SysToastSucc:
    case PB4PHomeSysToastType_SysToastWarn:
    case PB4PHomeSysToastType_SysToastError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeModStyle

GPBEnumDescriptor *PB4PHomeModStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HmsStyleZero\000HmsStyleBanner001\000HmsStyleB"
        "anner002\000HmsStyleSubNav\000HmsStylePlayerFa"
        "lls\000HmsStylePlayer3P\000HmsStylePlayerList\000"
        "HmsStyleRoomList\000HmsStyleRoomListSex\000Hms"
        "StyleRoom3Pbig\000HmsStyleRoom3Psmall\000HmsSt"
        "yleRoom2Pbig\000HmsStyleBfbarrage\000HmsStyleB"
        "fscroll\000HmsStyleTjcollection\000HmsStyleMyC"
        "ollection\000HmsStyleMyFootPrint\000HmsStyleOr"
        "derPlayer2Pbig\000HmsStyleBannerList\000HmsSty"
        "leRouter\000HmsStyleActivity\000HmsStyleRankLi"
        "st\000HmsStyleRouterSmall\000HmsStyleRoom2Psma"
        "ll\000HmsStyleNearByList\000HmsStyleNearBy3Psm"
        "all\000HmsStylePlayerInsertTop\000HmsStyleOrde"
        "rPlayer3P\000HmsStyleNearByWithAlbum\000HmsSty"
        "leCommunityTag\000HmsStyleCommunityGroup3Pb"
        "igHead\000HmsStyleCommunityGroupSlide\000HmsSt"
        "yleCommunityGroupList\000HmsStyleCommunityT"
        "rendList\000HmsStyleCommunityGroupTrendList"
        "\000HmsStyleCommunityTrendPublish\000HmsStyleC"
        "ommunityGroupSlideBigHead\000HmsStyleBanner"
        "Matrix24Slide\000HmsStyleBanner3P\000HmsStyleB"
        "anner2P\000HmsStyleRoomListSlide\000HmsStyleNe"
        "arByBigCard\000HmsStylePlayerSoundCard\000HmsS"
        "tyleBfbarrageGame\000HmsStyleBfscrollGame\000H"
        "msStyleRoomLarge\000HmsStyleGameRoomList\000Hm"
        "sStylePlayerSoundCardList\000HmsStyleShowOr"
        "derRoomList\000HmsStyleRoomRadioList\000HmsSty"
        "leBannerAverage3P\000HmsStyleOrderRank\000HmsS"
        "tyleMatching\000HmsStyleCommunityGroupTrend"
        "HotList\000HmsStyleSearchRoomList\000HmsStyleS"
        "earchBanner\000HmsStyleSearchModule\000HmsStyl"
        "eSearchRecord\000HmsStyleSearchRecordRoom\000H"
        "msStyleGameRoomListNew\000HmsStyleGamePlaye"
        "rList\000HmsStyleGamePlayerListOpen\000HmsStyl"
        "ePersonalRecommend\000HmsStyleRoomRecommend"
        "\000HmsStyleLeaveRoomRecommendRowCircle\000Hms"
        "StyleLeaveRoomRecommendColumnCircle\000HmsS"
        "tyleLeaveRoomRecommendRowSquare\000HmsStyle"
        "LeaveRoomRecommendColumnSquare\000HmsStyleB"
        "annerMatrix25Slide\000HmsStyleBannerMatrix1"
        "5\000HmsStyleBannerIrregular4P\000HmsStyleFrie"
        "ndRecommend\000HmsStylePublishHeadlines\000Hms"
        "StyleTopWealth\000HmsStyleTopCharm\000HmsStyle"
        "NobilityUser\000HmsStyleGameGangUp\000HmsStyle"
        "MobaTeamRoom\000HmsStyleBanner690160\000HmsSty"
        "leCommGame\000HmsStyleCommMiss\000HmsStyleComm"
        "Rank\000HmsStyleCommBanner\000HmsStyleCommGame"
        "Single\000HmsStyleCommShowUser\000HmsStyleGame"
        "Slide\000HmsStyleGamePlayNum\000HmsStyleGameDe"
        "sc\000HmsStyleCpblindBox\000HmsStyleVideoCard\000"
        "HmsStyleVideoList\000HmsStyleRankBigImage\000H"
        "msStyleRouter2P\000HmsStyleRouter3P\000HmsStyl"
        "eBubble\000HmsStyleOrderList\000HmsStyleBanner"
        "Matrix44\000HmsStylePlayerListIm\000";
    static const int32_t values[] = {
        PB4PHomeModStyle_HmsStyleZero,
        PB4PHomeModStyle_HmsStyleBanner001,
        PB4PHomeModStyle_HmsStyleBanner002,
        PB4PHomeModStyle_HmsStyleSubNav,
        PB4PHomeModStyle_HmsStylePlayerFalls,
        PB4PHomeModStyle_HmsStylePlayer3P,
        PB4PHomeModStyle_HmsStylePlayerList,
        PB4PHomeModStyle_HmsStyleRoomList,
        PB4PHomeModStyle_HmsStyleRoomListSex,
        PB4PHomeModStyle_HmsStyleRoom3Pbig,
        PB4PHomeModStyle_HmsStyleRoom3Psmall,
        PB4PHomeModStyle_HmsStyleRoom2Pbig,
        PB4PHomeModStyle_HmsStyleBfbarrage,
        PB4PHomeModStyle_HmsStyleBfscroll,
        PB4PHomeModStyle_HmsStyleTjcollection,
        PB4PHomeModStyle_HmsStyleMyCollection,
        PB4PHomeModStyle_HmsStyleMyFootPrint,
        PB4PHomeModStyle_HmsStyleOrderPlayer2Pbig,
        PB4PHomeModStyle_HmsStyleBannerList,
        PB4PHomeModStyle_HmsStyleRouter,
        PB4PHomeModStyle_HmsStyleActivity,
        PB4PHomeModStyle_HmsStyleRankList,
        PB4PHomeModStyle_HmsStyleRouterSmall,
        PB4PHomeModStyle_HmsStyleRoom2Psmall,
        PB4PHomeModStyle_HmsStyleNearByList,
        PB4PHomeModStyle_HmsStyleNearBy3Psmall,
        PB4PHomeModStyle_HmsStylePlayerInsertTop,
        PB4PHomeModStyle_HmsStyleOrderPlayer3P,
        PB4PHomeModStyle_HmsStyleNearByWithAlbum,
        PB4PHomeModStyle_HmsStyleCommunityTag,
        PB4PHomeModStyle_HmsStyleCommunityGroup3PbigHead,
        PB4PHomeModStyle_HmsStyleCommunityGroupSlide,
        PB4PHomeModStyle_HmsStyleCommunityGroupList,
        PB4PHomeModStyle_HmsStyleCommunityTrendList,
        PB4PHomeModStyle_HmsStyleCommunityGroupTrendList,
        PB4PHomeModStyle_HmsStyleCommunityTrendPublish,
        PB4PHomeModStyle_HmsStyleCommunityGroupSlideBigHead,
        PB4PHomeModStyle_HmsStyleBannerMatrix24Slide,
        PB4PHomeModStyle_HmsStyleBanner3P,
        PB4PHomeModStyle_HmsStyleBanner2P,
        PB4PHomeModStyle_HmsStyleRoomListSlide,
        PB4PHomeModStyle_HmsStyleNearByBigCard,
        PB4PHomeModStyle_HmsStylePlayerSoundCard,
        PB4PHomeModStyle_HmsStyleBfbarrageGame,
        PB4PHomeModStyle_HmsStyleBfscrollGame,
        PB4PHomeModStyle_HmsStyleRoomLarge,
        PB4PHomeModStyle_HmsStyleGameRoomList,
        PB4PHomeModStyle_HmsStylePlayerSoundCardList,
        PB4PHomeModStyle_HmsStyleShowOrderRoomList,
        PB4PHomeModStyle_HmsStyleRoomRadioList,
        PB4PHomeModStyle_HmsStyleBannerAverage3P,
        PB4PHomeModStyle_HmsStyleOrderRank,
        PB4PHomeModStyle_HmsStyleMatching,
        PB4PHomeModStyle_HmsStyleCommunityGroupTrendHotList,
        PB4PHomeModStyle_HmsStyleSearchRoomList,
        PB4PHomeModStyle_HmsStyleSearchBanner,
        PB4PHomeModStyle_HmsStyleSearchModule,
        PB4PHomeModStyle_HmsStyleSearchRecord,
        PB4PHomeModStyle_HmsStyleSearchRecordRoom,
        PB4PHomeModStyle_HmsStyleGameRoomListNew,
        PB4PHomeModStyle_HmsStyleGamePlayerList,
        PB4PHomeModStyle_HmsStyleGamePlayerListOpen,
        PB4PHomeModStyle_HmsStylePersonalRecommend,
        PB4PHomeModStyle_HmsStyleRoomRecommend,
        PB4PHomeModStyle_HmsStyleLeaveRoomRecommendRowCircle,
        PB4PHomeModStyle_HmsStyleLeaveRoomRecommendColumnCircle,
        PB4PHomeModStyle_HmsStyleLeaveRoomRecommendRowSquare,
        PB4PHomeModStyle_HmsStyleLeaveRoomRecommendColumnSquare,
        PB4PHomeModStyle_HmsStyleBannerMatrix25Slide,
        PB4PHomeModStyle_HmsStyleBannerMatrix15,
        PB4PHomeModStyle_HmsStyleBannerIrregular4P,
        PB4PHomeModStyle_HmsStyleFriendRecommend,
        PB4PHomeModStyle_HmsStylePublishHeadlines,
        PB4PHomeModStyle_HmsStyleTopWealth,
        PB4PHomeModStyle_HmsStyleTopCharm,
        PB4PHomeModStyle_HmsStyleNobilityUser,
        PB4PHomeModStyle_HmsStyleGameGangUp,
        PB4PHomeModStyle_HmsStyleMobaTeamRoom,
        PB4PHomeModStyle_HmsStyleBanner690160,
        PB4PHomeModStyle_HmsStyleCommGame,
        PB4PHomeModStyle_HmsStyleCommMiss,
        PB4PHomeModStyle_HmsStyleCommRank,
        PB4PHomeModStyle_HmsStyleCommBanner,
        PB4PHomeModStyle_HmsStyleCommGameSingle,
        PB4PHomeModStyle_HmsStyleCommShowUser,
        PB4PHomeModStyle_HmsStyleGameSlide,
        PB4PHomeModStyle_HmsStyleGamePlayNum,
        PB4PHomeModStyle_HmsStyleGameDesc,
        PB4PHomeModStyle_HmsStyleCpblindBox,
        PB4PHomeModStyle_HmsStyleVideoCard,
        PB4PHomeModStyle_HmsStyleVideoList,
        PB4PHomeModStyle_HmsStyleRankBigImage,
        PB4PHomeModStyle_HmsStyleRouter2P,
        PB4PHomeModStyle_HmsStyleRouter3P,
        PB4PHomeModStyle_HmsStyleBubble,
        PB4PHomeModStyle_HmsStyleOrderList,
        PB4PHomeModStyle_HmsStyleBannerMatrix44,
        PB4PHomeModStyle_HmsStylePlayerListIm,
    };
    static const char *extraTextFormatInfo = "b\000c\211\000\001c\213\203\000\002c\213\203\000\003c\213\000\004c\220\000\005c\215\000\006c\217\000\007c\215\000\010c\220\000\tc\213C\000\nc\213E\000\013c\213C\000\014c\206b\006\000\rc\206b\005\000\016c\206b\t\000\017c\221\000\020c\220\000\021c\222C\000\022c\217\000\023c\213\000\024c\215\000\025c\215\000\026c\220\000\027c\213E\000\030c\217\000\031c\215E\000\032c\224\000\033c\222\000\034c\224\000\035c\221\000\036c\225G\000\037c\230\000 c\227\000!c\227\000\"c\234\000#c\232\000$c\237\000%c\230\000&c\215\000\'c\215\000(c\222\000)c\222\000*c\224\000+c\206b\n\000,c\206b\t\000-c\216\000.c\221\000/c\230\0000c\226\0001c\222\0002c\224\0003c\216\0004c\215\0005c\237\0006c\223\0007c\221\0008c\221\0009c\221\000:c\225\000;c\224\000<c\223\000=c\227\000>c\226\000?c\222\000@c\237\001\000Ac\237\004\000Bc\237\001\000Cc\237\004\000Dc\230\000Ec\223\000Fc\226\000Gc\224\000Hc\225\000Ic\216\000Jc\215\000Kc\221\000Lc\217\000Mc\221\000Nc\213\203\203\000Oc\215\000Pc\215\000Qc\215\000Rc\217\000Sc\223\000Tc\221\000Uc\211\205\000Vc\211\207\000Wc\211\204\000Xc\206b\007\000Yc\216\000Zc\216\000[c\221\000\\c\215\000]c\215\000^c\213\000_c\216\000`c\223\000ac\220A\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeModStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeModStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeModStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeModStyle_HmsStyleZero:
    case PB4PHomeModStyle_HmsStyleBanner001:
    case PB4PHomeModStyle_HmsStyleBanner002:
    case PB4PHomeModStyle_HmsStyleSubNav:
    case PB4PHomeModStyle_HmsStylePlayerFalls:
    case PB4PHomeModStyle_HmsStylePlayer3P:
    case PB4PHomeModStyle_HmsStylePlayerList:
    case PB4PHomeModStyle_HmsStyleRoomList:
    case PB4PHomeModStyle_HmsStyleRoomListSex:
    case PB4PHomeModStyle_HmsStyleRoom3Pbig:
    case PB4PHomeModStyle_HmsStyleRoom3Psmall:
    case PB4PHomeModStyle_HmsStyleRoom2Pbig:
    case PB4PHomeModStyle_HmsStyleBfbarrage:
    case PB4PHomeModStyle_HmsStyleBfscroll:
    case PB4PHomeModStyle_HmsStyleTjcollection:
    case PB4PHomeModStyle_HmsStyleMyCollection:
    case PB4PHomeModStyle_HmsStyleMyFootPrint:
    case PB4PHomeModStyle_HmsStyleOrderPlayer2Pbig:
    case PB4PHomeModStyle_HmsStyleBannerList:
    case PB4PHomeModStyle_HmsStyleRouter:
    case PB4PHomeModStyle_HmsStyleActivity:
    case PB4PHomeModStyle_HmsStyleRankList:
    case PB4PHomeModStyle_HmsStyleRouterSmall:
    case PB4PHomeModStyle_HmsStyleRoom2Psmall:
    case PB4PHomeModStyle_HmsStyleNearByList:
    case PB4PHomeModStyle_HmsStyleNearBy3Psmall:
    case PB4PHomeModStyle_HmsStylePlayerInsertTop:
    case PB4PHomeModStyle_HmsStyleOrderPlayer3P:
    case PB4PHomeModStyle_HmsStyleNearByWithAlbum:
    case PB4PHomeModStyle_HmsStyleCommunityTag:
    case PB4PHomeModStyle_HmsStyleCommunityGroup3PbigHead:
    case PB4PHomeModStyle_HmsStyleCommunityGroupSlide:
    case PB4PHomeModStyle_HmsStyleCommunityGroupList:
    case PB4PHomeModStyle_HmsStyleCommunityTrendList:
    case PB4PHomeModStyle_HmsStyleCommunityGroupTrendList:
    case PB4PHomeModStyle_HmsStyleCommunityTrendPublish:
    case PB4PHomeModStyle_HmsStyleCommunityGroupSlideBigHead:
    case PB4PHomeModStyle_HmsStyleBannerMatrix24Slide:
    case PB4PHomeModStyle_HmsStyleBanner3P:
    case PB4PHomeModStyle_HmsStyleBanner2P:
    case PB4PHomeModStyle_HmsStyleRoomListSlide:
    case PB4PHomeModStyle_HmsStyleNearByBigCard:
    case PB4PHomeModStyle_HmsStylePlayerSoundCard:
    case PB4PHomeModStyle_HmsStyleBfbarrageGame:
    case PB4PHomeModStyle_HmsStyleBfscrollGame:
    case PB4PHomeModStyle_HmsStyleRoomLarge:
    case PB4PHomeModStyle_HmsStyleGameRoomList:
    case PB4PHomeModStyle_HmsStylePlayerSoundCardList:
    case PB4PHomeModStyle_HmsStyleShowOrderRoomList:
    case PB4PHomeModStyle_HmsStyleRoomRadioList:
    case PB4PHomeModStyle_HmsStyleBannerAverage3P:
    case PB4PHomeModStyle_HmsStyleOrderRank:
    case PB4PHomeModStyle_HmsStyleMatching:
    case PB4PHomeModStyle_HmsStyleCommunityGroupTrendHotList:
    case PB4PHomeModStyle_HmsStyleSearchRoomList:
    case PB4PHomeModStyle_HmsStyleSearchBanner:
    case PB4PHomeModStyle_HmsStyleSearchModule:
    case PB4PHomeModStyle_HmsStyleSearchRecord:
    case PB4PHomeModStyle_HmsStyleSearchRecordRoom:
    case PB4PHomeModStyle_HmsStyleGameRoomListNew:
    case PB4PHomeModStyle_HmsStyleGamePlayerList:
    case PB4PHomeModStyle_HmsStyleGamePlayerListOpen:
    case PB4PHomeModStyle_HmsStylePersonalRecommend:
    case PB4PHomeModStyle_HmsStyleRoomRecommend:
    case PB4PHomeModStyle_HmsStyleLeaveRoomRecommendRowCircle:
    case PB4PHomeModStyle_HmsStyleLeaveRoomRecommendColumnCircle:
    case PB4PHomeModStyle_HmsStyleLeaveRoomRecommendRowSquare:
    case PB4PHomeModStyle_HmsStyleLeaveRoomRecommendColumnSquare:
    case PB4PHomeModStyle_HmsStyleBannerMatrix25Slide:
    case PB4PHomeModStyle_HmsStyleBannerMatrix15:
    case PB4PHomeModStyle_HmsStyleBannerIrregular4P:
    case PB4PHomeModStyle_HmsStyleFriendRecommend:
    case PB4PHomeModStyle_HmsStylePublishHeadlines:
    case PB4PHomeModStyle_HmsStyleTopWealth:
    case PB4PHomeModStyle_HmsStyleTopCharm:
    case PB4PHomeModStyle_HmsStyleNobilityUser:
    case PB4PHomeModStyle_HmsStyleGameGangUp:
    case PB4PHomeModStyle_HmsStyleMobaTeamRoom:
    case PB4PHomeModStyle_HmsStyleBanner690160:
    case PB4PHomeModStyle_HmsStyleCommGame:
    case PB4PHomeModStyle_HmsStyleCommMiss:
    case PB4PHomeModStyle_HmsStyleCommRank:
    case PB4PHomeModStyle_HmsStyleCommBanner:
    case PB4PHomeModStyle_HmsStyleCommGameSingle:
    case PB4PHomeModStyle_HmsStyleCommShowUser:
    case PB4PHomeModStyle_HmsStyleGameSlide:
    case PB4PHomeModStyle_HmsStyleGamePlayNum:
    case PB4PHomeModStyle_HmsStyleGameDesc:
    case PB4PHomeModStyle_HmsStyleCpblindBox:
    case PB4PHomeModStyle_HmsStyleVideoCard:
    case PB4PHomeModStyle_HmsStyleVideoList:
    case PB4PHomeModStyle_HmsStyleRankBigImage:
    case PB4PHomeModStyle_HmsStyleRouter2P:
    case PB4PHomeModStyle_HmsStyleRouter3P:
    case PB4PHomeModStyle_HmsStyleBubble:
    case PB4PHomeModStyle_HmsStyleOrderList:
    case PB4PHomeModStyle_HmsStyleBannerMatrix44:
    case PB4PHomeModStyle_HmsStylePlayerListIm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeMoreRule

GPBEnumDescriptor *PB4PHomeMoreRule_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HmrRuleNone\000HmrRuleSubPage\000HmrRuleNextPa"
        "ge\000HmrRuleRefre\000HmrRuleFole\000HmrRuleClean"
        "\000HmrRuleModClassify\000HmrRuleModBcFriend\000H"
        "mrRuleModMyZone\000HmrRuleModRecommend\000HmrR"
        "uleModRoute\000HmrRuleModBubble\000HmrRuleSubP"
        "ageGame\000";
    static const int32_t values[] = {
        PB4PHomeMoreRule_HmrRuleNone,
        PB4PHomeMoreRule_HmrRuleSubPage,
        PB4PHomeMoreRule_HmrRuleNextPage,
        PB4PHomeMoreRule_HmrRuleRefre,
        PB4PHomeMoreRule_HmrRuleFole,
        PB4PHomeMoreRule_HmrRuleClean,
        PB4PHomeMoreRule_HmrRuleModClassify,
        PB4PHomeMoreRule_HmrRuleModBcFriend,
        PB4PHomeMoreRule_HmrRuleModMyZone,
        PB4PHomeMoreRule_HmrRuleModRecommend,
        PB4PHomeMoreRule_HmrRuleModRoute,
        PB4PHomeMoreRule_HmrRuleModBubble,
        PB4PHomeMoreRule_HmrRuleSubPageGame,
    };
    static const char *extraTextFormatInfo = "\r\000c\210\000\001c\213\000\002c\214\000\003c\211\000\004c\210\000\005c\211\000\006c\217\000\007c\217\000\010c\215\000\tc\220\000\nc\214\000\013c\215\000\014c\217\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeMoreRule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeMoreRule_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeMoreRule_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeMoreRule_HmrRuleNone:
    case PB4PHomeMoreRule_HmrRuleSubPage:
    case PB4PHomeMoreRule_HmrRuleNextPage:
    case PB4PHomeMoreRule_HmrRuleRefre:
    case PB4PHomeMoreRule_HmrRuleFole:
    case PB4PHomeMoreRule_HmrRuleClean:
    case PB4PHomeMoreRule_HmrRuleModClassify:
    case PB4PHomeMoreRule_HmrRuleModBcFriend:
    case PB4PHomeMoreRule_HmrRuleModMyZone:
    case PB4PHomeMoreRule_HmrRuleModRecommend:
    case PB4PHomeMoreRule_HmrRuleModRoute:
    case PB4PHomeMoreRule_HmrRuleModBubble:
    case PB4PHomeMoreRule_HmrRuleSubPageGame:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeShowStatus

GPBEnumDescriptor *PB4PHomeShowStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HssShowNone\000HssShowNormal\000HssShowFole\000";
    static const int32_t values[] = {
        PB4PHomeShowStatus_HssShowNone,
        PB4PHomeShowStatus_HssShowNormal,
        PB4PHomeShowStatus_HssShowFole,
    };
    static const char *extraTextFormatInfo = "\003\000c\210\000\001c\212\000\002c\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeShowStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeShowStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeShowStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeShowStatus_HssShowNone:
    case PB4PHomeShowStatus_HssShowNormal:
    case PB4PHomeShowStatus_HssShowFole:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeDataType

GPBEnumDescriptor *PB4PHomeDataType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HdtDataTypeNone\000HdtDataTypeRoom\000HdtDataT"
        "ypePlayer\000HdtDataTypeBanner\000HdtDataTypeS"
        "ubNav\000HdtDataTypeBcFriend\000HdtDataTypeRou"
        "ter\000HdtDataTypeRank\000HdtDataTypeActivity\000"
        "HdtDateTypeCommunityTag\000HdtDateTypeCommu"
        "nityGroup\000HdtDateTypeCommunityTrend\000HdtD"
        "ateTypeCommunityGroupDetail\000HdtDataTypeB"
        "ubble\000HdtDataTypeBcFriendGame\000HdtDateTyp"
        "eRadioStation\000HdtDataTypeBcFriendGameGan"
        "gUp\000HdtDataTypeCommGame\000HdtDataTypeCommM"
        "iss\000HdtDataTypeCommRank\000HdtDataTypeCommG"
        "ameSingle\000HdtDataTypeCommShowUser\000HdtDat"
        "aTypeGame\000HdtDataTypeCpinfoFish\000HdtDataT"
        "ypeCpinfo\000";
    static const int32_t values[] = {
        PB4PHomeDataType_HdtDataTypeNone,
        PB4PHomeDataType_HdtDataTypeRoom,
        PB4PHomeDataType_HdtDataTypePlayer,
        PB4PHomeDataType_HdtDataTypeBanner,
        PB4PHomeDataType_HdtDataTypeSubNav,
        PB4PHomeDataType_HdtDataTypeBcFriend,
        PB4PHomeDataType_HdtDataTypeRouter,
        PB4PHomeDataType_HdtDataTypeRank,
        PB4PHomeDataType_HdtDataTypeActivity,
        PB4PHomeDataType_HdtDateTypeCommunityTag,
        PB4PHomeDataType_HdtDateTypeCommunityGroup,
        PB4PHomeDataType_HdtDateTypeCommunityTrend,
        PB4PHomeDataType_HdtDateTypeCommunityGroupDetail,
        PB4PHomeDataType_HdtDataTypeBubble,
        PB4PHomeDataType_HdtDataTypeBcFriendGame,
        PB4PHomeDataType_HdtDateTypeRadioStation,
        PB4PHomeDataType_HdtDataTypeBcFriendGameGangUp,
        PB4PHomeDataType_HdtDataTypeCommGame,
        PB4PHomeDataType_HdtDataTypeCommMiss,
        PB4PHomeDataType_HdtDataTypeCommRank,
        PB4PHomeDataType_HdtDataTypeCommGameSingle,
        PB4PHomeDataType_HdtDataTypeCommShowUser,
        PB4PHomeDataType_HdtDataTypeGame,
        PB4PHomeDataType_HdtDataTypeCpinfoFish,
        PB4PHomeDataType_HdtDataTypeCpinfo,
    };
    static const char *extraTextFormatInfo = "\031\000c\214\000\001c\214\000\002c\216\000\003c\216\000\004c\216\000\005c\220\000\006c\216\000\007c\214\000\010c\220\000\tc\224\000\nc\226\000\013c\226\000\014c\234\000\rc\216\000\016c\224\000\017c\224\000\020c\232\000\021c\220\000\022c\220\000\023c\220\000\024c\226\000\025c\224\000\026c\214\000\027c\211b\007\000\030c\211b\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeDataType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeDataType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeDataType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeDataType_HdtDataTypeNone:
    case PB4PHomeDataType_HdtDataTypeRoom:
    case PB4PHomeDataType_HdtDataTypePlayer:
    case PB4PHomeDataType_HdtDataTypeBanner:
    case PB4PHomeDataType_HdtDataTypeSubNav:
    case PB4PHomeDataType_HdtDataTypeBcFriend:
    case PB4PHomeDataType_HdtDataTypeRouter:
    case PB4PHomeDataType_HdtDataTypeRank:
    case PB4PHomeDataType_HdtDataTypeActivity:
    case PB4PHomeDataType_HdtDateTypeCommunityTag:
    case PB4PHomeDataType_HdtDateTypeCommunityGroup:
    case PB4PHomeDataType_HdtDateTypeCommunityTrend:
    case PB4PHomeDataType_HdtDateTypeCommunityGroupDetail:
    case PB4PHomeDataType_HdtDataTypeBubble:
    case PB4PHomeDataType_HdtDataTypeBcFriendGame:
    case PB4PHomeDataType_HdtDateTypeRadioStation:
    case PB4PHomeDataType_HdtDataTypeBcFriendGameGangUp:
    case PB4PHomeDataType_HdtDataTypeCommGame:
    case PB4PHomeDataType_HdtDataTypeCommMiss:
    case PB4PHomeDataType_HdtDataTypeCommRank:
    case PB4PHomeDataType_HdtDataTypeCommGameSingle:
    case PB4PHomeDataType_HdtDataTypeCommShowUser:
    case PB4PHomeDataType_HdtDataTypeGame:
    case PB4PHomeDataType_HdtDataTypeCpinfoFish:
    case PB4PHomeDataType_HdtDataTypeCpinfo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeRouteType

GPBEnumDescriptor *PB4PHomeRouteType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HdtRouteTypeNone\000HdtRouteTypeId\000HdtRoute"
        "TypeSubPage\000HdtRouteTypeDefine\000HdtRouteT"
        "ypeMiwoZero\000HdtRouteTypeEnterRoom\000HdtRou"
        "teTypePlayerCard\000HdtRouteTypeImchat\000HdtR"
        "outeTypeMiwoOne\000HdtRouteTypeSkill\000HdtRou"
        "teTypeCommGame\000HdtRouteTypeCommRank\000HdtR"
        "outeTypeCommMiss\000HdtRouteTypeCommBanner\000";
    static const int32_t values[] = {
        PB4PHomeRouteType_HdtRouteTypeNone,
        PB4PHomeRouteType_HdtRouteTypeId,
        PB4PHomeRouteType_HdtRouteTypeSubPage,
        PB4PHomeRouteType_HdtRouteTypeDefine,
        PB4PHomeRouteType_HdtRouteTypeMiwoZero,
        PB4PHomeRouteType_HdtRouteTypeEnterRoom,
        PB4PHomeRouteType_HdtRouteTypePlayerCard,
        PB4PHomeRouteType_HdtRouteTypeImchat,
        PB4PHomeRouteType_HdtRouteTypeMiwoOne,
        PB4PHomeRouteType_HdtRouteTypeSkill,
        PB4PHomeRouteType_HdtRouteTypeCommGame,
        PB4PHomeRouteType_HdtRouteTypeCommRank,
        PB4PHomeRouteType_HdtRouteTypeCommMiss,
        PB4PHomeRouteType_HdtRouteTypeCommBanner,
    };
    static const char *extraTextFormatInfo = "\016\000c\215\000\001c\212A\000\002c\220\000\003c\217\000\004c\221\000\005c\222\000\006c\223\000\007c\212b\003\000\010c\220\000\tc\216\000\nc\221\000\013c\221\000\014c\221\000\rc\223\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeRouteType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeRouteType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeRouteType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeRouteType_HdtRouteTypeNone:
    case PB4PHomeRouteType_HdtRouteTypeId:
    case PB4PHomeRouteType_HdtRouteTypeSubPage:
    case PB4PHomeRouteType_HdtRouteTypeDefine:
    case PB4PHomeRouteType_HdtRouteTypeMiwoZero:
    case PB4PHomeRouteType_HdtRouteTypeEnterRoom:
    case PB4PHomeRouteType_HdtRouteTypePlayerCard:
    case PB4PHomeRouteType_HdtRouteTypeImchat:
    case PB4PHomeRouteType_HdtRouteTypeMiwoOne:
    case PB4PHomeRouteType_HdtRouteTypeSkill:
    case PB4PHomeRouteType_HdtRouteTypeCommGame:
    case PB4PHomeRouteType_HdtRouteTypeCommRank:
    case PB4PHomeRouteType_HdtRouteTypeCommMiss:
    case PB4PHomeRouteType_HdtRouteTypeCommBanner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeClassify

GPBEnumDescriptor *PB4PHomeClassify_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HmcClassifyNone\000HmcClassifySexAll\000HmcCla"
        "ssifyAllMale\000HmcClassifyAllFemale\000";
    static const int32_t values[] = {
        PB4PHomeClassify_HmcClassifyNone,
        PB4PHomeClassify_HmcClassifySexAll,
        PB4PHomeClassify_HmcClassifyAllMale,
        PB4PHomeClassify_HmcClassifyAllFemale,
    };
    static const char *extraTextFormatInfo = "\004\000c\214\000\001c\216\000\002c\217\000\003c\221\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeClassify)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeClassify_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeClassify_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeClassify_HmcClassifyNone:
    case PB4PHomeClassify_HmcClassifySexAll:
    case PB4PHomeClassify_HmcClassifyAllMale:
    case PB4PHomeClassify_HmcClassifyAllFemale:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeExtraType

GPBEnumDescriptor *PB4PHomeExtraType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HmcExtraTypeNone\000HmcExtraTypeAll\000HmcExtr"
        "aTypePeople\000HmcExtraTypeRoom\000";
    static const int32_t values[] = {
        PB4PHomeExtraType_HmcExtraTypeNone,
        PB4PHomeExtraType_HmcExtraTypeAll,
        PB4PHomeExtraType_HmcExtraTypePeople,
        PB4PHomeExtraType_HmcExtraTypeRoom,
    };
    static const char *extraTextFormatInfo = "\004\000c\215\000\001c\214\000\002c\217\000\003c\215\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeExtraType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeExtraType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeExtraType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeExtraType_HmcExtraTypeNone:
    case PB4PHomeExtraType_HmcExtraTypeAll:
    case PB4PHomeExtraType_HmcExtraTypePeople:
    case PB4PHomeExtraType_HmcExtraTypeRoom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeNavStyle

GPBEnumDescriptor *PB4PHomeNavStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HmcNavStyleNone\000HmcNavStyleNearBy\000";
    static const int32_t values[] = {
        PB4PHomeNavStyle_HmcNavStyleNone,
        PB4PHomeNavStyle_HmcNavStyleNearBy,
    };
    static const char *extraTextFormatInfo = "\002\000c\214\000\001c\216\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeNavStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeNavStyle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeNavStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeNavStyle_HmcNavStyleNone:
    case PB4PHomeNavStyle_HmcNavStyleNearBy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PluginRankType

GPBEnumDescriptor *PB4PluginRankType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PrtZero\000PrtCharmDay\000PrtCharmWeek\000PrtChar"
        "mAll\000PrtWealthDay\000PrtWealthWeek\000PrtWealt"
        "hAll\000PrtGiftAll\000PrtWeekStar\000PrtCharmYear"
        "\000PrtWealthYear\000PrtOrderRank\000PrtGirlWealt"
        "hHour\000PrtManWealthHour\000PrtGirlCharmHour\000"
        "PrtManCharmHour\000";
    static const int32_t values[] = {
        PB4PluginRankType_PrtZero,
        PB4PluginRankType_PrtCharmDay,
        PB4PluginRankType_PrtCharmWeek,
        PB4PluginRankType_PrtCharmAll,
        PB4PluginRankType_PrtWealthDay,
        PB4PluginRankType_PrtWealthWeek,
        PB4PluginRankType_PrtWealthAll,
        PB4PluginRankType_PrtGiftAll,
        PB4PluginRankType_PrtWeekStar,
        PB4PluginRankType_PrtCharmYear,
        PB4PluginRankType_PrtWealthYear,
        PB4PluginRankType_PrtOrderRank,
        PB4PluginRankType_PrtGirlWealthHour,
        PB4PluginRankType_PrtManWealthHour,
        PB4PluginRankType_PrtGirlCharmHour,
        PB4PluginRankType_PrtManCharmHour,
    };
    static const char *extraTextFormatInfo = "\017\001c\210\000\002c\211\000\003c\210\000\004c\211\000\005c\212\000\006c\211\000\007c\207\000\010c\210\000\tc\211\000\nc\212\000\013c\211\000\014c\216\000\rc\215\000\016c\215\000\017c\214\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PluginRankType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PluginRankType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PluginRankType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PluginRankType_PrtZero:
    case PB4PluginRankType_PrtCharmDay:
    case PB4PluginRankType_PrtCharmWeek:
    case PB4PluginRankType_PrtCharmAll:
    case PB4PluginRankType_PrtWealthDay:
    case PB4PluginRankType_PrtWealthWeek:
    case PB4PluginRankType_PrtWealthAll:
    case PB4PluginRankType_PrtGiftAll:
    case PB4PluginRankType_PrtWeekStar:
    case PB4PluginRankType_PrtCharmYear:
    case PB4PluginRankType_PrtWealthYear:
    case PB4PluginRankType_PrtOrderRank:
    case PB4PluginRankType_PrtGirlWealthHour:
    case PB4PluginRankType_PrtManWealthHour:
    case PB4PluginRankType_PrtGirlCharmHour:
    case PB4PluginRankType_PrtManCharmHour:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4MatchDirectType

GPBEnumDescriptor *PB4MatchDirectType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MatchDirectTypeDefault\000MatchDirectTypeRo"
        "om\000MatchDirectTypeChat\000MatchDirectTypeMo"
        "d\000MatchDirectTypeGame\000MatchDirectTypeCon"
        "tinue\000MatchDirectTypeNotice\000MatchDirectT"
        "ypeFollow\000MatchDirectTypeLink\000";
    static const int32_t values[] = {
        PB4MatchDirectType_MatchDirectTypeDefault,
        PB4MatchDirectType_MatchDirectTypeRoom,
        PB4MatchDirectType_MatchDirectTypeChat,
        PB4MatchDirectType_MatchDirectTypeMod,
        PB4MatchDirectType_MatchDirectTypeGame,
        PB4MatchDirectType_MatchDirectTypeContinue,
        PB4MatchDirectType_MatchDirectTypeNotice,
        PB4MatchDirectType_MatchDirectTypeFollow,
        PB4MatchDirectType_MatchDirectTypeLink,
    };
    static const char *extraTextFormatInfo = "\t\000\026\000\001\023\000\002\023\000\003\022\000\004\023\000\005\027\000\006\025\000\007\025\000\010\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4MatchDirectType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4MatchDirectType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4MatchDirectType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4MatchDirectType_MatchDirectTypeDefault:
    case PB4MatchDirectType_MatchDirectTypeRoom:
    case PB4MatchDirectType_MatchDirectTypeChat:
    case PB4MatchDirectType_MatchDirectTypeMod:
    case PB4MatchDirectType_MatchDirectTypeGame:
    case PB4MatchDirectType_MatchDirectTypeContinue:
    case PB4MatchDirectType_MatchDirectTypeNotice:
    case PB4MatchDirectType_MatchDirectTypeFollow:
    case PB4MatchDirectType_MatchDirectTypeLink:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4MatchStatusType

GPBEnumDescriptor *PB4MatchStatusType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MatchStatusTypeDefault\000MatchStatusTypeIn"
        "g\000MatchStatusCancel\000";
    static const int32_t values[] = {
        PB4MatchStatusType_MatchStatusTypeDefault,
        PB4MatchStatusType_MatchStatusTypeIng,
        PB4MatchStatusType_MatchStatusCancel,
    };
    static const char *extraTextFormatInfo = "\003\000\026\000\001\022\000\002\021\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4MatchStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4MatchStatusType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4MatchStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4MatchStatusType_MatchStatusTypeDefault:
    case PB4MatchStatusType_MatchStatusTypeIng:
    case PB4MatchStatusType_MatchStatusCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4QuickGamePreType

GPBEnumDescriptor *PB4QuickGamePreType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "QuickGamePreTypeDefault\000QuickGamePreType"
        "Ing\000";
    static const int32_t values[] = {
        PB4QuickGamePreType_QuickGamePreTypeDefault,
        PB4QuickGamePreType_QuickGamePreTypeIng,
    };
    static const char *extraTextFormatInfo = "\002\000\027\000\001\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4QuickGamePreType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4QuickGamePreType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4QuickGamePreType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4QuickGamePreType_QuickGamePreTypeDefault:
    case PB4QuickGamePreType_QuickGamePreTypeIng:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeEntryRoomExtendKey

GPBEnumDescriptor *PB4PHomeEntryRoomExtendKey_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PerekNone\000PerekGameIcon\000PerekGameBgURL\000";
    static const int32_t values[] = {
        PB4PHomeEntryRoomExtendKey_PerekNone,
        PB4PHomeEntryRoomExtendKey_PerekGameIcon,
        PB4PHomeEntryRoomExtendKey_PerekGameBgURL,
    };
    static const char *extraTextFormatInfo = "\001\002e\344\342\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeEntryRoomExtendKey)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeEntryRoomExtendKey_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeEntryRoomExtendKey_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeEntryRoomExtendKey_PerekNone:
    case PB4PHomeEntryRoomExtendKey_PerekGameIcon:
    case PB4PHomeEntryRoomExtendKey_PerekGameBgURL:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PGameRoomStatusTypeExt

GPBEnumDescriptor *PB4PGameRoomStatusTypeExt_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ExtPgrstNone\000ExtPgrstWait\000ExtPgrstPlayin"
        "g\000";
    static const int32_t values[] = {
        PB4PGameRoomStatusTypeExt_ExtPgrstNone,
        PB4PGameRoomStatusTypeExt_ExtPgrstWait,
        PB4PGameRoomStatusTypeExt_ExtPgrstPlaying,
    };
    static const char *extraTextFormatInfo = "\003\000c\345\204\000\001c\345\204\000\002c\345\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PGameRoomStatusTypeExt)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PGameRoomStatusTypeExt_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PGameRoomStatusTypeExt_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PGameRoomStatusTypeExt_ExtPgrstNone:
    case PB4PGameRoomStatusTypeExt_ExtPgrstWait:
    case PB4PGameRoomStatusTypeExt_ExtPgrstPlaying:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PGamePlayerStatusTypeExt

GPBEnumDescriptor *PB4PGamePlayerStatusTypeExt_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ExtPgpstNone\000ExtPgpstUnReady\000ExtPgpstRea"
        "dy\000ExtPgpstStart\000";
    static const int32_t values[] = {
        PB4PGamePlayerStatusTypeExt_ExtPgpstNone,
        PB4PGamePlayerStatusTypeExt_ExtPgpstUnReady,
        PB4PGamePlayerStatusTypeExt_ExtPgpstReady,
        PB4PGamePlayerStatusTypeExt_ExtPgpstStart,
    };
    static const char *extraTextFormatInfo = "\004\000c\345\204\000\001c\345\207\000\002c\345\205\000\003c\345\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PGamePlayerStatusTypeExt)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PGamePlayerStatusTypeExt_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PGamePlayerStatusTypeExt_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PGamePlayerStatusTypeExt_ExtPgpstNone:
    case PB4PGamePlayerStatusTypeExt_ExtPgpstUnReady:
    case PB4PGamePlayerStatusTypeExt_ExtPgpstReady:
    case PB4PGamePlayerStatusTypeExt_ExtPgpstStart:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4PHomeExtendKey

GPBEnumDescriptor *PB4PHomeExtendKey_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PekNone\000PekGameBgBro\000PekGameFrameBro\000Pek"
        "GameFrameColor\000PekCarId\000PekGameBgBroPc\000";
    static const int32_t values[] = {
        PB4PHomeExtendKey_PekNone,
        PB4PHomeExtendKey_PekGameBgBro,
        PB4PHomeExtendKey_PekGameFrameBro,
        PB4PHomeExtendKey_PekGameFrameColor,
        PB4PHomeExtendKey_PekCarId,
        PB4PHomeExtendKey_PekGameBgBroPc,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4PHomeExtendKey)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4PHomeExtendKey_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4PHomeExtendKey_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4PHomeExtendKey_PekNone:
    case PB4PHomeExtendKey_PekGameBgBro:
    case PB4PHomeExtendKey_PekGameFrameBro:
    case PB4PHomeExtendKey_PekGameFrameColor:
    case PB4PHomeExtendKey_PekCarId:
    case PB4PHomeExtendKey_PekGameBgBroPc:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4BF_RECORD_TYPE

GPBEnumDescriptor *PB4BF_RECORD_TYPE_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BfrtNormal\000BfrtTiaoTiao\000BfrtWorldGift\000";
    static const int32_t values[] = {
        PB4BF_RECORD_TYPE_BfrtNormal,
        PB4BF_RECORD_TYPE_BfrtTiaoTiao,
        PB4BF_RECORD_TYPE_BfrtWorldGift,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4BF_RECORD_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4BF_RECORD_TYPE_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4BF_RECORD_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4BF_RECORD_TYPE_BfrtNormal:
    case PB4BF_RECORD_TYPE_BfrtTiaoTiao:
    case PB4BF_RECORD_TYPE_BfrtWorldGift:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4BannerPosition

GPBEnumDescriptor *PB4BannerPosition_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BpZero\000BpLeftTop\000BpRightTop\000BpLeftBottom"
        "\000BpRightBottom\000";
    static const int32_t values[] = {
        PB4BannerPosition_BpZero,
        PB4BannerPosition_BpLeftTop,
        PB4BannerPosition_BpRightTop,
        PB4BannerPosition_BpLeftBottom,
        PB4BannerPosition_BpRightBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4BannerPosition)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4BannerPosition_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4BannerPosition_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4BannerPosition_BpZero:
    case PB4BannerPosition_BpLeftTop:
    case PB4BannerPosition_BpRightTop:
    case PB4BannerPosition_BpLeftBottom:
    case PB4BannerPosition_BpRightBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4HomeType

GPBEnumDescriptor *PB4HomeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HtIndex\000HtCommunity\000HtDiscovery\000HtSearch"
        "Id\000HtSearchRoom\000HtLeaveRoom\000";
    static const int32_t values[] = {
        PB4HomeType_HtIndex,
        PB4HomeType_HtCommunity,
        PB4HomeType_HtDiscovery,
        PB4HomeType_HtSearchId,
        PB4HomeType_HtSearchRoom,
        PB4HomeType_HtLeaveRoom,
    };
    static const char *extraTextFormatInfo = "\006\000b\205\000\001b\211\000\002b\211\000\003b\206\202\000\004b\206\204\000\005b\205\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4HomeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4HomeType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4HomeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4HomeType_HtIndex:
    case PB4HomeType_HtCommunity:
    case PB4HomeType_HtDiscovery:
    case PB4HomeType_HtSearchId:
    case PB4HomeType_HtSearchRoom:
    case PB4HomeType_HtLeaveRoom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4ClearFootType

GPBEnumDescriptor *PB4ClearFootType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CftNone\000CftCommunityGroup\000";
    static const int32_t values[] = {
        PB4ClearFootType_CftNone,
        PB4ClearFootType_CftCommunityGroup,
    };
    static const char *extraTextFormatInfo = "\002\000c\204\000\001c\216\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4ClearFootType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4ClearFootType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4ClearFootType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4ClearFootType_CftNone:
    case PB4ClearFootType_CftCommunityGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4ExtraModType

GPBEnumDescriptor *PB4ExtraModType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EmtNone\000EmtSearchPlayerBanner\000EmtSearchR"
        "oomBanner\000EmtRecentRoom\000EmtRadioStation\000"
        "EmtImNearby\000EmtBillEvaluateBanner\000EmtAct"
        "ivityDialogBanner\000EmtClanBanner\000EmtMiniP"
        "rogramRoom\000";
    static const int32_t values[] = {
        PB4ExtraModType_EmtNone,
        PB4ExtraModType_EmtSearchPlayerBanner,
        PB4ExtraModType_EmtSearchRoomBanner,
        PB4ExtraModType_EmtRecentRoom,
        PB4ExtraModType_EmtRadioStation,
        PB4ExtraModType_EmtImNearby,
        PB4ExtraModType_EmtBillEvaluateBanner,
        PB4ExtraModType_EmtActivityDialogBanner,
        PB4ExtraModType_EmtClanBanner,
        PB4ExtraModType_EmtMiniProgramRoom,
    };
    static const char *extraTextFormatInfo = "\001\006c\204\210\346\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4ExtraModType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4ExtraModType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4ExtraModType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4ExtraModType_EmtNone:
    case PB4ExtraModType_EmtSearchPlayerBanner:
    case PB4ExtraModType_EmtSearchRoomBanner:
    case PB4ExtraModType_EmtRecentRoom:
    case PB4ExtraModType_EmtRadioStation:
    case PB4ExtraModType_EmtImNearby:
    case PB4ExtraModType_EmtBillEvaluateBanner:
    case PB4ExtraModType_EmtActivityDialogBanner:
    case PB4ExtraModType_EmtClanBanner:
    case PB4ExtraModType_EmtMiniProgramRoom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4TabType

GPBEnumDescriptor *PB4TabType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TabTypeNone\000TabTypeEntertainment\000TabType"
        "RankingList\000TabTypeMine\000TabTypeCommunity"
        "\000TabTypeMessage\000TabTypeMediaPlayer\000TabTy"
        "peDiscovery\000TabTypeMatch\000TabTypeRoute\000Ta"
        "bTypeWipe\000";
    static const int32_t values[] = {
        PB4TabType_TabTypeNone,
        PB4TabType_TabTypeEntertainment,
        PB4TabType_TabTypeRankingList,
        PB4TabType_TabTypeMine,
        PB4TabType_TabTypeCommunity,
        PB4TabType_TabTypeMessage,
        PB4TabType_TabTypeMediaPlayer,
        PB4TabType_TabTypeDiscovery,
        PB4TabType_TabTypeMatch,
        PB4TabType_TabTypeRoute,
        PB4TabType_TabTypeWipe,
    };
    static const char *extraTextFormatInfo = "\013\000\007\204\000\001\007\215\000\002\007\213\000\003\007\204\000\004\007\211\000\005\007\207\000\006\007\213\000\007\007\211\000\010\007\205\000\t\007\205\000\n\007\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4TabType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4TabType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4TabType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4TabType_TabTypeNone:
    case PB4TabType_TabTypeEntertainment:
    case PB4TabType_TabTypeRankingList:
    case PB4TabType_TabTypeMine:
    case PB4TabType_TabTypeCommunity:
    case PB4TabType_TabTypeMessage:
    case PB4TabType_TabTypeMediaPlayer:
    case PB4TabType_TabTypeDiscovery:
    case PB4TabType_TabTypeMatch:
    case PB4TabType_TabTypeRoute:
    case PB4TabType_TabTypeWipe:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PB4FilterRule

GPBEnumDescriptor *PB4FilterRule_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FrZero\000FrDifferentSex\000";
    static const int32_t values[] = {
        PB4FilterRule_FrZero,
        PB4FilterRule_FrDifferentSex,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PB4FilterRule)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PB4FilterRule_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PB4FilterRule_IsValidValue(int32_t value__) {
  switch (value__) {
    case PB4FilterRule_FrZero:
    case PB4FilterRule_FrDifferentSex:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PB4SHomeShowUser

@implementation PB4SHomeShowUser


typedef struct PB4SHomeShowUser__storage_ {
  uint32_t _has_storage_[1];
} PB4SHomeShowUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SHomeShowUser class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4SHomeShowUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommGame

@implementation PB4PHomeCommGame

@dynamic banner;
@dynamic gameName;
@dynamic playNum;
@dynamic gameId;
@dynamic index;
@dynamic screenDirection;
@dynamic bgColor;
@dynamic textColor;
@dynamic desc;

typedef struct PB4PHomeCommGame__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t screenDirection;
  NSString *banner;
  NSString *gameName;
  NSString *bgColor;
  NSString *textColor;
  NSString *desc;
  int64_t playNum;
  int64_t gameId;
} PB4PHomeCommGame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "banner",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_Banner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, banner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_GameName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_PlayNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, playNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_GameId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_Index,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "screenDirection",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_ScreenDirection,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, screenDirection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bgColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_BgColor,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, bgColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "textColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_TextColor,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, textColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommGame_FieldNumber_Desc,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeCommGame__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommGame class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommGame__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommGameList

@implementation PB4PHomeCommGameList

@dynamic gamesArray, gamesArray_Count;

typedef struct PB4PHomeCommGameList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *gamesArray;
} PB4PHomeCommGameList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCommGame),
        .number = PB4PHomeCommGameList_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCommGameList__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommGameList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommGameList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommMiss

@implementation PB4PHomeCommMiss

@dynamic icon;
@dynamic bonusText;
@dynamic coin;
@dynamic total;
@dynamic currentProcess;
@dynamic status;
@dynamic index;
@dynamic missText;
@dynamic missId;

typedef struct PB4PHomeCommMiss__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  int32_t currentProcess;
  int32_t index;
  int32_t missId;
  NSString *icon;
  NSString *bonusText;
  NSString *missText;
  int64_t coin;
} PB4PHomeCommMiss__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusText",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_BonusText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, bonusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coin",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_Coin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, coin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_Total,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currentProcess",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_CurrentProcess,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, currentProcess),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_Status,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_Index,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "missText",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_MissText,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, missText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "missId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommMiss_FieldNumber_MissId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeCommMiss__storage_, missId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommMiss class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommMiss__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommMissList

@implementation PB4PHomeCommMissList

@dynamic missArray, missArray_Count;

typedef struct PB4PHomeCommMissList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *missArray;
} PB4PHomeCommMissList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCommMiss),
        .number = PB4PHomeCommMissList_FieldNumber_MissArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCommMissList__storage_, missArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommMissList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommMissList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommRank

@implementation PB4PHomeCommRank

@dynamic nickname;
@dynamic gameName;
@dynamic gameIcon;
@dynamic avatar;
@dynamic avatarFrame;
@dynamic index;
@dynamic backgroundURL;
@dynamic gameId;

typedef struct PB4PHomeCommRank__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t gameId;
  NSString *nickname;
  NSString *gameName;
  NSString *gameIcon;
  NSString *avatar;
  NSString *avatarFrame;
  NSString *backgroundURL;
} PB4PHomeCommRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_GameName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_GameIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, gameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_Avatar,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarFrame",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_AvatarFrame,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, avatarFrame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_Index,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "backgroundURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_BackgroundURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, backgroundURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCommRank_FieldNumber_GameId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeCommRank__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommRank class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\n\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCommRankList

@implementation PB4PHomeCommRankList

@dynamic rankArray, rankArray_Count;

typedef struct PB4PHomeCommRankList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rankArray;
} PB4PHomeCommRankList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCommRank),
        .number = PB4PHomeCommRankList_FieldNumber_RankArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCommRankList__storage_, rankArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCommRankList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCommRankList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchDirectTypeGameData

@implementation PB4MatchDirectTypeGameData

@dynamic gameId;
@dynamic roomId;
@dynamic matchStatus;
@dynamic quickGamePre;

typedef struct PB4MatchDirectTypeGameData__storage_ {
  uint32_t _has_storage_[1];
  int32_t gameId;
  int32_t roomId;
  PB4MatchStatusType matchStatus;
  PB4QuickGamePreType quickGamePre;
} PB4MatchDirectTypeGameData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeGameData_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeGameData__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeGameData_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeGameData__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "matchStatus",
        .dataTypeSpecific.enumDescFunc = PB4MatchStatusType_EnumDescriptor,
        .number = PB4MatchDirectTypeGameData_FieldNumber_MatchStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeGameData__storage_, matchStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "quickGamePre",
        .dataTypeSpecific.enumDescFunc = PB4QuickGamePreType_EnumDescriptor,
        .number = PB4MatchDirectTypeGameData_FieldNumber_QuickGamePre,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeGameData__storage_, quickGamePre),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchDirectTypeGameData class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchDirectTypeGameData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4MatchDirectTypeGameData_MatchStatus_RawValue(PB4MatchDirectTypeGameData *message) {
  GPBDescriptor *descriptor = [PB4MatchDirectTypeGameData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchDirectTypeGameData_FieldNumber_MatchStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MatchDirectTypeGameData_MatchStatus_RawValue(PB4MatchDirectTypeGameData *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MatchDirectTypeGameData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchDirectTypeGameData_FieldNumber_MatchStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4MatchDirectTypeGameData_QuickGamePre_RawValue(PB4MatchDirectTypeGameData *message) {
  GPBDescriptor *descriptor = [PB4MatchDirectTypeGameData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchDirectTypeGameData_FieldNumber_QuickGamePre];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MatchDirectTypeGameData_QuickGamePre_RawValue(PB4MatchDirectTypeGameData *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MatchDirectTypeGameData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchDirectTypeGameData_FieldNumber_QuickGamePre];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4MatchDirectTypeNormal

@implementation PB4MatchDirectTypeNormal

@dynamic normalId;
@dynamic normalURL;
@dynamic normalMsg;
@dynamic followId;
@dynamic followType;
@dynamic followName;
@dynamic followMsg;

typedef struct PB4MatchDirectTypeNormal__storage_ {
  uint32_t _has_storage_[1];
  int32_t normalId;
  int32_t followId;
  int32_t followType;
  NSString *normalURL;
  NSString *normalMsg;
  NSString *followName;
  NSString *followMsg;
} PB4MatchDirectTypeNormal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "normalId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_NormalId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, normalId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "normalURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_NormalURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, normalURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "normalMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_NormalMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, normalMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "followId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_FollowId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, followId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followType",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_FollowType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, followType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followName",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_FollowName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, followName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "followMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchDirectTypeNormal_FieldNumber_FollowMsg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4MatchDirectTypeNormal__storage_, followMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchDirectTypeNormal class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchDirectTypeNormal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeModClassify

@implementation PB4PHomeModClassify

@dynamic id_p;
@dynamic name;
@dynamic URL;
@dynamic selectedURL;

typedef struct PB4PHomeModClassify__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeClassify id_p;
  NSString *name;
  NSString *URL;
  NSString *selectedURL;
} PB4PHomeModClassify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4PHomeModClassify_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeModClassify__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeModClassify_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeModClassify__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeModClassify_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeModClassify__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectedURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeModClassify_FieldNumber_SelectedURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeModClassify__storage_, selectedURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeModClassify class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeModClassify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003!!!\000\004\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeModClassify_Id_p_RawValue(PB4PHomeModClassify *message) {
  GPBDescriptor *descriptor = [PB4PHomeModClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeModClassify_FieldNumber_Id_p];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeModClassify_Id_p_RawValue(PB4PHomeModClassify *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeModClassify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeModClassify_FieldNumber_Id_p];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeMod

@implementation PB4PHomeMod

@dynamic id_p;
@dynamic title;
@dynamic isShowTitle;
@dynamic style;
@dynamic isShowCtrlBtn;
@dynamic ctrlBtnImgURL;
@dynamic ctrlBtnRule;
@dynamic isEnd;
@dynamic classifysArray, classifysArray_Count;
@dynamic dataType;
@dynamic dataByte;
@dynamic routeType;
@dynamic route;
@dynamic isInsterMod;
@dynamic showNum;
@dynamic emptyImg;
@dynamic exposureNum;
@dynamic followMsg;
@dynamic isNew;
@dynamic rightTopRoute;
@dynamic emptyImgRoute;
@dynamic isDynamicLoad;
@dynamic isRouter;
@dynamic photoRouter;
@dynamic isOpenOnline;

typedef struct PB4PHomeMod__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB4PHomeModStyle style;
  PB4PHomeMoreRule ctrlBtnRule;
  PB4PHomeDataType dataType;
  PB4PHomeRouteType routeType;
  int32_t showNum;
  int32_t exposureNum;
  NSString *title;
  NSString *ctrlBtnImgURL;
  NSMutableArray *classifysArray;
  NSData *dataByte;
  NSString *route;
  NSString *emptyImg;
  NSString *followMsg;
  NSString *rightTopRoute;
  NSString *emptyImgRoute;
  NSString *photoRouter;
} PB4PHomeMod__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isShowTitle",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsShowTitle,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB4PHomeModStyle_EnumDescriptor,
        .number = PB4PHomeMod_FieldNumber_Style,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isShowCtrlBtn",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsShowCtrlBtn,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ctrlBtnImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_CtrlBtnImgURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, ctrlBtnImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ctrlBtnRule",
        .dataTypeSpecific.enumDescFunc = PB4PHomeMoreRule_EnumDescriptor,
        .number = PB4PHomeMod_FieldNumber_CtrlBtnRule,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, ctrlBtnRule),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsEnd,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "classifysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeModClassify),
        .number = PB4PHomeMod_FieldNumber_ClassifysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, classifysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeDataType_EnumDescriptor,
        .number = PB4PHomeMod_FieldNumber_DataType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dataByte",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_DataByte,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, dataByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "routeType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeRouteType_EnumDescriptor,
        .number = PB4PHomeMod_FieldNumber_RouteType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, routeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_Route,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isInsterMod",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsInsterMod,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "showNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_ShowNum,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, showNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "emptyImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_EmptyImg,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, emptyImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exposureNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_ExposureNum,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, exposureNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "followMsg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_FollowMsg,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, followMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isNew",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsNew,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "rightTopRoute",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_RightTopRoute,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, rightTopRoute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emptyImgRoute",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_EmptyImgRoute,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, emptyImgRoute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDynamicLoad",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsDynamicLoad,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isRouter",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsRouter,
        .hasIndex = 27,
        .offset = 28,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "photoRouter",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_PhotoRouter,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB4PHomeMod__storage_, photoRouter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isOpenOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeMod_FieldNumber_IsOpenOnline,
        .hasIndex = 30,
        .offset = 31,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeMod class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeMod__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\004\243\243\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeMod_Style_RawValue(PB4PHomeMod *message) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeMod_Style_RawValue(PB4PHomeMod *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeMod_CtrlBtnRule_RawValue(PB4PHomeMod *message) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_CtrlBtnRule];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeMod_CtrlBtnRule_RawValue(PB4PHomeMod *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_CtrlBtnRule];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeMod_DataType_RawValue(PB4PHomeMod *message) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_DataType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeMod_DataType_RawValue(PB4PHomeMod *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_DataType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeMod_RouteType_RawValue(PB4PHomeMod *message) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_RouteType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeMod_RouteType_RawValue(PB4PHomeMod *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeMod descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeMod_FieldNumber_RouteType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeEntryRoomList

@implementation PB4PHomeEntryRoomList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntryRoomList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntryRoomList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryRoom),
        .number = PB4PHomeEntryRoomList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoomList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryRoomList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryRoomList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryRoom

@implementation PB4PHomeEntryRoom

@dynamic id_p;
@dynamic index;
@dynamic type;
@dynamic id2;
@dynamic name;
@dynamic icon;
@dynamic onlineNum;
@dynamic hasPasswd;
@dynamic isRoomOwnerOnline;
@dynamic category;
@dynamic pattern;
@dynamic detailsImg;
@dynamic flags;
@dynamic rank;
@dynamic isTop;
@dynamic recommendWord;
@dynamic fans;
@dynamic roomId;
@dynamic highQualityOnlineNum;
@dynamic hasTips, tips;
@dynamic lastTime;
@dynamic sex;
@dynamic heat;
@dynamic chairs;
@dynamic coverPic;
@dynamic roomDecorateArray, roomDecorateArray_Count;
@dynamic hasVideoInfo, videoInfo;
@dynamic hasHost, host;
@dynamic roomGameIcon;
@dynamic roomTypeTag;
@dynamic hasEightDescribe, eightDescribe;
@dynamic ownerName;
@dynamic isClan;
@dynamic gameStatus;
@dynamic gamePlayerStatusArray, gamePlayerStatusArray_Count;
@dynamic actionTalk;
@dynamic roomTypeStr;
@dynamic chairPlayerListArray, chairPlayerListArray_Count;
@dynamic gameName;
@dynamic extend, extend_Count;
@dynamic hasRoomLabel, roomLabel;

typedef struct PB4PHomeEntryRoom__storage_ {
  uint32_t _has_storage_[2];
  int32_t index;
  PB4PluginRoomType type;
  int32_t onlineNum;
  int32_t category;
  int32_t pattern;
  int32_t flags;
  int32_t highQualityOnlineNum;
  PB4PluginSexType sex;
  int32_t heat;
  int32_t chairs;
  PB4PGameRoomStatusTypeExt gameStatus;
  NSString *name;
  NSString *icon;
  NSString *detailsImg;
  NSString *recommendWord;
  PB4PluginHomeTips *tips;
  NSString *coverPic;
  NSMutableArray *roomDecorateArray;
  PB4PhomeVideoInfo *videoInfo;
  PB4PlayerBaseInfo *host;
  NSString *roomGameIcon;
  NSString *roomTypeTag;
  PB4EightDescribe *eightDescribe;
  NSString *ownerName;
  NSMutableArray *gamePlayerStatusArray;
  NSString *actionTalk;
  NSString *roomTypeStr;
  NSMutableArray *chairPlayerListArray;
  NSString *gameName;
  GPBInt32ObjectDictionary *extend;
  PB4PHomeEntryRoomLabel *roomLabel;
  int64_t id_p;
  int64_t id2;
  int64_t rank;
  int64_t fans;
  int64_t roomId;
  int64_t lastTime;
} PB4PHomeEntryRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4PluginRoomType_EnumDescriptor,
        .number = PB4PHomeEntryRoom_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Id2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Icon,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onlineNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_OnlineNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, onlineNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hasPasswd",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_HasPasswd,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isRoomOwnerOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_IsRoomOwnerOnline,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Category,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "pattern",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Pattern,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, pattern),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "detailsImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_DetailsImg,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, detailsImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flags",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Flags,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, flags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Rank,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "isTop",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_IsTop,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recommendWord",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_RecommendWord,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, recommendWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fans",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Fans,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, fans),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_RoomId,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "highQualityOnlineNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_HighQualityOnlineNum,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, highQualityOnlineNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PluginHomeTips),
        .number = PB4PHomeEntryRoom_FieldNumber_Tips,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_LastTime,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, lastTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeEntryRoom_FieldNumber_Sex,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "heat",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Heat,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, heat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "chairs",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Chairs,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, chairs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "coverPic",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_CoverPic,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, coverPic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomDecorateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4RoomDecorate),
        .number = PB4PHomeEntryRoom_FieldNumber_RoomDecorateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomDecorateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PhomeVideoInfo),
        .number = PB4PHomeEntryRoom_FieldNumber_VideoInfo,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, videoInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PlayerBaseInfo),
        .number = PB4PHomeEntryRoom_FieldNumber_Host,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomGameIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_RoomGameIcon,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomGameIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomTypeTag",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_RoomTypeTag,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomTypeTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eightDescribe",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4EightDescribe),
        .number = PB4PHomeEntryRoom_FieldNumber_EightDescribe,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, eightDescribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ownerName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_OwnerName,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, ownerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isClan",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_IsClan,
        .hasIndex = 34,
        .offset = 35,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gameStatus",
        .dataTypeSpecific.enumDescFunc = PB4PGameRoomStatusTypeExt_EnumDescriptor,
        .number = PB4PHomeEntryRoom_FieldNumber_GameStatus,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, gameStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gamePlayerStatusArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PGamePlayerStatusExt),
        .number = PB4PHomeEntryRoom_FieldNumber_GamePlayerStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, gamePlayerStatusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionTalk",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_ActionTalk,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, actionTalk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomTypeStr",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_RoomTypeStr,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomTypeStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chairPlayerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4ChairPlayerInfo),
        .number = PB4PHomeEntryRoom_FieldNumber_ChairPlayerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, chairPlayerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_GameName,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extend",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoom_FieldNumber_Extend,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, extend),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomLabel",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryRoomLabel),
        .number = PB4PHomeEntryRoom_FieldNumber_RoomLabel,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoom__storage_, roomLabel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryRoom class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\017\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntryRoom_Type_RawValue(PB4PHomeEntryRoom *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryRoom_Type_RawValue(PB4PHomeEntryRoom *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeEntryRoom_Sex_RawValue(PB4PHomeEntryRoom *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryRoom_Sex_RawValue(PB4PHomeEntryRoom *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeEntryRoom_GameStatus_RawValue(PB4PHomeEntryRoom *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_GameStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryRoom_GameStatus_RawValue(PB4PHomeEntryRoom *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryRoom descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryRoom_FieldNumber_GameStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeEntryRoomLabel

@implementation PB4PHomeEntryRoomLabel

@dynamic labelIconURL;
@dynamic labelName;
@dynamic labelFontcolor;

typedef struct PB4PHomeEntryRoomLabel__storage_ {
  uint32_t _has_storage_[1];
  NSString *labelIconURL;
  NSString *labelName;
  NSString *labelFontcolor;
} PB4PHomeEntryRoomLabel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoomLabel_FieldNumber_LabelIconURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoomLabel__storage_, labelIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoomLabel_FieldNumber_LabelName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoomLabel__storage_, labelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelFontcolor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryRoomLabel_FieldNumber_LabelFontcolor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryRoomLabel__storage_, labelFontcolor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryRoomLabel class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryRoomLabel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ChairPlayerInfo

@implementation PB4ChairPlayerInfo

@dynamic playerId;
@dynamic icon;

typedef struct PB4ChairPlayerInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
  int64_t playerId;
} PB4ChairPlayerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4ChairPlayerInfo_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ChairPlayerInfo__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4ChairPlayerInfo_FieldNumber_Icon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ChairPlayerInfo__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ChairPlayerInfo class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ChairPlayerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PGamePlayerStatusExt

@implementation PB4PGamePlayerStatusExt

@dynamic playerId;
@dynamic status;
@dynamic icon;

typedef struct PB4PGamePlayerStatusExt__storage_ {
  uint32_t _has_storage_[1];
  PB4PGamePlayerStatusTypeExt status;
  NSString *icon;
  int64_t playerId;
} PB4PGamePlayerStatusExt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PGamePlayerStatusExt_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PGamePlayerStatusExt__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = PB4PGamePlayerStatusTypeExt_EnumDescriptor,
        .number = PB4PGamePlayerStatusExt_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PGamePlayerStatusExt__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PGamePlayerStatusExt_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PGamePlayerStatusExt__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PGamePlayerStatusExt class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PGamePlayerStatusExt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PGamePlayerStatusExt_Status_RawValue(PB4PGamePlayerStatusExt *message) {
  GPBDescriptor *descriptor = [PB4PGamePlayerStatusExt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PGamePlayerStatusExt_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PGamePlayerStatusExt_Status_RawValue(PB4PGamePlayerStatusExt *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PGamePlayerStatusExt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PGamePlayerStatusExt_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4EightDescribe

@implementation PB4EightDescribe

@dynamic text;

typedef struct PB4EightDescribe__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} PB4EightDescribe__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PB4EightDescribe_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4EightDescribe__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4EightDescribe class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4EightDescribe__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PhomeVideoInfo

@implementation PB4PhomeVideoInfo

@dynamic title;
@dynamic tagsArray, tagsArray_Count;
@dynamic image;

typedef struct PB4PhomeVideoInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSMutableArray *tagsArray;
  NSString *image;
} PB4PhomeVideoInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4PhomeVideoInfo_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PhomeVideoInfo__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PhomeVideoInfo_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PhomeVideoInfo__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = PB4PhomeVideoInfo_FieldNumber_Image,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PhomeVideoInfo__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PhomeVideoInfo class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PhomeVideoInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryBcFriendList

@implementation PB4PHomeEntryBcFriendList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntryBcFriendList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntryBcFriendList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryBcFriend),
        .number = PB4PHomeEntryBcFriendList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriendList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBcFriendList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBcFriendList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryBcFriend

@implementation PB4PHomeEntryBcFriend

@dynamic id_p;
@dynamic index;
@dynamic sex;
@dynamic id2;
@dynamic wealthLevel;
@dynamic charmLevel;
@dynamic content;
@dynamic endTime;
@dynamic headlineCost;
@dynamic type;
@dynamic name;
@dynamic icon;
@dynamic recordId;
@dynamic recordType;
@dynamic onChairNum;
@dynamic roomPatternBcName;
@dynamic roomPatternBcNameColor;
@dynamic roomPatternBcBorderColor;
@dynamic extend, extend_Count;
@dynamic labelsArray, labelsArray_Count;
@dynamic playerId;
@dynamic hasRoomLabel, roomLabel;

typedef struct PB4PHomeEntryBcFriend__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB4PluginSexType sex;
  int32_t wealthLevel;
  int32_t charmLevel;
  int32_t headlineCost;
  PB4PluginBcFriendType type;
  PB4BF_RECORD_TYPE recordType;
  int32_t onChairNum;
  NSString *content;
  NSString *name;
  NSString *icon;
  NSString *recordId;
  NSString *roomPatternBcName;
  NSString *roomPatternBcNameColor;
  NSString *roomPatternBcBorderColor;
  GPBInt32ObjectDictionary *extend;
  NSMutableArray *labelsArray;
  PB4PHomeEntryRoomLabel *roomLabel;
  int64_t id_p;
  int64_t id2;
  int64_t endTime;
  int64_t playerId;
} PB4PHomeEntryBcFriend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Id2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "wealthLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_WealthLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, wealthLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_CharmLevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Content,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_EndTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "headlineCost",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_HeadlineCost,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, headlineCost),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4PluginBcFriendType_EnumDescriptor,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Name,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Icon,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recordId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_RecordId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, recordId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recordType",
        .dataTypeSpecific.enumDescFunc = PB4BF_RECORD_TYPE_EnumDescriptor,
        .number = PB4PHomeEntryBcFriend_FieldNumber_RecordType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, recordType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onChairNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_OnChairNum,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, onChairNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomPatternBcName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_RoomPatternBcName,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, roomPatternBcName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomPatternBcNameColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_RoomPatternBcNameColor,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, roomPatternBcNameColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomPatternBcBorderColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_RoomPatternBcBorderColor,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, roomPatternBcBorderColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extend",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_Extend,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, extend),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBcFriend_FieldNumber_PlayerId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomLabel",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryRoomLabel),
        .number = PB4PHomeEntryBcFriend_FieldNumber_RoomLabel,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBcFriend__storage_, roomLabel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBcFriend class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBcFriend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntryBcFriend_Sex_RawValue(PB4PHomeEntryBcFriend *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryBcFriend_Sex_RawValue(PB4PHomeEntryBcFriend *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeEntryBcFriend_Type_RawValue(PB4PHomeEntryBcFriend *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryBcFriend_Type_RawValue(PB4PHomeEntryBcFriend *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeEntryBcFriend_RecordType_RawValue(PB4PHomeEntryBcFriend *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_RecordType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryBcFriend_RecordType_RawValue(PB4PHomeEntryBcFriend *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBcFriend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBcFriend_FieldNumber_RecordType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeRouterList

@implementation PB4PHomeRouterList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeRouterList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeRouterList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeRouter),
        .number = PB4PHomeRouterList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeRouterList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeRouterList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeRouterList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeRouter

@implementation PB4PHomeRouter

@dynamic title;
@dynamic featureImg;
@dynamic featureText;
@dynamic backgroundImg;
@dynamic router;

typedef struct PB4PHomeRouter__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *featureImg;
  NSString *featureText;
  NSString *backgroundImg;
  NSString *router;
} PB4PHomeRouter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRouter_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeRouter__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "featureImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRouter_FieldNumber_FeatureImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeRouter__storage_, featureImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "featureText",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRouter_FieldNumber_FeatureText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeRouter__storage_, featureText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRouter_FieldNumber_BackgroundImg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeRouter__storage_, backgroundImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRouter_FieldNumber_Router,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeRouter__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeRouter class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeRouter__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeRankList

@implementation PB4PHomeRankList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeRankList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeRankList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeRank),
        .number = PB4PHomeRankList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeRankList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeRankList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeRankList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeRank

@implementation PB4PHomeRank

@dynamic rankName;
@dynamic rankIcon;
@dynamic num;
@dynamic router;
@dynamic rankListArray, rankListArray_Count;
@dynamic rankType;
@dynamic title;
@dynamic msg;
@dynamic bgImage;
@dynamic describe;
@dynamic reloadTime;

typedef struct PB4PHomeRank__storage_ {
  uint32_t _has_storage_[1];
  int32_t num;
  PB4PluginRankType rankType;
  NSString *rankName;
  NSString *rankIcon;
  NSString *router;
  NSMutableArray *rankListArray;
  NSString *title;
  NSString *msg;
  NSString *bgImage;
  NSString *describe;
  int64_t reloadTime;
} PB4PHomeRank__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rankName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_RankName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, rankName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rankIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_RankIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, rankIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_Num,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_Router,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rankListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeRankItem),
        .number = PB4PHomeRank_FieldNumber_RankListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, rankListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rankType",
        .dataTypeSpecific.enumDescFunc = PB4PluginRankType_EnumDescriptor,
        .number = PB4PHomeRank_FieldNumber_RankType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, rankType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_Title,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bgImage",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_BgImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, bgImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "describe",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_Describe,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, describe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reloadTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRank_FieldNumber_ReloadTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeRank__storage_, reloadTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeRank class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeRank__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeRank_RankType_RawValue(PB4PHomeRank *message) {
  GPBDescriptor *descriptor = [PB4PHomeRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeRank_FieldNumber_RankType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeRank_RankType_RawValue(PB4PHomeRank *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeRank descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeRank_FieldNumber_RankType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeRankItem

@implementation PB4PHomeRankItem

@dynamic id_p;
@dynamic name;
@dynamic sex;
@dynamic level;
@dynamic value;
@dynamic resTime;
@dynamic gapVal;
@dynamic icon;
@dynamic giftId;
@dynamic giftNum;
@dynamic ranking;
@dynamic id2;
@dynamic giftName;
@dynamic isChair;
@dynamic isRoom;

typedef struct PB4PHomeRankItem__storage_ {
  uint32_t _has_storage_[1];
  PB4PluginSexType sex;
  int32_t level;
  int32_t resTime;
  int32_t giftNum;
  int32_t ranking;
  NSString *name;
  NSString *icon;
  NSString *giftName;
  int64_t id_p;
  int64_t value;
  int64_t gapVal;
  int64_t giftId;
  int64_t id2;
} PB4PHomeRankItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeRankItem_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "resTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_ResTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, resTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "gapVal",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_GapVal,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, gapVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Icon,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_GiftId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "giftNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_GiftNum,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, giftNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "ranking",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Ranking,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, ranking),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_Id2,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "giftName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_GiftName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeRankItem__storage_, giftName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isChair",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_IsChair,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isRoom",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeRankItem_FieldNumber_IsRoom,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeRankItem class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeRankItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeRankItem_Sex_RawValue(PB4PHomeRankItem *message) {
  GPBDescriptor *descriptor = [PB4PHomeRankItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeRankItem_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeRankItem_Sex_RawValue(PB4PHomeRankItem *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeRankItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeRankItem_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeActivityList

@implementation PB4PHomeActivityList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeActivityList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeActivityList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeActivity),
        .number = PB4PHomeActivityList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeActivityList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeActivityList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeActivityList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeActivity

@implementation PB4PHomeActivity

@dynamic activityIcon;
@dynamic activityTextArray, activityTextArray_Count;
@dynamic router;
@dynamic interval;
@dynamic title;

typedef struct PB4PHomeActivity__storage_ {
  uint32_t _has_storage_[1];
  int32_t interval;
  NSString *activityIcon;
  NSMutableArray *activityTextArray;
  NSString *router;
  NSString *title;
} PB4PHomeActivity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activityIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeActivity_FieldNumber_ActivityIcon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeActivity__storage_, activityIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "activityTextArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeActivity_FieldNumber_ActivityTextArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeActivity__storage_, activityTextArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeActivity_FieldNumber_Router,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeActivity__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeActivity_FieldNumber_Interval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeActivity__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeActivity_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeActivity__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeActivity class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeActivity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryOrderPlayer

@implementation PB4PHomeEntryOrderPlayer

@dynamic orderNum;
@dynamic voiceURL;
@dynamic briefIntroduction;
@dynamic orderLevel;
@dynamic orderLevelPicture;
@dynamic priceId;
@dynamic priceNum;
@dynamic unit;
@dynamic voiceTime;
@dynamic skillId;
@dynamic gold;
@dynamic skillLevelId;
@dynamic hasBillConf, billConf;
@dynamic skillLevelName;
@dynamic textColor;
@dynamic borderColor;

typedef struct PB4PHomeEntryOrderPlayer__storage_ {
  uint32_t _has_storage_[1];
  int32_t orderNum;
  int32_t orderLevel;
  int32_t priceNum;
  int32_t voiceTime;
  int32_t skillId;
  int32_t gold;
  int32_t skillLevelId;
  NSString *voiceURL;
  NSString *briefIntroduction;
  NSString *orderLevelPicture;
  NSString *unit;
  PB4BillConf *billConf;
  NSString *skillLevelName;
  NSString *textColor;
  NSString *borderColor;
  int64_t priceId;
} PB4PHomeEntryOrderPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orderNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_OrderNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, orderNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_VoiceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "briefIntroduction",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_BriefIntroduction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, briefIntroduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_OrderLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, orderLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "orderLevelPicture",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_OrderLevelPicture,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, orderLevelPicture),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_PriceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, priceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "priceNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_PriceNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, priceNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unit",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_Unit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, unit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_VoiceTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_SkillId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gold",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_Gold,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, gold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skillLevelId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_SkillLevelId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, skillLevelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "billConf",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4BillConf),
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_BillConf,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, billConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skillLevelName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_SkillLevelName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, skillLevelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "textColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_TextColor,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, textColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "borderColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryOrderPlayer_FieldNumber_BorderColor,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4PHomeEntryOrderPlayer__storage_, borderColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryOrderPlayer class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryOrderPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryPlayerList

@implementation PB4PHomeEntryPlayerList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntryPlayerList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntryPlayerList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryPlayer),
        .number = PB4PHomeEntryPlayerList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayerList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryPlayerList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryPlayerList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryPlayer

@implementation PB4PHomeEntryPlayer

@dynamic id_p;
@dynamic index;
@dynamic id2;
@dynamic name;
@dynamic icon;
@dynamic hasRoomPasswd;
@dynamic recommendWord;
@dynamic fans;
@dynamic roomId;
@dynamic sex;
@dynamic hasOrderInfo, orderInfo;
@dynamic coverPic;
@dynamic flag;
@dynamic signature;
@dynamic distances;
@dynamic province;
@dynamic municipality;
@dynamic county;
@dynamic addressDetail;
@dynamic recommendTags;
@dynamic billIconArray, billIconArray_Count;
@dynamic isOnline;
@dynamic imageListArray, imageListArray_Count;
@dynamic updateTime;
@dynamic orderInfoListArray, orderInfoListArray_Count;
@dynamic talkArray, talkArray_Count;
@dynamic playerAbilityArray, playerAbilityArray_Count;
@dynamic voiceURL;
@dynamic voiceTime;
@dynamic recommendWordIcon;
@dynamic userStateContent;
@dynamic authTagsArray, authTagsArray_Count;
@dynamic billIconInfoArray, billIconInfoArray_Count;
@dynamic gameName;
@dynamic age;
@dynamic constellation;
@dynamic isChair;
@dynamic actionTalk;
@dynamic nobilityId;
@dynamic hasCpInfo, cpInfo;
@dynamic mind;

typedef struct PB4PHomeEntryPlayer__storage_ {
  uint32_t _has_storage_[2];
  int32_t index;
  PB4PluginSexType sex;
  int32_t distances;
  int32_t voiceTime;
  int32_t age;
  int32_t nobilityId;
  NSString *name;
  NSString *icon;
  NSString *recommendWord;
  PB4PHomeEntryOrderPlayer *orderInfo;
  NSString *coverPic;
  NSString *signature;
  NSString *province;
  NSString *municipality;
  NSString *county;
  NSString *addressDetail;
  NSString *recommendTags;
  NSMutableArray *billIconArray;
  NSMutableArray *imageListArray;
  NSMutableArray *orderInfoListArray;
  NSMutableArray *talkArray;
  NSMutableArray *playerAbilityArray;
  NSString *voiceURL;
  NSString *recommendWordIcon;
  NSString *userStateContent;
  NSMutableArray *authTagsArray;
  NSMutableArray *billIconInfoArray;
  NSString *gameName;
  NSString *constellation;
  NSString *actionTalk;
  PB4PHomeCPPlayer *cpInfo;
  NSString *mind;
  int64_t id_p;
  int64_t id2;
  int64_t fans;
  int64_t roomId;
  int64_t flag;
  int64_t updateTime;
} PB4PHomeEntryPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "id2",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Id2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, id2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Name,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Icon,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasRoomPasswd",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_HasRoomPasswd,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recommendWord",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_RecommendWord,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, recommendWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fans",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Fans,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, fans),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_RoomId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeEntryPlayer_FieldNumber_Sex,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "orderInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryOrderPlayer),
        .number = PB4PHomeEntryPlayer_FieldNumber_OrderInfo,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, orderInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coverPic",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_CoverPic,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, coverPic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Flag,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Signature,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "distances",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Distances,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, distances),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Province,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "municipality",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Municipality,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, municipality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "county",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_County,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, county),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressDetail",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_AddressDetail,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, addressDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recommendTags",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_RecommendTags,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, recommendTags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "billIconArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_BillIconArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, billIconArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_IsOnline,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "imageListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PlayerImageInfo),
        .number = PB4PHomeEntryPlayer_FieldNumber_ImageListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, imageListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_UpdateTime,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, updateTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "orderInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryOrderPlayer),
        .number = PB4PHomeEntryPlayer_FieldNumber_OrderInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, orderInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_TalkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, talkArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerAbilityArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomePlayerAbility),
        .number = PB4PHomeEntryPlayer_FieldNumber_PlayerAbilityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, playerAbilityArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_VoiceURL,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_VoiceTime,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recommendWordIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_RecommendWordIcon,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, recommendWordIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userStateContent",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_UserStateContent,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, userStateContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTagsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4AuthTag),
        .number = PB4PHomeEntryPlayer_FieldNumber_AuthTagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, authTagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "billIconInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4BillPlayerIconInfo),
        .number = PB4PHomeEntryPlayer_FieldNumber_BillIconInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, billIconInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gameName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_GameName,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, gameName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "age",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Age,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, age),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "constellation",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Constellation,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, constellation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isChair",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_IsChair,
        .hasIndex = 31,
        .offset = 32,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "actionTalk",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_ActionTalk,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, actionTalk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nobilityId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_NobilityId,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, nobilityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cpInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCPPlayer),
        .number = PB4PHomeEntryPlayer_FieldNumber_CpInfo,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, cpInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mind",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryPlayer_FieldNumber_Mind,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(PB4PHomeEntryPlayer__storage_, mind),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryPlayer class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\034\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntryPlayer_Sex_RawValue(PB4PHomeEntryPlayer *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryPlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryPlayer_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryPlayer_Sex_RawValue(PB4PHomeEntryPlayer *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryPlayer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryPlayer_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4BillConf

@implementation PB4BillConf

@dynamic skillId;
@dynamic name;
@dynamic skillIconURL;
@dynamic skillStartColor;
@dynamic skillEndColor;
@dynamic levSkillStartColor;
@dynamic levSkillEndColor;

typedef struct PB4BillConf__storage_ {
  uint32_t _has_storage_[1];
  int32_t skillId;
  NSString *name;
  NSString *skillIconURL;
  NSString *skillStartColor;
  NSString *skillEndColor;
  NSString *levSkillStartColor;
  NSString *levSkillEndColor;
} PB4BillConf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skillId",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_SkillId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, skillId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skillIconURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_SkillIconURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, skillIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skillStartColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_SkillStartColor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, skillStartColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skillEndColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_SkillEndColor,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, skillEndColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levSkillStartColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_LevSkillStartColor,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, levSkillStartColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "levSkillEndColor",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillConf_FieldNumber_LevSkillEndColor,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4BillConf__storage_, levSkillEndColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4BillConf class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4BillConf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\005\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4BillPlayerIconInfo

@implementation PB4BillPlayerIconInfo

@dynamic URL;
@dynamic iconLocation;

typedef struct PB4BillPlayerIconInfo__storage_ {
  uint32_t _has_storage_[1];
  PB4IconLocationType iconLocation;
  NSString *URL;
} PB4BillPlayerIconInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB4BillPlayerIconInfo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4BillPlayerIconInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconLocation",
        .dataTypeSpecific.enumDescFunc = PB4IconLocationType_EnumDescriptor,
        .number = PB4BillPlayerIconInfo_FieldNumber_IconLocation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4BillPlayerIconInfo__storage_, iconLocation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4BillPlayerIconInfo class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4BillPlayerIconInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4BillPlayerIconInfo_IconLocation_RawValue(PB4BillPlayerIconInfo *message) {
  GPBDescriptor *descriptor = [PB4BillPlayerIconInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4BillPlayerIconInfo_FieldNumber_IconLocation];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4BillPlayerIconInfo_IconLocation_RawValue(PB4BillPlayerIconInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4BillPlayerIconInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4BillPlayerIconInfo_FieldNumber_IconLocation];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4AuthTag

@implementation PB4AuthTag

@dynamic icon;

typedef struct PB4AuthTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *icon;
} PB4AuthTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4AuthTag_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4AuthTag__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4AuthTag class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4AuthTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomePlayerAbility

@implementation PB4PHomePlayerAbility

@dynamic abilityName;
@dynamic abilityValue;

typedef struct PB4PHomePlayerAbility__storage_ {
  uint32_t _has_storage_[1];
  int32_t abilityValue;
  NSString *abilityName;
} PB4PHomePlayerAbility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "abilityName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomePlayerAbility_FieldNumber_AbilityName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomePlayerAbility__storage_, abilityName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "abilityValue",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomePlayerAbility_FieldNumber_AbilityValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomePlayerAbility__storage_, abilityValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomePlayerAbility class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomePlayerAbility__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryBannerList

@implementation PB4PHomeEntryBannerList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntryBannerList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntryBannerList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryBanner),
        .number = PB4PHomeEntryBannerList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBannerList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBannerList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBannerList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntryBanner

@implementation PB4PHomeEntryBanner

@dynamic id_p;
@dynamic index;
@dynamic URL;
@dynamic route;
@dynamic name;
@dynamic onlineNum;
@dynamic position;

typedef struct PB4PHomeEntryBanner__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  PB4BannerPosition position;
  NSString *URL;
  NSString *route;
  NSString *name;
  int64_t id_p;
  int64_t onlineNum;
} PB4PHomeEntryBanner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_Route,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onlineNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBanner_FieldNumber_OnlineNum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, onlineNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "position",
        .dataTypeSpecific.enumDescFunc = PB4BannerPosition_EnumDescriptor,
        .number = PB4PHomeEntryBanner_FieldNumber_Position,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBanner__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBanner class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBanner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntryBanner_Position_RawValue(PB4PHomeEntryBanner *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBanner descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBanner_FieldNumber_Position];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryBanner_Position_RawValue(PB4PHomeEntryBanner *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBanner descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBanner_FieldNumber_Position];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeEntrySubNavList

@implementation PB4PHomeEntrySubNavList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntrySubNavList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntrySubNavList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntrySubNav),
        .number = PB4PHomeEntrySubNavList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNavList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntrySubNavList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntrySubNavList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeEntrySubNav

@implementation PB4PHomeEntrySubNav

@dynamic id_p;
@dynamic index;
@dynamic name;
@dynamic imgURL;
@dynamic selectedImgURL;
@dynamic isDefault;
@dynamic navStyle;
@dynamic showSelectSex;
@dynamic classify;
@dynamic buttonsArray, buttonsArray_Count;
@dynamic redNum;

typedef struct PB4PHomeEntrySubNav__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t index;
  PB4PHomeNavStyle navStyle;
  PB4PHomeClassify classify;
  int32_t redNum;
  NSString *name;
  NSString *imgURL;
  NSString *selectedImgURL;
  NSMutableArray *buttonsArray;
} PB4PHomeEntrySubNav__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_ImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectedImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_SelectedImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, selectedImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_IsDefault,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "navStyle",
        .dataTypeSpecific.enumDescFunc = PB4PHomeNavStyle_EnumDescriptor,
        .number = PB4PHomeEntrySubNav_FieldNumber_NavStyle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, navStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "showSelectSex",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_ShowSelectSex,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "classify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4PHomeEntrySubNav_FieldNumber_Classify,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, classify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "buttonsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Button),
        .number = PB4PHomeEntrySubNav_FieldNumber_ButtonsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, buttonsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntrySubNav_FieldNumber_RedNum,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4PHomeEntrySubNav__storage_, redNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntrySubNav class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntrySubNav__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\003\241!!\000\005\010\243\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntrySubNav_NavStyle_RawValue(PB4PHomeEntrySubNav *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntrySubNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntrySubNav_FieldNumber_NavStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntrySubNav_NavStyle_RawValue(PB4PHomeEntrySubNav *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntrySubNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntrySubNav_FieldNumber_NavStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4PHomeEntrySubNav_Classify_RawValue(PB4PHomeEntrySubNav *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntrySubNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntrySubNav_FieldNumber_Classify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntrySubNav_Classify_RawValue(PB4PHomeEntrySubNav *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntrySubNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntrySubNav_FieldNumber_Classify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeNav

@implementation PB4PHomeNav

@dynamic id_p;
@dynamic name;
@dynamic sort;
@dynamic isDefault;
@dynamic modListArray, modListArray_Count;
@dynamic imgURL;
@dynamic selectedImgURL;
@dynamic navStyle;
@dynamic isFixed;
@dynamic navIcon;

typedef struct PB4PHomeNav__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t sort;
  PB4PHomeNavStyle navStyle;
  NSString *name;
  NSMutableArray *modListArray;
  NSString *imgURL;
  NSString *selectedImgURL;
  NSString *navIcon;
} PB4PHomeNav__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_Sort,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_IsDefault,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "modListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeMod),
        .number = PB4PHomeNav_FieldNumber_ModListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, modListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_ImgURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectedImgURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_SelectedImgURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, selectedImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "navStyle",
        .dataTypeSpecific.enumDescFunc = PB4PHomeNavStyle_EnumDescriptor,
        .number = PB4PHomeNav_FieldNumber_NavStyle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, navStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isFixed",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_IsFixed,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "navIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeNav_FieldNumber_NavIcon,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4PHomeNav__storage_, navIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeNav class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeNav__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\006\003\241!!\000\007\010\243\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeNav_NavStyle_RawValue(PB4PHomeNav *message) {
  GPBDescriptor *descriptor = [PB4PHomeNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeNav_FieldNumber_NavStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeNav_NavStyle_RawValue(PB4PHomeNav *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeNav descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeNav_FieldNumber_NavStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4Button

@implementation PB4Button

@dynamic buttonIcon;
@dynamic router;

typedef struct PB4Button__storage_ {
  uint32_t _has_storage_[1];
  NSString *buttonIcon;
  NSString *router;
} PB4Button__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "buttonIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4Button_FieldNumber_ButtonIcon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4Button__storage_, buttonIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "router",
        .dataTypeSpecific.className = NULL,
        .number = PB4Button_FieldNumber_Router,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4Button__storage_, router),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4Button class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4Button__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetPHomeNavReq

@implementation PB4GetPHomeNavReq

@dynamic pageId;
@dynamic type;
@dynamic navId;
@dynamic subNavId;

typedef struct PB4GetPHomeNavReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageId;
  PB4HomeType type;
  int32_t navId;
  int32_t subNavId;
} PB4GetPHomeNavReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavReq_FieldNumber_PageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavReq__storage_, pageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4HomeType_EnumDescriptor,
        .number = PB4GetPHomeNavReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "navId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavReq_FieldNumber_NavId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavReq__storage_, navId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subNavId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavReq_FieldNumber_SubNavId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavReq__storage_, subNavId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeNavReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeNavReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4GetPHomeNavReq_Type_RawValue(PB4GetPHomeNavReq *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeNavReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeNavReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeNavReq_Type_RawValue(PB4GetPHomeNavReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeNavReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeNavReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4GetPHomeNavRes

@implementation PB4GetPHomeNavRes

@dynamic isRemember;
@dynamic navListArray, navListArray_Count;
@dynamic md5;
@dynamic buttonsArray, buttonsArray_Count;
@dynamic redNum;

typedef struct PB4GetPHomeNavRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t redNum;
  NSMutableArray *navListArray;
  NSString *md5;
  NSMutableArray *buttonsArray;
} PB4GetPHomeNavRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isRemember",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavRes_FieldNumber_IsRemember,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "navListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeNav),
        .number = PB4GetPHomeNavRes_FieldNumber_NavListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavRes__storage_, navListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavRes_FieldNumber_Md5,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavRes__storage_, md5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buttonsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Button),
        .number = PB4GetPHomeNavRes_FieldNumber_ButtonsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavRes__storage_, buttonsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeNavRes_FieldNumber_RedNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetPHomeNavRes__storage_, redNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeNavRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeNavRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetPHomeModReq

@implementation PB4GetPHomeModReq

@dynamic navId;
@dynamic subNavId;
@dynamic modId;
@dynamic index;
@dynamic isEnd;
@dynamic classify;

typedef struct PB4GetPHomeModReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t navId;
  int32_t subNavId;
  int32_t modId;
  int32_t index;
  PB4PHomeClassify classify;
} PB4GetPHomeModReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeModReq_FieldNumber_NavId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetPHomeModReq__storage_, navId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subNavId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeModReq_FieldNumber_SubNavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetPHomeModReq__storage_, subNavId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "modId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeModReq_FieldNumber_ModId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetPHomeModReq__storage_, modId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeModReq_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetPHomeModReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeModReq_FieldNumber_IsEnd,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "classify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4GetPHomeModReq_FieldNumber_Classify,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4GetPHomeModReq__storage_, classify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeModReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeModReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4GetPHomeModReq_Classify_RawValue(PB4GetPHomeModReq *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeModReq_FieldNumber_Classify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeModReq_Classify_RawValue(PB4GetPHomeModReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeModReq_FieldNumber_Classify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4GetPHomeModRes

@implementation PB4GetPHomeModRes

@dynamic listArray, listArray_Count;

typedef struct PB4GetPHomeModRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4GetPHomeModRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeMod),
        .number = PB4GetPHomeModRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetPHomeModRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeModRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeModRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetPHomeCtrlBtnReq

@implementation PB4GetPHomeCtrlBtnReq

@dynamic navId;
@dynamic subNavId;
@dynamic modId;
@dynamic index;
@dynamic moreRule;
@dynamic hasModClassify, modClassify;
@dynamic pageNum;

typedef struct PB4GetPHomeCtrlBtnReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t navId;
  int32_t subNavId;
  int32_t modId;
  int32_t index;
  PB4PHomeMoreRule moreRule;
  int32_t pageNum;
  PB4PHomeModClassify *modClassify;
} PB4GetPHomeCtrlBtnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_NavId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, navId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subNavId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_SubNavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, subNavId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "modId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_ModId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, modId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "moreRule",
        .dataTypeSpecific.enumDescFunc = PB4PHomeMoreRule_EnumDescriptor,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_MoreRule,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, moreRule),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "modClassify",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeModClassify),
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_ModClassify,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, modClassify),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnReq_FieldNumber_PageNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnReq__storage_, pageNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeCtrlBtnReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeCtrlBtnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4GetPHomeCtrlBtnReq_MoreRule_RawValue(PB4GetPHomeCtrlBtnReq *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnReq_FieldNumber_MoreRule];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeCtrlBtnReq_MoreRule_RawValue(PB4GetPHomeCtrlBtnReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnReq_FieldNumber_MoreRule];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4GetPHomeCtrlBtnRes

@implementation PB4GetPHomeCtrlBtnRes

@dynamic dataType;
@dynamic dataByte;
@dynamic routeType;
@dynamic route;
@dynamic maxIndex;
@dynamic fiterClassify;
@dynamic subPageStyle;
@dynamic topPic;
@dynamic topString;
@dynamic isRouter;
@dynamic photoRouter;
@dynamic isOpenOnline;

typedef struct PB4GetPHomeCtrlBtnRes__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeDataType dataType;
  PB4PHomeRouteType routeType;
  int32_t maxIndex;
  PB4PHomeClassify fiterClassify;
  PB4PHomeModStyle subPageStyle;
  NSData *dataByte;
  NSString *route;
  NSString *topPic;
  NSString *topString;
  NSString *photoRouter;
} PB4GetPHomeCtrlBtnRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeDataType_EnumDescriptor,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_DataType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dataByte",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_DataByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, dataByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "routeType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeRouteType_EnumDescriptor,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_RouteType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, routeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_Route,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_MaxIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, maxIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_FiterClassify,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "subPageStyle",
        .dataTypeSpecific.enumDescFunc = PB4PHomeModStyle_EnumDescriptor,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_SubPageStyle,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, subPageStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "topPic",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_TopPic,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, topPic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "topString",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_TopString,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, topString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isRouter",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_IsRouter,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "photoRouter",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_PhotoRouter,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4GetPHomeCtrlBtnRes__storage_, photoRouter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isOpenOnline",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetPHomeCtrlBtnRes_FieldNumber_IsOpenOnline,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetPHomeCtrlBtnRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetPHomeCtrlBtnRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4GetPHomeCtrlBtnRes_DataType_RawValue(PB4GetPHomeCtrlBtnRes *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_DataType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeCtrlBtnRes_DataType_RawValue(PB4GetPHomeCtrlBtnRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_DataType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4GetPHomeCtrlBtnRes_RouteType_RawValue(PB4GetPHomeCtrlBtnRes *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_RouteType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeCtrlBtnRes_RouteType_RawValue(PB4GetPHomeCtrlBtnRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_RouteType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4GetPHomeCtrlBtnRes_FiterClassify_RawValue(PB4GetPHomeCtrlBtnRes *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeCtrlBtnRes_FiterClassify_RawValue(PB4GetPHomeCtrlBtnRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4GetPHomeCtrlBtnRes_SubPageStyle_RawValue(PB4GetPHomeCtrlBtnRes *message) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_SubPageStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4GetPHomeCtrlBtnRes_SubPageStyle_RawValue(PB4GetPHomeCtrlBtnRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4GetPHomeCtrlBtnRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4GetPHomeCtrlBtnRes_FieldNumber_SubPageStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4ClearHomeFootPrintReq

@implementation PB4ClearHomeFootPrintReq

@dynamic type;

typedef struct PB4ClearHomeFootPrintReq__storage_ {
  uint32_t _has_storage_[1];
  PB4ClearFootType type;
} PB4ClearHomeFootPrintReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4ClearFootType_EnumDescriptor,
        .number = PB4ClearHomeFootPrintReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ClearHomeFootPrintReq__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearHomeFootPrintReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ClearHomeFootPrintReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4ClearHomeFootPrintReq_Type_RawValue(PB4ClearHomeFootPrintReq *message) {
  GPBDescriptor *descriptor = [PB4ClearHomeFootPrintReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ClearHomeFootPrintReq_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ClearHomeFootPrintReq_Type_RawValue(PB4ClearHomeFootPrintReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ClearHomeFootPrintReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ClearHomeFootPrintReq_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4ClearHomeFootPrintRes

@implementation PB4ClearHomeFootPrintRes

@dynamic flag;

typedef struct PB4ClearHomeFootPrintRes__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearHomeFootPrintRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = PB4ClearHomeFootPrintRes_FieldNumber_Flag,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearHomeFootPrintRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ClearHomeFootPrintRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4Position

@implementation PB4Position

@dynamic latitude;
@dynamic longitude;
@dynamic province;
@dynamic municipality;
@dynamic county;
@dynamic addressDetail;

typedef struct PB4Position__storage_ {
  uint32_t _has_storage_[1];
  NSString *province;
  NSString *municipality;
  NSString *county;
  NSString *addressDetail;
  double latitude;
  double longitude;
} PB4Position__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4Position__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4Position__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_Province,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4Position__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "municipality",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_Municipality,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4Position__storage_, municipality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "county",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_County,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4Position__storage_, county),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressDetail",
        .dataTypeSpecific.className = NULL,
        .number = PB4Position_FieldNumber_AddressDetail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4Position__storage_, addressDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4Position class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4Position__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PeopleNearbyReq

@implementation PB4PeopleNearbyReq

@dynamic hasInfo, info;

typedef struct PB4PeopleNearbyReq__storage_ {
  uint32_t _has_storage_[1];
  PB4Position *info;
} PB4PeopleNearbyReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Position),
        .number = PB4PeopleNearbyReq_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PeopleNearbyReq__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PeopleNearbyReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PeopleNearbyReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PeopleNearbyRes

@implementation PB4PeopleNearbyRes

@dynamic interval;

typedef struct PB4PeopleNearbyRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t interval;
} PB4PeopleNearbyRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = PB4PeopleNearbyRes_FieldNumber_Interval,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PeopleNearbyRes__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PeopleNearbyRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PeopleNearbyRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4FriendDistanceReq

@implementation PB4FriendDistanceReq

@dynamic friendId;

typedef struct PB4FriendDistanceReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t friendId;
} PB4FriendDistanceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4FriendDistanceReq_FieldNumber_FriendId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4FriendDistanceReq__storage_, friendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4FriendDistanceReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4FriendDistanceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4FriendDistanceRes

@implementation PB4FriendDistanceRes

@dynamic distances;
@dynamic city;

typedef struct PB4FriendDistanceRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t distances;
  NSString *city;
} PB4FriendDistanceRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "distances",
        .dataTypeSpecific.className = NULL,
        .number = PB4FriendDistanceRes_FieldNumber_Distances,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4FriendDistanceRes__storage_, distances),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = PB4FriendDistanceRes_FieldNumber_City,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4FriendDistanceRes__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4FriendDistanceRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4FriendDistanceRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4LocationOffReq

@implementation PB4LocationOffReq


typedef struct PB4LocationOffReq__storage_ {
  uint32_t _has_storage_[1];
} PB4LocationOffReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4LocationOffReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4LocationOffReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4LocationOffRes

@implementation PB4LocationOffRes


typedef struct PB4LocationOffRes__storage_ {
  uint32_t _has_storage_[1];
} PB4LocationOffRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4LocationOffRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4LocationOffRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityDataDetail

@implementation PB4CommunityDataDetail

@dynamic style;
@dynamic isEnd;
@dynamic dataType;
@dynamic data_p;
@dynamic defaultImg;
@dynamic fiterClassify;
@dynamic index;

typedef struct PB4CommunityDataDetail__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeModStyle style;
  PB4PHomeDataType dataType;
  PB4PHomeClassify fiterClassify;
  int32_t index;
  NSData *data_p;
  NSString *defaultImg;
} PB4CommunityDataDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = PB4PHomeModStyle_EnumDescriptor,
        .number = PB4CommunityDataDetail_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityDataDetail_FieldNumber_IsEnd,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeDataType_EnumDescriptor,
        .number = PB4CommunityDataDetail_FieldNumber_DataType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityDataDetail_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "defaultImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityDataDetail_FieldNumber_DefaultImg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, defaultImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4CommunityDataDetail_FieldNumber_FiterClassify,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityDataDetail_FieldNumber_Index,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4CommunityDataDetail__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityDataDetail class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityDataDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityDataDetail_Style_RawValue(PB4CommunityDataDetail *message) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_Style];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityDataDetail_Style_RawValue(PB4CommunityDataDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_Style];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4CommunityDataDetail_DataType_RawValue(PB4CommunityDataDetail *message) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_DataType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityDataDetail_DataType_RawValue(PB4CommunityDataDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_DataType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4CommunityDataDetail_FiterClassify_RawValue(PB4CommunityDataDetail *message) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityDataDetail_FiterClassify_RawValue(PB4CommunityDataDetail *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityDataDetail descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityDataDetail_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityTagDetailReq

@implementation PB4CommunityTagDetailReq

@dynamic tagId;
@dynamic fiterClassify;
@dynamic index;

typedef struct PB4CommunityTagDetailReq__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeClassify fiterClassify;
  int32_t index;
  int64_t tagId;
} PB4CommunityTagDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTagDetailReq_FieldNumber_TagId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTagDetailReq__storage_, tagId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4CommunityTagDetailReq_FieldNumber_FiterClassify,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTagDetailReq__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTagDetailReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTagDetailReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTagDetailReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTagDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityTagDetailReq_FiterClassify_RawValue(PB4CommunityTagDetailReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityTagDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTagDetailReq_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityTagDetailReq_FiterClassify_RawValue(PB4CommunityTagDetailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityTagDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityTagDetailReq_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4CommunityGroupDetailReq

@implementation PB4CommunityGroupDetailReq

@dynamic groupId;
@dynamic fiterClassify;
@dynamic index;

typedef struct PB4CommunityGroupDetailReq__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeClassify fiterClassify;
  int32_t index;
  int64_t groupId;
} PB4CommunityGroupDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupDetailReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityGroupDetailReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4CommunityGroupDetailReq_FieldNumber_FiterClassify,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityGroupDetailReq__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityGroupDetailReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityGroupDetailReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityGroupDetailReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityGroupDetailReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4CommunityGroupDetailReq_FiterClassify_RawValue(PB4CommunityGroupDetailReq *message) {
  GPBDescriptor *descriptor = [PB4CommunityGroupDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupDetailReq_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4CommunityGroupDetailReq_FiterClassify_RawValue(PB4CommunityGroupDetailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4CommunityGroupDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4CommunityGroupDetailReq_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4ExtraModReq

@implementation PB4ExtraModReq

@dynamic modType;
@dynamic fiterClassify;
@dynamic index;

typedef struct PB4ExtraModReq__storage_ {
  uint32_t _has_storage_[1];
  PB4ExtraModType modType;
  PB4PHomeClassify fiterClassify;
  int32_t index;
} PB4ExtraModReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modType",
        .dataTypeSpecific.enumDescFunc = PB4ExtraModType_EnumDescriptor,
        .number = PB4ExtraModReq_FieldNumber_ModType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ExtraModReq__storage_, modType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4ExtraModReq_FieldNumber_FiterClassify,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ExtraModReq__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModReq_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4ExtraModReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ExtraModReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ExtraModReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4ExtraModReq_ModType_RawValue(PB4ExtraModReq *message) {
  GPBDescriptor *descriptor = [PB4ExtraModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModReq_FieldNumber_ModType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ExtraModReq_ModType_RawValue(PB4ExtraModReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ExtraModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModReq_FieldNumber_ModType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4ExtraModReq_FiterClassify_RawValue(PB4ExtraModReq *message) {
  GPBDescriptor *descriptor = [PB4ExtraModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModReq_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ExtraModReq_FiterClassify_RawValue(PB4ExtraModReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ExtraModReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModReq_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4ExtraModRes

@implementation PB4ExtraModRes

@dynamic dataType;
@dynamic bin;
@dynamic maxIndex;
@dynamic fiterClassify;
@dynamic nextIndex;
@dynamic topPic;
@dynamic topString;

typedef struct PB4ExtraModRes__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeDataType dataType;
  int32_t maxIndex;
  PB4PHomeClassify fiterClassify;
  int32_t nextIndex;
  NSData *bin;
  NSString *topPic;
  NSString *topString;
} PB4ExtraModRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeDataType_EnumDescriptor,
        .number = PB4ExtraModRes_FieldNumber_DataType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bin",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModRes_FieldNumber_Bin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, bin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModRes_FieldNumber_MaxIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, maxIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fiterClassify",
        .dataTypeSpecific.enumDescFunc = PB4PHomeClassify_EnumDescriptor,
        .number = PB4ExtraModRes_FieldNumber_FiterClassify,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, fiterClassify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "nextIndex",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModRes_FieldNumber_NextIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, nextIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "topPic",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModRes_FieldNumber_TopPic,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, topPic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "topString",
        .dataTypeSpecific.className = NULL,
        .number = PB4ExtraModRes_FieldNumber_TopString,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4ExtraModRes__storage_, topString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ExtraModRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ExtraModRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4ExtraModRes_DataType_RawValue(PB4ExtraModRes *message) {
  GPBDescriptor *descriptor = [PB4ExtraModRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModRes_FieldNumber_DataType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ExtraModRes_DataType_RawValue(PB4ExtraModRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ExtraModRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModRes_FieldNumber_DataType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t PB4ExtraModRes_FiterClassify_RawValue(PB4ExtraModRes *message) {
  GPBDescriptor *descriptor = [PB4ExtraModRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModRes_FieldNumber_FiterClassify];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4ExtraModRes_FiterClassify_RawValue(PB4ExtraModRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4ExtraModRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4ExtraModRes_FieldNumber_FiterClassify];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4RadioStationList

@implementation PB4RadioStationList

@dynamic listArray, listArray_Count;

typedef struct PB4RadioStationList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4RadioStationList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4RadioStationRoom),
        .number = PB4RadioStationList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4RadioStationList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4RadioStationList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4RadioStationList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4RadioStationRoom

@implementation PB4RadioStationRoom

@dynamic roomId;
@dynamic roomId2;
@dynamic roomName;
@dynamic briefIntroduction;
@dynamic cover;
@dynamic hot;

typedef struct PB4RadioStationRoom__storage_ {
  uint32_t _has_storage_[1];
  int32_t hot;
  NSString *roomName;
  NSString *briefIntroduction;
  NSString *cover;
  int64_t roomId;
  int64_t roomId2;
} PB4RadioStationRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomId2",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_RoomId2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, roomId2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomName",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_RoomName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, roomName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "briefIntroduction",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_BriefIntroduction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, briefIntroduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_Cover,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hot",
        .dataTypeSpecific.className = NULL,
        .number = PB4RadioStationRoom_FieldNumber_Hot,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4RadioStationRoom__storage_, hot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4RadioStationRoom class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4RadioStationRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommentInfo

@implementation PB4CommentInfo

@dynamic id_p;
@dynamic articleId;
@dynamic articleName;
@dynamic content;
@dynamic likeCount;
@dynamic commentCount;
@dynamic parentId;
@dynamic userId;
@dynamic userName;
@dynamic userIcon;
@dynamic charmLevel;
@dynamic wealthlEvel;
@dynamic toUserId;
@dynamic toUserName;
@dynamic hasLike;
@dynamic createAt;
@dynamic childCommentArray, childCommentArray_Count;
@dynamic isTop;

typedef struct PB4CommentInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t charmLevel;
  int32_t wealthlEvel;
  NSString *articleName;
  NSString *content;
  NSString *userName;
  NSString *userIcon;
  NSString *toUserName;
  NSMutableArray *childCommentArray;
  int64_t id_p;
  int64_t articleId;
  int64_t likeCount;
  int64_t commentCount;
  int64_t parentId;
  int64_t userId;
  int64_t toUserId;
  int64_t createAt;
} PB4CommentInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_ArticleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_ArticleName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, articleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_LikeCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, likeCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_CommentCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, commentCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_ParentId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_UserId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_UserName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_UserIcon,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, userIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "charmLevel",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_CharmLevel,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, charmLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "wealthlEvel",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_WealthlEvel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, wealthlEvel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_ToUserId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, toUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_ToUserName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, toUserName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasLike",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_HasLike,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "createAt",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_CreateAt,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, createAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "childCommentArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommentInfo),
        .number = PB4CommentInfo_FieldNumber_ChildCommentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommentInfo__storage_, childCommentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isTop",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommentInfo_FieldNumber_IsTop,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommentInfo class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommentInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\023\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetHotCommentListByArticleIdReq

@implementation PB4GetHotCommentListByArticleIdReq

@dynamic userId;
@dynamic articleId;

typedef struct PB4GetHotCommentListByArticleIdReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t userId;
  int64_t articleId;
} PB4GetHotCommentListByArticleIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetHotCommentListByArticleIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetHotCommentListByArticleIdReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetHotCommentListByArticleIdReq_FieldNumber_ArticleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetHotCommentListByArticleIdReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetHotCommentListByArticleIdReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetHotCommentListByArticleIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetHotCommentListByArticleIdRes

@implementation PB4GetHotCommentListByArticleIdRes

@dynamic commentListArray, commentListArray_Count;

typedef struct PB4GetHotCommentListByArticleIdRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commentListArray;
} PB4GetHotCommentListByArticleIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommentInfo),
        .number = PB4GetHotCommentListByArticleIdRes_FieldNumber_CommentListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetHotCommentListByArticleIdRes__storage_, commentListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetHotCommentListByArticleIdRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetHotCommentListByArticleIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetCommentListByArticleIdReq

@implementation PB4GetCommentListByArticleIdReq

@dynamic userId;
@dynamic articleId;
@dynamic parentId;
@dynamic lastId;
@dynamic pageSize;

typedef struct PB4GetCommentListByArticleIdReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t userId;
  int64_t articleId;
  int64_t parentId;
  int64_t lastId;
  int64_t pageSize;
} PB4GetCommentListByArticleIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdReq_FieldNumber_ArticleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdReq_FieldNumber_ParentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdReq__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdReq_FieldNumber_LastId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdReq__storage_, lastId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdReq_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdReq__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetCommentListByArticleIdReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetCommentListByArticleIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetCommentListByArticleIdRes

@implementation PB4GetCommentListByArticleIdRes

@dynamic commentListArray, commentListArray_Count;
@dynamic hasMore;
@dynamic likeCount;
@dynamic commentCount;
@dynamic like;

typedef struct PB4GetCommentListByArticleIdRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commentListArray;
  int64_t likeCount;
  int64_t commentCount;
} PB4GetCommentListByArticleIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommentInfo),
        .number = PB4GetCommentListByArticleIdRes_FieldNumber_CommentListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdRes__storage_, commentListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hasMore",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdRes_FieldNumber_HasMore,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdRes_FieldNumber_LikeCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdRes__storage_, likeCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdRes_FieldNumber_CommentCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4GetCommentListByArticleIdRes__storage_, commentCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentListByArticleIdRes_FieldNumber_Like,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetCommentListByArticleIdRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetCommentListByArticleIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetCommentInfoByArticleIdReq

@implementation PB4GetCommentInfoByArticleIdReq

@dynamic userId;
@dynamic articleId;
@dynamic commentId;

typedef struct PB4GetCommentInfoByArticleIdReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t userId;
  int64_t articleId;
  int64_t commentId;
} PB4GetCommentInfoByArticleIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentInfoByArticleIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetCommentInfoByArticleIdReq__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentInfoByArticleIdReq_FieldNumber_ArticleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4GetCommentInfoByArticleIdReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4GetCommentInfoByArticleIdReq_FieldNumber_CommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4GetCommentInfoByArticleIdReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetCommentInfoByArticleIdReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetCommentInfoByArticleIdReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4GetCommentInfoByArticleIdRes

@implementation PB4GetCommentInfoByArticleIdRes

@dynamic hasCommentInfo, commentInfo;
@dynamic hotCommentListArray, hotCommentListArray_Count;

typedef struct PB4GetCommentInfoByArticleIdRes__storage_ {
  uint32_t _has_storage_[1];
  PB4CommentInfo *commentInfo;
  NSMutableArray *hotCommentListArray;
} PB4GetCommentInfoByArticleIdRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommentInfo),
        .number = PB4GetCommentInfoByArticleIdRes_FieldNumber_CommentInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4GetCommentInfoByArticleIdRes__storage_, commentInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hotCommentListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4CommentInfo),
        .number = PB4GetCommentInfoByArticleIdRes_FieldNumber_HotCommentListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4GetCommentInfoByArticleIdRes__storage_, hotCommentListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4GetCommentInfoByArticleIdRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4GetCommentInfoByArticleIdRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4AddArticleCommentReq

@implementation PB4AddArticleCommentReq

@dynamic articleId;
@dynamic articleName;
@dynamic parentId;
@dynamic content;
@dynamic toUserId;
@dynamic toUserName;
@dynamic commentURL;

typedef struct PB4AddArticleCommentReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *articleName;
  NSString *content;
  NSString *toUserName;
  NSString *commentURL;
  int64_t articleId;
  int64_t parentId;
  int64_t toUserId;
} PB4AddArticleCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_ArticleId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleName",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_ArticleName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, articleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_ParentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_ToUserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, toUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_ToUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, toUserName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commentURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentReq_FieldNumber_CommentURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentReq__storage_, commentURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4AddArticleCommentReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4AddArticleCommentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4AddArticleCommentRes

@implementation PB4AddArticleCommentRes

@dynamic id_p;

typedef struct PB4AddArticleCommentRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} PB4AddArticleCommentRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4AddArticleCommentRes_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4AddArticleCommentRes__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4AddArticleCommentRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4AddArticleCommentRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4DelArticleCommentReq

@implementation PB4DelArticleCommentReq

@dynamic id_p;
@dynamic articleId;
@dynamic parentId;

typedef struct PB4DelArticleCommentReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
  int64_t articleId;
  int64_t parentId;
} PB4DelArticleCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4DelArticleCommentReq_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4DelArticleCommentReq__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4DelArticleCommentReq_FieldNumber_ArticleId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4DelArticleCommentReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4DelArticleCommentReq_FieldNumber_ParentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4DelArticleCommentReq__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4DelArticleCommentReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4DelArticleCommentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4DelArticleCommentRes

@implementation PB4DelArticleCommentRes


typedef struct PB4DelArticleCommentRes__storage_ {
  uint32_t _has_storage_[1];
} PB4DelArticleCommentRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4DelArticleCommentRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4DelArticleCommentRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4UpdateCommentLikeReq

@implementation PB4UpdateCommentLikeReq

@dynamic articleId;
@dynamic commentId;
@dynamic parentCommentId;
@dynamic like;

typedef struct PB4UpdateCommentLikeReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t articleId;
  int64_t commentId;
  int64_t parentCommentId;
} PB4UpdateCommentLikeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "articleId",
        .dataTypeSpecific.className = NULL,
        .number = PB4UpdateCommentLikeReq_FieldNumber_ArticleId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4UpdateCommentLikeReq__storage_, articleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4UpdateCommentLikeReq_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4UpdateCommentLikeReq__storage_, commentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "parentCommentId",
        .dataTypeSpecific.className = NULL,
        .number = PB4UpdateCommentLikeReq_FieldNumber_ParentCommentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4UpdateCommentLikeReq__storage_, parentCommentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "like",
        .dataTypeSpecific.className = NULL,
        .number = PB4UpdateCommentLikeReq_FieldNumber_Like,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4UpdateCommentLikeReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4UpdateCommentLikeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4UpdateCommentLikeRes

@implementation PB4UpdateCommentLikeRes


typedef struct PB4UpdateCommentLikeRes__storage_ {
  uint32_t _has_storage_[1];
} PB4UpdateCommentLikeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4UpdateCommentLikeRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4UpdateCommentLikeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CheckUserIsAdminReq

@implementation PB4CheckUserIsAdminReq


typedef struct PB4CheckUserIsAdminReq__storage_ {
  uint32_t _has_storage_[1];
} PB4CheckUserIsAdminReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CheckUserIsAdminReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4CheckUserIsAdminReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CheckUserIsAdminRes

@implementation PB4CheckUserIsAdminRes

@dynamic isAdmin;

typedef struct PB4CheckUserIsAdminRes__storage_ {
  uint32_t _has_storage_[1];
} PB4CheckUserIsAdminRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isAdmin",
        .dataTypeSpecific.className = NULL,
        .number = PB4CheckUserIsAdminRes_FieldNumber_IsAdmin,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CheckUserIsAdminRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CheckUserIsAdminRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MainTabReq

@implementation PB4MainTabReq


typedef struct PB4MainTabReq__storage_ {
  uint32_t _has_storage_[1];
} PB4MainTabReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MainTabReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4MainTabReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MainTabRes

@implementation PB4MainTabRes

@dynamic tabListArray, tabListArray_Count;
@dynamic rememberChoose;

typedef struct PB4MainTabRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tabListArray;
} PB4MainTabRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MainTab),
        .number = PB4MainTabRes_FieldNumber_TabListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4MainTabRes__storage_, tabListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rememberChoose",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTabRes_FieldNumber_RememberChoose,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MainTabRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MainTabRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MainTab

@implementation PB4MainTab

@dynamic tabType;
@dynamic tabName;
@dynamic tabImg;
@dynamic tabImgActivated;
@dynamic isDefault;
@dynamic route;
@dynamic tabImgSwipe;

typedef struct PB4MainTab__storage_ {
  uint32_t _has_storage_[1];
  PB4TabType tabType;
  NSString *tabName;
  NSString *tabImg;
  NSString *tabImgActivated;
  NSString *route;
  NSString *tabImgSwipe;
} PB4MainTab__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tabType",
        .dataTypeSpecific.enumDescFunc = PB4TabType_EnumDescriptor,
        .number = PB4MainTab_FieldNumber_TabType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, tabType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tabName",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_TabName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, tabName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabImg",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_TabImg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, tabImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabImgActivated",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_TabImgActivated,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, tabImgActivated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isDefault",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_IsDefault,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "route",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_Route,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tabImgSwipe",
        .dataTypeSpecific.className = NULL,
        .number = PB4MainTab_FieldNumber_TabImgSwipe,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4MainTab__storage_, tabImgSwipe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MainTab class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MainTab__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4MainTab_TabType_RawValue(PB4MainTab *message) {
  GPBDescriptor *descriptor = [PB4MainTab descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MainTab_FieldNumber_TabType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MainTab_TabType_RawValue(PB4MainTab *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MainTab descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MainTab_FieldNumber_TabType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeEntryBubble

@implementation PB4PHomeEntryBubble

@dynamic playerId;
@dynamic nickName;
@dynamic sex;
@dynamic icon;
@dynamic content;
@dynamic labelName;
@dynamic heat;
@dynamic roomId;
@dynamic navIdsArray, navIdsArray_Count;

typedef struct PB4PHomeEntryBubble__storage_ {
  uint32_t _has_storage_[1];
  PB4PluginSexType sex;
  int32_t heat;
  NSString *nickName;
  NSString *icon;
  NSString *content;
  NSString *labelName;
  GPBInt32Array *navIdsArray;
  int64_t playerId;
  int64_t roomId;
} PB4PHomeEntryBubble__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_PlayerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeEntryBubble_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_Icon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelName",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_LabelName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, labelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "heat",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_Heat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, heat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_RoomId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "navIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeEntryBubble_FieldNumber_NavIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubble__storage_, navIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBubble class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBubble__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeEntryBubble_Sex_RawValue(PB4PHomeEntryBubble *message) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBubble descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBubble_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeEntryBubble_Sex_RawValue(PB4PHomeEntryBubble *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeEntryBubble descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeEntryBubble_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeEntryBubbleList

@implementation PB4PHomeEntryBubbleList

@dynamic listArray, listArray_Count;

typedef struct PB4PHomeEntryBubbleList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} PB4PHomeEntryBubbleList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeEntryBubble),
        .number = PB4PHomeEntryBubbleList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeEntryBubbleList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeEntryBubbleList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeEntryBubbleList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4UserSongReq

@implementation PB4UserSongReq

@dynamic singer;
@dynamic song;
@dynamic playType;

typedef struct PB4UserSongReq__storage_ {
  uint32_t _has_storage_[1];
  PB4UserSongType playType;
  NSString *singer;
  NSString *song;
} PB4UserSongReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "singer",
        .dataTypeSpecific.className = NULL,
        .number = PB4UserSongReq_FieldNumber_Singer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4UserSongReq__storage_, singer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "song",
        .dataTypeSpecific.className = NULL,
        .number = PB4UserSongReq_FieldNumber_Song,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4UserSongReq__storage_, song),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playType",
        .dataTypeSpecific.enumDescFunc = PB4UserSongType_EnumDescriptor,
        .number = PB4UserSongReq_FieldNumber_PlayType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4UserSongReq__storage_, playType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4UserSongReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4UserSongReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4UserSongReq_PlayType_RawValue(PB4UserSongReq *message) {
  GPBDescriptor *descriptor = [PB4UserSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4UserSongReq_FieldNumber_PlayType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4UserSongReq_PlayType_RawValue(PB4UserSongReq *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4UserSongReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4UserSongReq_FieldNumber_PlayType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4UserSongRes

@implementation PB4UserSongRes


typedef struct PB4UserSongRes__storage_ {
  uint32_t _has_storage_[1];
} PB4UserSongRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4UserSongRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4UserSongRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeSysToastMsg

@implementation PB4PHomeSysToastMsg

@dynamic type;
@dynamic msg;

typedef struct PB4PHomeSysToastMsg__storage_ {
  uint32_t _has_storage_[1];
  PB4PHomeSysToastType type;
  NSString *msg;
} PB4PHomeSysToastMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PB4PHomeSysToastType_EnumDescriptor,
        .number = PB4PHomeSysToastMsg_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeSysToastMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeSysToastMsg_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeSysToastMsg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeSysToastMsg class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeSysToastMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeSysToastMsg_Type_RawValue(PB4PHomeSysToastMsg *message) {
  GPBDescriptor *descriptor = [PB4PHomeSysToastMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeSysToastMsg_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeSysToastMsg_Type_RawValue(PB4PHomeSysToastMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeSysToastMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeSysToastMsg_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4SysMatchMsg

@implementation PB4SysMatchMsg

@dynamic matchType;
@dynamic dataByte;
@dynamic matchItemId;

typedef struct PB4SysMatchMsg__storage_ {
  uint32_t _has_storage_[1];
  PB4MatchDirectType matchType;
  int32_t matchItemId;
  NSData *dataByte;
} PB4SysMatchMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchType",
        .dataTypeSpecific.enumDescFunc = PB4MatchDirectType_EnumDescriptor,
        .number = PB4SysMatchMsg_FieldNumber_MatchType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4SysMatchMsg__storage_, matchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dataByte",
        .dataTypeSpecific.className = NULL,
        .number = PB4SysMatchMsg_FieldNumber_DataByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4SysMatchMsg__storage_, dataByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "matchItemId",
        .dataTypeSpecific.className = NULL,
        .number = PB4SysMatchMsg_FieldNumber_MatchItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4SysMatchMsg__storage_, matchItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SysMatchMsg class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SysMatchMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4SysMatchMsg_MatchType_RawValue(PB4SysMatchMsg *message) {
  GPBDescriptor *descriptor = [PB4SysMatchMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4SysMatchMsg_FieldNumber_MatchType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4SysMatchMsg_MatchType_RawValue(PB4SysMatchMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4SysMatchMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4SysMatchMsg_FieldNumber_MatchType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4MatchUserPageDataReq

@implementation PB4MatchUserPageDataReq

@dynamic matchPageId;

typedef struct PB4MatchUserPageDataReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t matchPageId;
} PB4MatchUserPageDataReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchPageId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserPageDataReq_FieldNumber_MatchPageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchUserPageDataReq__storage_, matchPageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserPageDataReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserPageDataReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchUserPageDataRes

@implementation PB4MatchUserPageDataRes

@dynamic matchSourceListArray, matchSourceListArray_Count;
@dynamic matchPageHeadimg;

typedef struct PB4MatchUserPageDataRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *matchSourceListArray;
  NSString *matchPageHeadimg;
} PB4MatchUserPageDataRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchSourceListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4MatchSource),
        .number = PB4MatchUserPageDataRes_FieldNumber_MatchSourceListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4MatchUserPageDataRes__storage_, matchSourceListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "matchPageHeadimg",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserPageDataRes_FieldNumber_MatchPageHeadimg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchUserPageDataRes__storage_, matchPageHeadimg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserPageDataRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserPageDataRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchSource

@implementation PB4MatchSource

@dynamic name;
@dynamic matchItemId;
@dynamic icon;
@dynamic smallIcon;
@dynamic matchType;
@dynamic src;

typedef struct PB4MatchSource__storage_ {
  uint32_t _has_storage_[1];
  int32_t matchItemId;
  PB4MatchDirectType matchType;
  NSString *name;
  NSString *icon;
  NSString *smallIcon;
  NSString *src;
} PB4MatchSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchSource_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "matchItemId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchSource_FieldNumber_MatchItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, matchItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchSource_FieldNumber_Icon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallIcon",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchSource_FieldNumber_SmallIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, smallIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "matchType",
        .dataTypeSpecific.enumDescFunc = PB4MatchDirectType_EnumDescriptor,
        .number = PB4MatchSource_FieldNumber_MatchType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, matchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchSource_FieldNumber_Src,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4MatchSource__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchSource class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchSource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4MatchSource_MatchType_RawValue(PB4MatchSource *message) {
  GPBDescriptor *descriptor = [PB4MatchSource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchSource_FieldNumber_MatchType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MatchSource_MatchType_RawValue(PB4MatchSource *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MatchSource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchSource_FieldNumber_MatchType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4MatchUserReq

@implementation PB4MatchUserReq

@dynamic matchPageId;
@dynamic matchItemId;

typedef struct PB4MatchUserReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t matchPageId;
  int32_t matchItemId;
} PB4MatchUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchPageId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserReq_FieldNumber_MatchPageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchUserReq__storage_, matchPageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "matchItemId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserReq_FieldNumber_MatchItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MatchUserReq__storage_, matchItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchUserRes

@implementation PB4MatchUserRes

@dynamic userIconArray, userIconArray_Count;

typedef struct PB4MatchUserRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIconArray;
} PB4MatchUserRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIconArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserRes_FieldNumber_UserIconArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4MatchUserRes__storage_, userIconArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchUserGameStatusReq

@implementation PB4MatchUserGameStatusReq

@dynamic roomId;
@dynamic gameId;

typedef struct PB4MatchUserGameStatusReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  int32_t gameId;
} PB4MatchUserGameStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserGameStatusReq_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchUserGameStatusReq__storage_, roomId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = PB4MatchUserGameStatusReq_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4MatchUserGameStatusReq__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserGameStatusReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserGameStatusReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4MatchUserGameStatusRes

@implementation PB4MatchUserGameStatusRes

@dynamic matchStatus;

typedef struct PB4MatchUserGameStatusRes__storage_ {
  uint32_t _has_storage_[1];
  PB4MatchStatusType matchStatus;
} PB4MatchUserGameStatusRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchStatus",
        .dataTypeSpecific.enumDescFunc = PB4MatchStatusType_EnumDescriptor,
        .number = PB4MatchUserGameStatusRes_FieldNumber_MatchStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4MatchUserGameStatusRes__storage_, matchStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4MatchUserGameStatusRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4MatchUserGameStatusRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4MatchUserGameStatusRes_MatchStatus_RawValue(PB4MatchUserGameStatusRes *message) {
  GPBDescriptor *descriptor = [PB4MatchUserGameStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchUserGameStatusRes_FieldNumber_MatchStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4MatchUserGameStatusRes_MatchStatus_RawValue(PB4MatchUserGameStatusRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4MatchUserGameStatusRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4MatchUserGameStatusRes_FieldNumber_MatchStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4InterestConfReq

@implementation PB4InterestConfReq


typedef struct PB4InterestConfReq__storage_ {
  uint32_t _has_storage_[1];
} PB4InterestConfReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4InterestConfReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4InterestConfReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4InterestConfRes

@implementation PB4InterestConfRes

@dynamic listArray, listArray_Count;
@dynamic maxInterestNum;
@dynamic sex;

typedef struct PB4InterestConfRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxInterestNum;
  PB4PluginSexType sex;
  NSMutableArray *listArray;
} PB4InterestConfRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4InterestItem),
        .number = PB4InterestConfRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4InterestConfRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxInterestNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4InterestConfRes_FieldNumber_MaxInterestNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4InterestConfRes__storage_, maxInterestNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4InterestConfRes_FieldNumber_Sex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4InterestConfRes__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4InterestConfRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4InterestConfRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4InterestConfRes_Sex_RawValue(PB4InterestConfRes *message) {
  GPBDescriptor *descriptor = [PB4InterestConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4InterestConfRes_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4InterestConfRes_Sex_RawValue(PB4InterestConfRes *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4InterestConfRes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4InterestConfRes_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4InterestItem

@implementation PB4InterestItem

@dynamic id_p;
@dynamic name;

typedef struct PB4InterestItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *name;
} PB4InterestItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4InterestItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4InterestItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PB4InterestItem_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4InterestItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4InterestItem class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4InterestItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SetMyInterestReq

@implementation PB4SetMyInterestReq

@dynamic interestIdsArray, interestIdsArray_Count;

typedef struct PB4SetMyInterestReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *interestIdsArray;
} PB4SetMyInterestReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interestIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4SetMyInterestReq_FieldNumber_InterestIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4SetMyInterestReq__storage_, interestIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SetMyInterestReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SetMyInterestReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SetMyInterestRes

@implementation PB4SetMyInterestRes


typedef struct PB4SetMyInterestRes__storage_ {
  uint32_t _has_storage_[1];
} PB4SetMyInterestRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SetMyInterestRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4SetMyInterestRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SetNavSortReq

@implementation PB4SetNavSortReq

@dynamic navIdsArray, navIdsArray_Count;

typedef struct PB4SetNavSortReq__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *navIdsArray;
} PB4SetNavSortReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4SetNavSortReq_FieldNumber_NavIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4SetNavSortReq__storage_, navIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SetNavSortReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SetNavSortReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SetNavSortRes

@implementation PB4SetNavSortRes


typedef struct PB4SetNavSortRes__storage_ {
  uint32_t _has_storage_[1];
} PB4SetNavSortRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SetNavSortRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4SetNavSortRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PushUpdateAction

@implementation PB4PushUpdateAction

@dynamic id_p;
@dynamic dataType;
@dynamic dataByte;
@dynamic filterArray, filterArray_Count;

typedef struct PB4PushUpdateAction__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  PB4PHomeDataType dataType;
  NSData *dataByte;
  GPBEnumArray *filterArray;
} PB4PushUpdateAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PushUpdateAction_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PushUpdateAction__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = PB4PHomeDataType_EnumDescriptor,
        .number = PB4PushUpdateAction_FieldNumber_DataType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PushUpdateAction__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dataByte",
        .dataTypeSpecific.className = NULL,
        .number = PB4PushUpdateAction_FieldNumber_DataByte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PushUpdateAction__storage_, dataByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "filterArray",
        .dataTypeSpecific.enumDescFunc = PB4FilterRule_EnumDescriptor,
        .number = PB4PushUpdateAction_FieldNumber_FilterArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PushUpdateAction__storage_, filterArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PushUpdateAction class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PushUpdateAction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PushUpdateAction_DataType_RawValue(PB4PushUpdateAction *message) {
  GPBDescriptor *descriptor = [PB4PushUpdateAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PushUpdateAction_FieldNumber_DataType];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PushUpdateAction_DataType_RawValue(PB4PushUpdateAction *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PushUpdateAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PushUpdateAction_FieldNumber_DataType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PushModActionReset

@implementation PB4PushModActionReset

@dynamic id_p;

typedef struct PB4PushModActionReset__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
} PB4PushModActionReset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PushModActionReset_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PushModActionReset__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PushModActionReset class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PushModActionReset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PhomeNavRed

@implementation PB4PhomeNavRed

@dynamic navRedArray, navRedArray_Count;

typedef struct PB4PhomeNavRed__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *navRedArray;
} PB4PhomeNavRed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navRedArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4NavRed),
        .number = PB4PhomeNavRed_FieldNumber_NavRedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PhomeNavRed__storage_, navRedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PhomeNavRed class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PhomeNavRed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4NavRed

@implementation PB4NavRed

@dynamic id_p;
@dynamic subNavArray, subNavArray_Count;

typedef struct PB4NavRed__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSMutableArray *subNavArray;
} PB4NavRed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4NavRed_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4NavRed__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subNavArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4SubNavRed),
        .number = PB4NavRed_FieldNumber_SubNavArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4NavRed__storage_, subNavArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4NavRed class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4NavRed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4SubNavRed

@implementation PB4SubNavRed

@dynamic id_p;
@dynamic redNum;

typedef struct PB4SubNavRed__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t redNum;
} PB4SubNavRed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4SubNavRed_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4SubNavRed__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "redNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4SubNavRed_FieldNumber_RedNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4SubNavRed__storage_, redNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4SubNavRed class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4SubNavRed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearNavRedReq

@implementation PB4ClearNavRedReq

@dynamic navId;
@dynamic subNavId;

typedef struct PB4ClearNavRedReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t navId;
  int32_t subNavId;
} PB4ClearNavRedReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navId",
        .dataTypeSpecific.className = NULL,
        .number = PB4ClearNavRedReq_FieldNumber_NavId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4ClearNavRedReq__storage_, navId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subNavId",
        .dataTypeSpecific.className = NULL,
        .number = PB4ClearNavRedReq_FieldNumber_SubNavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4ClearNavRedReq__storage_, subNavId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearNavRedReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4ClearNavRedReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4ClearNavRedRes

@implementation PB4ClearNavRedRes


typedef struct PB4ClearNavRedRes__storage_ {
  uint32_t _has_storage_[1];
} PB4ClearNavRedRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4ClearNavRedRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4ClearNavRedRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PlayerSystemMsgSummayReq

@implementation PB4PlayerSystemMsgSummayReq


typedef struct PB4PlayerSystemMsgSummayReq__storage_ {
  uint32_t _has_storage_[1];
} PB4PlayerSystemMsgSummayReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PlayerSystemMsgSummayReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PB4PlayerSystemMsgSummayReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PlayerSystemMsgSummayRes

@implementation PB4PlayerSystemMsgSummayRes

@dynamic listsArray, listsArray_Count;

typedef struct PB4PlayerSystemMsgSummayRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listsArray;
} PB4PlayerSystemMsgSummayRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4SystemMiscMsgItem),
        .number = PB4PlayerSystemMsgSummayRes_FieldNumber_ListsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PlayerSystemMsgSummayRes__storage_, listsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PlayerSystemMsgSummayRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PlayerSystemMsgSummayRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsPhotosReq

@implementation PB4CommunityTrendsPhotosReq

@dynamic index;
@dynamic playerId;
@dynamic trendId;
@dynamic lastId;

typedef struct PB4CommunityTrendsPhotosReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t lastId;
  int64_t playerId;
  int64_t trendId;
} PB4CommunityTrendsPhotosReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosReq_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "playerId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosReq_FieldNumber_PlayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosReq__storage_, playerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosReq_FieldNumber_TrendId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosReq__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosReq_FieldNumber_LastId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosReq__storage_, lastId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsPhotosReq class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsPhotosReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4CommunityTrendsPhotosRes

@implementation PB4CommunityTrendsPhotosRes

@dynamic listArray, listArray_Count;
@dynamic index;
@dynamic trendId;
@dynamic lastId;
@dynamic isEnd;

typedef struct PB4CommunityTrendsPhotosRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t lastId;
  NSMutableArray *listArray;
  int64_t trendId;
} PB4CommunityTrendsPhotosRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4Photo),
        .number = PB4CommunityTrendsPhotosRes_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosRes__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosRes_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosRes__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosRes_FieldNumber_TrendId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosRes__storage_, trendId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastId",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosRes_FieldNumber_LastId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4CommunityTrendsPhotosRes__storage_, lastId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isEnd",
        .dataTypeSpecific.className = NULL,
        .number = PB4CommunityTrendsPhotosRes_FieldNumber_IsEnd,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4CommunityTrendsPhotosRes class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4CommunityTrendsPhotosRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCPInfoList

@implementation PB4PHomeCPInfoList

@dynamic listArray, listArray_Count;
@dynamic sameSexListArray, sameSexListArray_Count;

typedef struct PB4PHomeCPInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  NSMutableArray *sameSexListArray;
} PB4PHomeCPInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCPInfo),
        .number = PB4PHomeCPInfoList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfoList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sameSexListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PB4PHomeCPInfo),
        .number = PB4PHomeCPInfoList_FieldNumber_SameSexListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfoList__storage_, sameSexListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCPInfoList class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCPInfoList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PB4PHomeCPInfo

@implementation PB4PHomeCPInfo

@dynamic imageURL;
@dynamic voiceURL;
@dynamic condition;
@dynamic voiceTime;
@dynamic voiceId;
@dynamic sex;
@dynamic id_p;
@dynamic anchorNum;
@dynamic index;
@dynamic isShowTone;

typedef struct PB4PHomeCPInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t voiceTime;
  int32_t voiceId;
  PB4PluginSexType sex;
  int32_t id_p;
  int32_t anchorNum;
  int32_t index;
  NSString *imageURL;
  NSString *voiceURL;
  NSString *condition;
} PB4PHomeCPInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_ImageURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_VoiceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "condition",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_Condition,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_VoiceTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "voiceId",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_VoiceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, voiceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = PB4PluginSexType_EnumDescriptor,
        .number = PB4PHomeCPInfo_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_Id_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "anchorNum",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_AnchorNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, anchorNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_Index,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PB4PHomeCPInfo__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isShowTone",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPInfo_FieldNumber_IsShowTone,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCPInfo class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCPInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\241!!\000\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PB4PHomeCPInfo_Sex_RawValue(PB4PHomeCPInfo *message) {
  GPBDescriptor *descriptor = [PB4PHomeCPInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeCPInfo_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetPB4PHomeCPInfo_Sex_RawValue(PB4PHomeCPInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [PB4PHomeCPInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PB4PHomeCPInfo_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PB4PHomeCPPlayer

@implementation PB4PHomeCPPlayer

@dynamic picURL;
@dynamic voiceURL;
@dynamic voiceTime;
@dynamic labelsArray, labelsArray_Count;

typedef struct PB4PHomeCPPlayer__storage_ {
  uint32_t _has_storage_[1];
  int32_t voiceTime;
  NSString *picURL;
  NSString *voiceURL;
  NSMutableArray *labelsArray;
} PB4PHomeCPPlayer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "picURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPPlayer_FieldNumber_PicURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PB4PHomeCPPlayer__storage_, picURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPPlayer_FieldNumber_VoiceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PB4PHomeCPPlayer__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceTime",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPPlayer_FieldNumber_VoiceTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PB4PHomeCPPlayer__storage_, voiceTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = NULL,
        .number = PB4PHomeCPPlayer_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PB4PHomeCPPlayer__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PB4PHomeCPPlayer class]
                                     rootClass:[PB4PhomeExtRoot class]
                                          file:PB4PhomeExtRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PB4PHomeCPPlayer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\003\241!!\000\002\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
